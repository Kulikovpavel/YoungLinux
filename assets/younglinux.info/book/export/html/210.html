<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Управление процессами</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
              <div class="section-1">
                <div class="section-2">
          
    <div id="node-210" class="section-3">
  <h1 class="book-heading">Управление процессами</h1>
  <h2>Работа для системного администратора</h2>
<p>Хотя управление системными ресурсами, включая процессы, является задачей местного системного администратора, но и обычному пользователю не повредит кое-что узнать об этом, особенно в той части, которая касается оптимального выполнения его или ее собственных процессов.</p>
<p>Мы немного расскажем на теоретическом уровне о производительности системы, но не будем касаться оптимизации оборудования и других продвинутых процедур. Вместо этого мы изучим насущные проблемы, с которыми сталкивается обычный пользователь, и действия, которые пользователь может предпринять для обеспечения оптимального использования имеющихся ресурсов. Как мы узнаем в следующем разделе, следует поразмыслить, прежде чем действовать.</p>
<p><strong>Рисунок 4.2. Ты не мог бы идти побыстрее?</strong></p>
<div style="text-align:center;"><img src="../../../img/linuxintro/trappen.png" width="497" height="526" alt="Пользователь хочет, чтобы процессы выполнялись быстрее." /></div>
<h2>Сколько времени это займет?</h2>
<p>Bash предоставляет встроенную команду <strong>time</strong>, которая отображает, сколько времени занимает выполнение команды. Она рассчитывает время с высокой точностью и может быть использована с любой командой. В примере ниже,  проходит около полторы минуты <span style="background-color:yellow;">to make this book</span>:</p>
<pre>
tilly:~/xml/src> <strong>time make</strong>
Output written on abook.pdf (222 pages, 1619861 bytes).
Transcript written on abook.log.

real	1m41.056s
user	1m31.190s
sys	0m1.880s
</pre><p>
Команда GNU <strong>time</strong> в <span class="mono">/usr/bin</span> (в отличие от версии, встроенной в shell) отображает больше информации, которая может быть отформатирована различными способами. Она также показывает статус завершения команды и общее истекшее время. Такая же команда, как выше, использующая независимый <strong>time</strong>, дает следующий вывод:</p>
<pre>
tilly:~/xml/src> <strong>/usr/bin/time make</strong>
Output written on abook.pdf (222 pages, 1595027 bytes).
Transcript written on abook.log.

Command exited with non-zero status 2
88.87user 1.74system 1:36.21elapsed 94%CPU 
				(0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (2192major+30002minor)pagefaults 0swaps
</pre><p>
Для получения полной информации снова обратитесь к info-страницам.</p>
<h2>Исполнение</h2>
<p>Для пользователей эффективность означает быстрое выполнение команд. Для системного администратора, с другой стороны, это означает гораздо больше: администратор оптимизирует производительность всей системы, включая пользователей, все программы и демоны. Производительность системы может зависеть от тысячи незначительных вещей, которые не учитываются командой <strong>time</strong>:</p>
<ul>
<li>выполняющаяся программа плохо написана или использует компьютер надлежащим образом</li>
<li>доступ к дискам, контроллерам, дисплею и всем другим видам интерфейсов</li>
<li>достижимость удаленных систем (производительность сети)</li>
<li>количество пользователей в системе, количество пользователей, одновременно работающих на самом деле.</li>
<li>время дня</li>
<li>...</li>
</ul>
<h2>Нагрузка</h2>
<p>Короче говоря, нагрузка зависит от того, что является нормальным для вашей системы. На моем старом P133 работает брандмауэр, SSH сервер, файловый сервер, служба маршрутизации, sendmail сервер, прокси сервер и некоторые другие службы, все они не жалуются на семь подключенных пользователей; нагрузка по-прежнему 0 или в пределах нормы. Некоторые (многопроцессорные) системы, которые я видела, были вполне счастливы с нагрузкой в 67. Существует только один способ узнать, что нагрузка нормальна, - это проверять ее регулярно. Если так не делать, вы только сможете оценить загрузку системы по времени отклика в командной строке, что является очень грубым измерением, поскольку эта скорость зависит от сотни других причин.</p>
<p>Имейте в виду, что разные системы будут вести себя по-разному с одной и той же средней нагрузкой. Например, системе с видеокартой, поддерживающей аппаратное ускорение, не будет иметь никаких проблем при прорисовке 3D изображений, в то же время в такой же системе с VGA видеокартой будет чрезвычайно замедленное время рендеринга. Мой старый P133 будет довольно неудобен, когда я запущу Х-сервер, но на современной системе вы вряд ли заметите разницу в нагрузке на систему.</p>
<h2>Я могу что-нибудь сделать как пользователь?</h2>
<p>Большое окружение замедляет работу. Если у вас установлено множество переменных окружения (вместо переменных оболочки), длинных путей поиска, которые не оптимизированы (ошибки в настройках переменной окружения PATH), и присутствует много настроек, которые обычно делаются "на лету", системе будет требоваться больше времени на поиск и чтение данных.</p>
<p>В X, оконные менеджеры и среды рабочего стола могут действительно «съедать» процессор. На самом деле приходится расплачиваться за фантастический рабочий стол, даже если вы можете скачать его бесплатно, поскольку большинство десктопов снабжаются дополнениями до бесконечности. Скромность окажется  добродетелью, если вы не покупаете новый компьютер каждый год.</p>
<h3>Приоритет</h3>
<p>Приоритет или важность работы определяется ее числом <em>nice</em>. Программа с большим nice-числом дружественна к другим программам, другим пользователям и системе; т.е. эта программа - не важное дело. Низкое nice-число обозначает более важное задание, которое потребует больше ресурсов, не делясь ими.</p>
<p>Улучшение выполнения задания за счет увеличения его nice-числа полезно только для процессов, которые используют много процессорного времени (компиляторы, математические приложения и т.п.). Процессы, которые постоянно обращаются к вводу/выводу имеют более высокий приоритет (низкое nice-число), например,  ввод с клавиатуры всегда получает наивысший приоритет в системе.</p>
<p>Определение приоритетов программ осуществляется с помощью команды <strong>nice</strong>.</p>
<p>Большинство систем также предоставляют команду BSD <strong>renice</strong>, которая позволяет изменять дружелюбность выполняющейся команды. Опять же, читайте man-страницы для получения системно-специфичной информации.</p>
<p class="note"><img src="../../../img/linuxintro/caution.gif" alt="" /><strong> Интерактивные программы.</strong><br />
Плохая идея, выполнять nice или renice по отношению к интерактивной программе или заданию, работающему на переднем плане.</p>
<p>Использование этих команд, как правило, является задачей системного администратора. Читайте man-страницы для дополнительной информации о дополнительной функциональности, доступной для системного администратора.</p>
<h3>Ресурсы процессора</h3>
<p>На каждой системе Linux множество программ одновременно нуждаются в ресурсах процессора(ов), даже в том случае, если вы являетесь единственным пользователем в системе. Каждая программа для работы нуждается в определенном количестве циклов центрального процессора. Бывают случаи, когда циклов процессора недостаточно, поскольку он слишком занят. Команда <strong>uptime</strong>  чрезвычайно неточна (отображает только средние, вы должны знать, что это нормально), но далеко не бесполезна. Есть некоторые действия, которые можно предпринять, если вы думаете, что ваш процессор является причиной зависания вашей системы:</p>
<ul>
<li>Выполняйте тяжелые программы, когда нагрузка невелика. Это можно делать в вашей системе в ночное время. См. следующий раздел про планирование.</li>
<li>Предотвращайте систему от выполнения ненужной работы: остановите демонов и программы, которые вы не используете, используйте <strong>locate</strong> вместо тяжелой <strong>find</strong>, ...</li>
<li>Выполняйте больше заданий с низким приоритетом.</li>
<li></li>
</ul>
<p>Если ни одно из этих решений не вариант в вашей конкретной ситуации, вы можете обновить процессор. На машине UNIX это работа для системного администратора.</p>
<h3>Ресурсы памяти</h3>
<p>Когда текущие работающие процессы ожидают больше памяти, чем доступно физически в системе, Linux не разрушится; она начнет подкачку или своппинг, смысл в том, что процесс использует память на диске или из пространства подкачки, перемещая содержимое физической памяти (части работающих программ или целых программ в случае своппинга) на диск, тем самым давая физической памяти обрабатывать несколько процессов. Это в достаточной степени замедляет работу системы, поскольку доступ к диску намного медленнее, чем доступ к памяти. Команда <strong>top</strong> может быть использована для отображения того,  насколько память и подкачка используются. Системы, использующие glibc, предлагают команды <strong>memusage</strong> и <strong>memusagestat</strong> для визуализации использования памяти.</p>
<p>Если вы обнаружите, что используется много памяти и пространства подкачки, вы можете попробовать:</p>
<ul>
<li>Прерывание, остановку или переопределение nice для тех программ, которые используют большую часть памяти.</li>
<li>Добавление дополнительной памяти (а в некоторых случаях больше пространства подкачки) системе.</li>
<li>Настройка производительности системы, что выходит за рамки этого документа. См. список в <a href="http://younglinux.info/#">Приложении А, «Куда идти дальше?»</a> за дополнением.</li>
</ul>
<h3>Ресурсы I/O (ввода/вывода)</h3>
<p>Хотя ограничения ввода-вывода являются основной причиной стресса системных администраторов, системы Linux предлагает довольно бедные утилиты для измерения I/O производительности. Инструменты <strong>ps</strong>, <strong>vmstat</strong> и <strong>top</strong> дают некоторое представление о том, сколько программ ждут ввода-вывода; <strong>netstat</strong> отображает интерфейс сетевой статистики, но в сущности нет инструментов нормального измерения I/O отклика при загрузке системы, а команда <strong>iostat</strong> дает краткий обзор общего I/O использования. Существуют различные графические приложения для отображения вывода этих команд в понятном виде.</p>
<p>Каждое устройство имеет свои собственные проблемы, но пропускная способность сетевых интерфейсов и пропускная способность дисков два основных узких места в производительности ввода-вывода.</p>
<p>Сетевые I/O проблемы:</p>
<ul>
<li>Сетевые перегрузки:</li>
</ul>
<p>Количество данных, передаваемых по сети больше возможностей сети, в результате медленное выполнение каждой связанной с сетью задачи для всех пользователей. Это может быть решено путем очистки сети (которая в основном заключается в отключении протоколов и услуг, которые вам не нужны), либо путем реконфигурации сети (например, использование подсетей, замена узлов с переключателями, модернизация интерфейсов и оборудования).</p>
<ul>
<li>Проблемы сетевой целостности:</li>
</ul>
<p>Случается, когда данные передаются неправильно. Решение такого рода проблем может быть выполнено только путем изоляции неисправного элемента и его заменой.</p>
<p>Дисковые I/O проблемы:</p>
<ul>
<li>для каждого процесса скорость передачи слишком низкая:</li>
</ul>
<p>Скорость чтения и записи для определенного процесса не является достаточной.</p>
<ul>
<li>совокупная скорость передачи слишком низкая:</li>
</ul>
<p>Максимум общей пропускной способности, которые система может обеспечить для всех выполняющихся программ, недостаточна.</p>
<p>Обнаружить такого рода проблемы сложнее, и обычно это требует дополнительное оборудование для того, чтобы разделить потоки данных по шинам, контроллерам и дискам, если причина проблемы — это перегрузка оборудования. Одним из решений этого является оптимизированная конфигурация RAID-массива для действий ввода-вывода. Так у вас появляется возможность остаться при том же оборудовании. Перед обновлением пропускной способности шин, контроллеров и дисков всегда можно попробовать другие варианты.</p>
<p>Если перегрузка не является причиной, может быть, ваше оборудование постепенно портится, или неправильно подключено к системе. Проверьте контакты, соединители и разъемы для начала.</p>
<h3>Пользователи</h3>
<p>Пользователи могут быть разделены на несколько классов в зависимости от их отношения к использованию ресурсов:</p>
<ul>
<li>Пользователи, которые запускают большое число маленьких заданий: вы, начинающий пользователь Linux, например.</li>
<li>Пользователи, которые запускают относительно немного, но больших заданий: пользователи, работающие с моделированием, расчетами, эмуляторами или другими программами, которые съедают много памяти, и обычно этих пользователей сопровождает большой объем файлов данных.</li>
<li>Пользователи, которые запускают немного заданий, но используют много процессорного времени (разработчики и т.п.).</li>
</ul>
<p>Вы можете видеть, что системные требования могут отличаться для каждого класса пользователей, и поэтому сложно удовлетворить каждого. Если вы работаете на многопользовательской системе, полезно (и приятно) узнать привычки других пользователей системы, с тем чтобы получить максимальную отдачу от ее для выполнения ваших конкретных задач.</p>
<h3>Графические инструменты</h3>
<p>Для графической среды доступен целый букет инструментов мониторинга. Ниже приведен снимок экрана Системного Монитора Gnome, который способен отображать и искать информацию о процессах и контролировать системные ресурсы:</p>
<p><strong>Рисунок 4.3. Системный Монитор Gnome</strong><br />
<img src="../../../img/linuxintro/system-monitor.png" width="465" height="527" alt="Системный монитор Gnome" /></p>
<p>Также существует несколько полезных иконок, которые вы можете установить на панели задач, таких как мониторы диска, памяти и загруженности. <strong>Xload</strong> - это другое небольшое приложение X для мониторинга загрузки системы. Определитесь сами со своими предпочтениями.</p>
<h3>Прерывание ваших процессов</h3>
<p>Как непривилегированный пользователь, вы можете влиять только на собственные процессы. Мы уже видели, как вы можете отображать процессы и отфильтровывать процессы, относящиеся к конкретному пользователю, а также знаете, какие могут  произойти возможные ограничения. Когда вы видите, что один из ваших процессов потребляет слишком много системных ресурсов, есть две вещи, которые вы можете сделать:</p>
<ul>
<li>Заставить процесс использовать меньше ресурсов, не прерывая его;</li>
<li>Остановить процесс вообще.</li>
</ul>
<p>В случае, если вы хотите, чтобы процесс продолжил работу, но также хотите дать шанс другим процессам в системе, вы можете переопределить <em>nice</em> процесса. Наряду с использованием команд <strong>nice</strong> или <strong>renice</strong>, <strong>top</strong> является простым способом обнаружения процесса(ов), причиняющего беспокойство, и снижения приоритета.</p>
<p>Узнайте процесс в столбце "NI", у него, скорее всего, будет отрицательный приоритет. Наберите r и введите ID процесса, для которого вы хотите переопределить число <em>nice</em>. Затем введите значение nice, например, "20". Это означает, что отныне этот процесс будет занимать самое большое 1/5 циклов процессора.</p>
<p>Примеры процессов, которые вы захотите сохранить в рабочем состоянии, — это эмуляторы, виртуальные машины, компиляторы и т.д.</p>
<p>Если вы хотите остановить процесс, потому что он висит или собирается полностью вывести из рабочего состояния ввод-вывод, создание файла или использование других ресурсов системы, используйте команду <strong>kill</strong>. Если у вас есть возможность, попробуйте сначала завершить процесс "по тихому", отправив ему сигнал SIGTERM. Это указание к прекращению любой активности в соответствии с процедурами, описанными в коде программы:</p>
<pre>
joe:~> <strong>ps -ef | grep <em>mozilla</em></strong>
joe    25822	1  0 Mar11 ?	00:34:04 /usr/lib/mozilla-1.4.1/mozilla-

joe:~> <strong>kill -15 <em>25822</em></strong>
</pre><p>
В приведенном выше примере, пользователь <em>joe</em> остановил его браузер Mozilla, поскольку он подвис.</p>
<p>От некоторых процессов избавиться немного труднее. Если у вас есть время, вы можете отправить им сигнал SIGINT, прервав их. Если этот трюк не сработает, используйте самый сильный сигнал SIGKILL. В приведенном ниже примере <em>joe</em> останавливается Mozilla, которая повисла окончательно:</p>
<pre>
joe:~> <strong>ps -ef | grep <em>mozilla</em></strong>
joe    25915	1  0 Mar11 ?	00:15:06 /usr/lib/mozilla-1.4.1/mozilla-

joe:~> <strong>kill -9 <em>25915</em></strong>

joe:~> <strong>ps -ef | grep <em>25915</em></strong>
joe	2634 32273 0 18:09 pts/4   00:00:00 grep 25915
</pre><p>
В таких случаях вы можете захотеть проверить, что этот процесс действительно прерван, используя фильтр <strong>grep</strong> опять же по PID. Если это возвращает только процесс <strong>grep</strong>, вы можете быть уверены, что вам удалось остановить тот процесс.</p>
<p>Среди процессов есть те, которые сложно прервать в вашей оболочке. И это хорошо: если бы их можно было легко прервать, то вы бы теряли вашу оболочку каждый раз при случайном вводе <strong>Ctrl-C</strong> в командной строке, т.к. это равносильно отправке SIGINT.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> UNIX без конвейеров почти немыслим.</strong><br />
Использование вертикальной черты (|) при использовании выводов одной команды в качестве входных данных другой объясняется в следующей главе, <a href="http://younglinux.info/#">Глава 5, "Перенаправление ввода-вывода"</a>.</p>
<p>В графической среде, программа <strong>xkill</strong> очень проста в использовании. Просто введите имя команды, затем нажмите Enter и выберите в окне приложение, которое вы хотите остановить. Это довольно опасно, потому что программа отправляет  SIGKILL по умолчанию, поэтому используйте ее, только когда приложение зависает.</p>
  </div>
    </div></div>
  </body>
</html>
