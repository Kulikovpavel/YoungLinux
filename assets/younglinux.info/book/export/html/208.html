<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Процессы изнутри</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
              <div class="section-1">
                <div class="section-2">
          
    <div id="node-208" class="section-3">
  <h1 class="book-heading">Процессы изнутри</h1>
  <h2>Многопользовательская работа и многозадачность</h2>
<p>Теперь, когда мы уже привыкли к нашему окружению и способны немного взаимодействовать с нашей системой, самое время для более детального изучения процессов. Не все команды запускают единственный процесс. Некоторые из них начинают целый ряд процессов, например, <strong>mozilla</strong>; другие, как <strong>ls</strong>, выполняются как единственная команда.</p>
<p>Кроме того, Linux основан на UNIX, где это является обычной практикой при многочисленных пользователях, запускающих множество команд в одно и то же время в одной и той же системе. Очевидно, что были приняты меры, чтобы  процессор управлял всеми этими процессами, и обеспечивалась функциональность, когда пользователи могут переключаться между процессами. В некоторых случаях процессы должны продолжать работать, даже если пользователь, который их запустил, вышел из системы. С другой стороны, пользователи нуждаются в средствах для прерывания процессов.</p>
<p>В следующих разделах мы расскажем об устройстве процессов в Linux.</p>
<h2>Типы процессов</h2>
<h3>Интерактивные процессы</h3>
<p>Интерактивные процессы инициализируется и контролируется через терминальную сессию. Иными словами, кто-то должен быть подключен к системе, чтобы эти процессы запустились; они не запускаются автоматически, как часть функциональности системы. Эти процессы могут работать на переднем плане, занимая терминал, который запустил программу, и вы не сможете запускать другие приложения до тех пор, как этот процесс работает таким образом. Иначе они могут работать в фоновом режиме, таким образом, терминал, в котором вы запустили программу, может принимать новые команды, пока та программа тоже работает. До сих пор мы в основном уделяли внимание программам, работающим на переднем плане - продолжительность времени, необходимого для их работы, была слишком короткой, чтобы заметить - но просмотр файлов командой less - хороший пример, когда команда занимает терминал сессии. В этом случае, активная программа ожидает от вас какого-нибудь действия. Программа по-прежнему связана с терминалом, откуда она была запущена, а терминал пригоден только для ввода команд для этой программы, только их он может понять. Другие команды просто приведут к ошибкам или зависанию системы.</p>
<p>Несмотря на то, что процесс выполняется в фоновом режиме, пользователь все равно не имеет возможности делать другие вещи в терминале, в котором он запустил программу, пока программа работает.</p>
<p>Оболочка предлагает функцию управления заданиями, которая позволяет легко обрабатывать множество процессов. Этот механизм переключает процессы между передним и задним фоном. Используя эту систему, программы также могут быть запущены в фоновом режиме сразу же.</p>
<p>Запуск процесса в фоновом режиме, имеет смысл только для программ, которые не нуждаются в пользовательском контроле (через shell). Перевод задания  в фоновый режим делается, как правило, когда для его выполнения, как ожидается, потребует длительного времени. Для того, чтобы освободить выдачу терминала после ввода команды, добавляется завершающий амперсанд. В примере, используя графический режим, мы открываем дополнительное окно терминала из имеющегося:</p>
<pre>
billy:~> <strong>xterm &</strong>
[1] 26558

billy:~> <strong>jobs</strong>
[1]+  Running                 xterm &
</pre><p>
Подробное описание функции контроля заданий есть в info-страницах <strong>bash</strong>, так что здесь перечислены только наиболее часто используемые способы управления заданиями:</p>
<p><strong>Таблица 4.1. Управление процессами</strong></p>
<table class="il">
<tr>
<td width="150"><strong>Команды (часть из существующих)</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td><strong>regular_command</strong></td>
<td>Запуск данной команды на переднем плане.</td>
</tr>
<tr>
<td><strong>command &amp;</strong></td>
<td>Запуск команды в фоновом режиме (в версии терминала).</td>
</tr>
<tr>
<td><strong>jobs</strong></td>
<td>Показывает команды запущенные в фоновом режиме.</td>
</tr>
<tr>
<td><strong>Ctrl+Z</strong></td>
<td>Приостановить (остановить, но не выйти) процесс, выполняемый на переднем плане (засыпание).</td>
</tr>
<tr>
<td><strong>Ctrl+C</strong></td>
<td>Прервать (прекратить и выйти) процесс, выполняемый на переднем плане.</td>
</tr>
<tr>
<td><span class="monoi">%n</span></td>
<td>Каждый процесс, выполняемый в фоновом режиме, получает присвоенный ему номер. Используя выражение %, указание может быть отнесено к процессу путем использования его номера, например, <strong>fg </strong> <span class="mono">%2</span>.</td>
</tr>
<tr>
<td><strong>bg</strong></td>
<td>Возобновить приостановленную программу в фоновом режиме.</td>
</tr>
<tr>
<td><strong>fg</strong></td>
<td>Поместить фоновое задание на передний план.</td>
</tr>
<tr>
<td><strong>kill</strong></td>
<td>Завершение процесса (см. также Shell Builtin Commands на info-страницах <strong>bash</strong>).</td>
</tr>
</table>
<p>Подробные практические примеры можно найти в упражнениях.</p>
<p>Большинство UNIX систем, вероятно, могут быть способны запустить экран, который полезен, когда вам действительно нужна еще одна оболочка для выполнения команд. После вызова экрана, новая сессия создается с сопутствующей оболочкой и/или командами, которые указаны и которые вы можете отложить в сторону. В этой новой сессии вы можете делать все, что вы хотите. Все программы и операции будут работать независимо от выдачи оболочки. Затем вы можете отделить эту сессию, пока программы, которые вы запустили в ней, продолжат работать, даже когда вы выйдите из оболочки давшей начало, и выберите экран снова в любое удобное для вас время.</p>
<p>Эта программа берет свое начало со времени, когда виртуальные консоли еще не придумали, и все должно было быть сделано с помощью одного текстового терминала. Для увлеченных это все еще имеет значение в Linux, хотя уже почти 10 лет у нас есть виртуальные консоли.</p>
<h3>Автоматические процессы</h3>
<p> Автоматические или пакетные процессы не связаны с терминалом. Скорее, это такие задачи, которые могут быть поставлены в очередь области диспетчера печати, где они ожидают выполнения по принципу FIFO (первый вошел, первый вышел). Такие задачи могут быть выполнены с помощью одного из двух критериев:</p>
<ul>
<li>В определенную дату и время: выполнение, используя команду <strong>at</strong>, которую мы обсудим во второй части этой главы.</li>
<li>В периоды, когда общая загруженность системы достаточно низка, чтобы принять дополнительные работы: делается с помощью команды <strong>batch</strong>. По умолчанию задачи ставятся в очередь, где они ожидают выполнения в период, когда загрузка системы будет меньше, чем 0,8. В больших средах системный администратор может отдать предпочтение пакетной обработке, когда должны быть обработаны большие объемы данных или когда выполнение задач требуют много системных ресурсов в уже загруженной системе. Пакетная обработка используется также для оптимизации производительности системы.</li>
</ul>
<h3>Демоны</h3>
<p>Демоны — это серверные процессы, которые работают постоянно. В большинстве случаев они инициализируются при запуске системы, и затем ожидают в фоновом режиме до того, как их услуги потребуются. Типичным примером является сетевой демон <em>xinetd</em>, которая запускается почти при каждой процедуре загрузки. После того как система загрузится, сетевой демон просто сидит и ждет клиентскую программу, которую необходимо подключить, такую как, например, FTP-клиент.</p>
<h2>Свойства процессов</h2>
<p>Процесс имеет ряд особенностей, которые могут быть просмотрены с помощью команды <strong>ps</strong>:</p>
<ul>
<li>Идентификатор процесса или PID: уникальный идентификационный номер, используемый для обращения к процессу.</li>
<li>ID родительского процесса или PPID: номер процесса (PID), который запустил данный процесс.</li>
<li>Nice-число: степень дружелюбия этого процесса по отношению к другим процессам (не путать с приоритетом процесса, который рассчитывается на основе этого милого числа и последнего использования процессора этим процессом).</li>
<li>Терминал или TTY: терминал, к которому привязан данный процесс.</li>
<li>Имя реального и эффективного пользователя (RUID и EUID): владелец процесса. Реальным владельцем является пользователь, который ввел команду, эффективный пользователь — тот, кто определяет порядок доступа к системным ресурсам. RUID и EUID обычно это одно и то же, и процесс имеет те же права доступа, которые есть у пользователя его запустившего. Поясним это на примере: браузер <strong>mozilla</strong>, находящийся в <span class="mono">/usr/bin</span>, принадлежит пользователю <em>root</em>:</li>
</ul>
<pre>
theo:~> <strong>ls -l /usr/bin/mozilla</strong>
-rwxr-xr-x  1 root   root      4996 Nov 20 18:28 /usr/bin/mozilla*

theo:~> <strong>mozilla &</strong>
[1] 26595

theo:~> <strong>ps -af</strong>
UID     PID  PPID C STIME TTY       TIME CMD
theo  26601 26599 0 15:04 pts/5 00:00:00 /usr/lib/mozilla/mozilla-bin
theo  26613 26569 0 15:04 pts/5 00:00:00 ps -af
</pre><p>
Когда пользователь <em>theo</em> запускает эту программу, сам процесс и все процессы, запущенные им, будут принадлежать пользователю <em>theo</em>, а не системному администратору. Когда <strong>mozilla</strong> будет требовать доступ к определенным файлам, то доступ будет зависеть от разрешений <em>theo</em>, а не администратора.</p>
<ul>
<li>Реальная и эффективная группы владельца (RGID и EGID): реальной группой- владельцем процесса является основная группа пользователя, запустившего процесс. Эффективная группа-владелец - обычно то же самое, за исключением случаев, когда режим доступа SGID применяется к файлу.</li>
</ul>
<h2>Просмотр информации о процессе</h2>
<p>Команда <strong>ps</strong> является одним из инструментов для визуализации процессов. Эта команда имеет несколько опций, которые могут быть объединены для отображения различных свойств процесса.</p>
<p>При отсутствии конкретных опций <strong>ps</strong> выдает только информацию о текущей оболочке и возможных процессах:</p>
<pre>
theo:~> <strong>ps</strong>
  PID TTY          TIME CMD
 4245 pts/7    00:00:00 bash
 5314 pts/7    00:00:00 ps
</pre><p>
Поскольку это не дает достаточно информации - как правило, по меньшей мере сотня процессов запущены в вашей системе – мы обычно будем выбирать отдельные процессы из списка всех процессов, используя команду <strong>grep</strong> в конвейере , см. <a href="http://younglinux.info/#">Раздел  "Выход перенаправления с > и | "</a>, как в этой строке, в которой будут выбраны и отображены все процессы, принадлежащие определенному пользователю:</p>
<p><span class="mono">ps -ef | grep username</span></p>
<p>Этот пример показывает все процессы с процессорным именем <strong>bash</strong>, наиболее распространенной оболочкой в системах Linux:</p>
<pre>
theo:> ps auxw | grep bash
brenda   31970  0.0  0.3  6080 1556 tty2   S  Feb23   0:00 -bash
root     32043  0.0  0.3  6112 1600 tty4   S  Feb23   0:00 -bash
theo     32581  0.0  0.3  6384 1864 pts/1  S  Feb23   0:00 bash
theo     32616  0.0  0.3  6396 1896 pts/2  S  Feb23   0:00 bash
theo     32629  0.0  0.3  6380 1856 pts/3  S  Feb23   0:00 bash
theo      2214  0.0  0.3  6412 1944 pts/5  S  16:18   0:02 bash
theo      4245  0.0  0.3  6392 1888 pts/7  S  17:26   0:00 bash
theo      5427  0.0  0.1  3720  548 pts/7  S  19:22   0:00 grep bash
</pre><p>
В этих случаях команда <strong>grep</strong> находит строки, содержащие строку <em>bash</em>, которые множество раз отображаются также в системах, которые имеют много простоев. Если вы не хотите, чтобы это произошло, используйте команду <strong>pgrep</strong>.</p>
<p>Bash-оболочки представляют собой особый случай: этот процессорный список также показывает, какие из них являются оболочками входа (где вы должны ввести ваше имя пользователя и пароль, например, когда вы входите в текстовом режиме или же совершаете удаленный вход, в отличие от оболочек не требующих логина, например, нажав значок окна терминала). Такие оболочки, требующие логин, начинаются с дефиса (-).</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>|?</strong><br />
Мы расскажем об операторе | в следующей главе, см. <a href="http://younglinux.info/#">Главу 5, "Перенаправление ввода/вывода"</a>.</p>
<p>Дополнительная информация может быть найдена как обычно: <strong>ps </strong> <span class="mono"> --help</span> или <strong>man </strong> <span class="monoi">ps</span>. GNU <strong>ps</strong> поддерживает различные форматы опций; приведенные выше примеры не содержат ошибок.</p>
<p>Заметьте, что <strong>ps</strong> выдает только сиюминутное состояние активных процессов, это одномоментный срез. Программа <strong>top</strong> дает более точный обзор путем обновления результатов, определенных <strong>ps</strong> (с множеством опций), один раз в 5 секунд, создавая новый список процессов, что периодически вызывает большие нагрузки, поэтому используется подключение дополнительной информации о файле подкачки и состоянии процессора; из файла <span class="mono">proc</span> системы:</p>
<pre>
 12:40pm up 9 days, 6:00, 4 users, load average: 0.21, 0.11, 0.03
89 processes: 86 sleeping, 3 running, 0 zombie, 0 stopped
CPU states:  2.5% user,  1.7% system,  0.0% nice, 95.6% idle
Mem:   255120K av, 239412K used, 15708K free, 756K shrd, 22620K buff
Swap: 1050176K av, 76428K used, 973748K free, 82756K cached

  PID USER  PRI NI SIZE  RSS SHARE STAT %CPU %MEM TIME COMMAND
 5005 root  14  0 91572  15M 11580 R    1.9  6.0  7:53 X
19599 jeff  14  0  1024 1024   796 R    1.1  0.4  0:01 top
19100 jeff   9  0  5288 4948  3888 R    0.5  1.9  0:24 gnome-terminal
19328 jeff   9  0 37884  36M 14724 S    0.5 14.8  1:30 mozilla-bin
    1 root   8  0   516  472   464 S    0.0  0.1  0:06 init
    2 root   9  0     0    0     0 SW   0.0  0.0  0:02 keventd
    3 root   9  0     0    0     0 SW   0.0  0.0  0:00 kapm-idled
    4 root  19 19     0    0     0 SWN  0.0  0.0  0:00 ksoftirqd_CPU0
    5 root   9  0     0    0     0 SW   0.0  0.0  0:33 kswapd
    6 root   9  0     0    0     0 SW   0.0  0.0  0:00 kreclaimd
    7 root   9  0     0    0     0 SW   0.0  0.0  0:00 bdflush
    8 root   9  0     0    0     0 SW   0.0  0.0  0:05 kupdated
    9 root  -1-20     0    0     0 SW&lt;  0.0  0.0  0:00 mdrecoveryd
   13 root   9  0     0    0     0 SW   0.0  0.0  0:01 kjournald
   89 root   9  0     0    0     0 SW   0.0  0.0  0:00 khubd
  219 root   9  0     0    0     0 SW   0.0  0.0  0:00 kjournald
  220 root   9  0     0    0     0 SW   0.0  0.0  0:00 kjournald
</pre><p>
Первая строка <strong>top</strong> содержит такую же информацию, которая отображается командой <strong>uptime</strong>:</p>
<pre>
jeff:~> <strong>uptime</strong>
  3:30pm, up 12 days, 23:29, 6 users, load average: 0.01, 0.02, 0.00
</pre><p>
Данных для этих программ хранятся среди других в  <span class="mono">/var/run/utmp</span> (информация о текущих подключенных пользователях) и в виртуальной файловой системе <span class="mono">/proc</span>, например, <span class="mono">/proc/loadavg</span> (обычная загрузочная информация). Есть разные виды графических приложений для просмотра этой информации, такие как Gnome System Monitor и <em>lavaps</em>. На <noindex><a href="http://freshmeat.net/">FreshMeat</a> и <a href="http://sourceforge.net/">SourceForge</a></noindex> и вы найдете десятки приложений, которые централизируют эту информацию наряду с другими серверными данными и журналами со множества серверов на один (web) сервер, что позволяет осуществлять мониторинг всей ИТ-инфраструктуры с одной рабочей станции.</p>
<p>Отношения между процессами могут быть отображены с использованием команды <strong>pstree</strong>:</p>
<pre>
sophie:~> <strong>pstree</strong>
init-+-amd
     |-apmd
     |-2*[artsd]
     |-atd
     |-crond
     |-deskguide_apple
     |-eth0
     |-gdm---gdm-+-X
     |           `-gnome-session-+-Gnome
     |                           |-ssh-agent
     |                           `-true
     |-geyes_applet
     |-gkb_applet
     |-gnome-name-serv
     |-gnome-smproxy
     |-gnome-terminal-+-bash---vim
     |                |-bash
     |                |-bash---pstree
     |                |-bash---ssh
     |                |-bash---mozilla-bin---mozilla-bin---3*[mozilla-bin]
     |                `-gnome-pty-helper
     |-gpm
     |-gweather
     |-kapm-idled
     |-3*[kdeinit]
     |-keventd
     |-khubd
     |-5*[kjournald]
     |-klogd
     |-lockd---rpciod
     |-lpd
     |-mdrecoveryd
     |-6*[mingetty]
     |-8*[nfsd]
     |-nscd---nscd---5*[nscd]
     |-ntpd
     |-3*[oafd]
     |-panel
     |-portmap
     |-rhnsd
     |-rpc.mountd
     |-rpc.rquotad
     |-rpc.statd
     |-sawfish
     |-screenshooter_a
     |-sendmail
     |-sshd---sshd---bash---su---bash
     |-syslogd
     |-tasklist_applet
     |-vmnet-bridge
     |-xfs
     `-xinetd-ipv6
</pre><p>
Опции <span class="mono">-u</span> и <span class="mono">-a</span> дают дополнительную информацию. Для знакомства с другими опциями, а также тем, что  они делают, направляем к info-страницам.</p>
<p>В следующем разделе мы увидим, как один процесс может создавать другой.</p>
<h2>Жизнь и смерть процесса</h2>
<h3>Создание процесса</h3>
<p>Новый процесс появляется вследствие того, что существующий процесс создает точную копию самого себя. У этого дочернего процесса тоже окружение, что и у родителя, отличается только номер ID процесса. Эта процедура называется <em>forking</em> (порождение).</p>
<p>После рождения, адресное пространство дочернего процесса переписывается с новыми данными процесса. Это делается посредством вызова <em>ехес</em> в системе.</p>
<p>Таким образом, механизм <em>fork-and-exec</em> переключает старые команды на новые, пока окружение, в котором выполняется новая программа остается таким же, в том числе конфигурация устройств ввода/вывода, переменные окружения и приоритет. Этот механизм используется для создания всех процессов UNIX, также это относится и к операционной системе Linux. Даже первый процесс, <strong>init</strong>, с процессорным ID 1, порождается во время загрузки  в так называемой процедуре <em>bootstrapping</em> (начальной загрузки).</p>
<p>Эта схема иллюстрирует механизм <em>fork-and-exec</em>. ID процесса изменяется после процедуры порождения:</p>
<p><strong>Рисунок 4.1. Механизм fork-and-exec</strong></p>
<div style="text-align:center;"><img src="../../../img/linuxintro/fork-and-exec.png" width="366" height="441" alt="Происхождение процессов в Linux" /></div>
<p>Есть несколько случаев, в которых <strong>init</strong> становится родителем процесса, хотя процесс не был запущен <strong>init</strong>, как мы уже видели в примере <strong>pstree</strong>. Многие программы, например, <em>daemonize</em> - их дочерние процессы, так они могут продолжать работать, когда родитель завершается или его завершают. Оконный менеджер является типичным примером; он запускается процессом <strong>xterm</strong>, который создает оболочку (shell), принимающую команды. Затем оконный менеджер отстраняется от какой-либо дальнейшей ответственности и передает дочерний процесс <strong>init</strong>. С помощью этого механизма можно менять оконные менеджеры, не прерывая запущенных приложений.</p>
<p>Время от времени что-то идет не так даже в хороших семьях. В исключительных случаях процесс может закончиться, в то время как родитель не ждет завершения этого процесса. Такой непогребенный процесс называется зомби-процессом.</p>
<h3>Завершение процесса</h3>
<p>Когда процесс завершается нормально (его не завершили или иным способом неожиданно не прервали), программа возвращает его <em>exit status</em> (статус выхода) родителю. Этот <em>exit status</em> является числом, возвращаемым программой, предоставившей результаты своего выполнения. Система передачи информации об исполненной работе берет свое начало с языка программирования Си, на котором был написан UNIX.</p>
<p>Коды возврата могут быть интерпретированы родителем или скриптами. Значения кодов возврата специфичны для программ. Эту информацию обычно можно найти в man-страницах указанной программы, например команда <strong>grep</strong> возвращает -1, если не найдено совпадений, при этом в строке может быть выведено сообщение: "Нет найденных файлов". Другим примером является встроенная команда Bash <strong>true</strong>, которая не делает ничего, кроме возвращения статуса выхода 0, что означает успех.</p>
<h3>Сигналы</h3>
<p>Процессы заканчиваются, если они получают сигнал. Есть несколько сигналов, которые вы можете отправить процессу. Используйте команду <strong>kill</strong>, чтобы послать сигнал процессу. Команда <strong>kill </strong> <span class="mono"> -i</span> отображается список сигналов. Большинство сигналов предназначены для внутреннего использования системой или для программистов, когда они пишут код. Как пользователю вам потребуются следующие сигналы:</p>
<p><strong>Таблица 4.2. Часто используемые сигналы</strong></p>
<table class="il">
<tr>
<td width="150"><strong>Имя сигнала</strong></td>
<td width="150"><strong>Номер сигнала</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>Завершить процесс надлежащим образом.</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>Прерывание процесса. Процесс может игнорировать этот сигнал.</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>Прерывание процесса. Процесс не может игнорировать этот сигнал.</td>
</tr>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>Для демонов: перечитать конфигурационный файл.</td>
</tr>
</table>
<p>Вы можете прочитать больше о действиях по умолчанию, которые предпринимаются при передаче сигнала процессу, в <strong>man </strong> <span class="mono"> 7 <em>signal</em></span>.</p>
<h2>SUID и SGID</h2>
<p>Как и было обещано в предыдущей главе, теперь мы будем обсуждать специальные режимы SUID и SGID более подробно. Эти режимы существуют, чтобы обеспечить обычным пользователям возможность выполнять задачи, которые они, как правило, не могут осуществить из-за строгой схемы управления доступом к файлам, используемой в UNIX-системах. В идеальной ситуации специальные режимы используются так редко, насколько это возможно, так как они включают в себя риски для безопасности. Разработчики Linux, как правило, стараются также избегать их по возможности. Версия <strong>ps</strong> в Linux, например, использует информацию, хранящуюся в файловой системе <span class="mono">/proc</span>, которая доступна каждому, что позволяет избегать демонстрации важных системных данных и ресурсов для широкой общественности. До этого (и до сих пор на старых системах UNIX) программа <strong>ps</strong> нуждалась в доступе к файлам, таким как <span class="mono">/dev/mem</span> и <span class="mono">/dev/kmem</span>, что имело свои недостатки из-за разрешений и владельцев этих файлов:</p>
<pre>
rita:~> <strong>ls -l /dev/*mem</strong>
crw-r-----    1 root     kmem       1,   2 Aug 30 22:30 /dev/kmem
crw-r-----    1 root     kmem       1,   1 Aug 30 22:30 /dev/mem
</pre><p>
В более ранних версиях <strong>ps</strong> не было возможности для запуска программы под обычным пользователем без применения специальных режимов.</p>
<p>Хотя мы обычно стараемся избегать применения каких-либо специальных режимов, иногда бывает необходимо использовать SUID. Примером может служить механизм смены пароля. Очевидно, что пользователи хотят делать это самостоятельно вместо того, чтобы их пароль устанавливал системный администратор. Как мы знаем, имена пользователей и пароли перечислены в файле <span class="mono">/etc/passwd</span>, который имеет следующие права доступа и владельцев:</p>
<pre>
bea:~> <strong>ls -l /etc/passwd</strong>
-rw-r--r--    1 root     root     1267 Jan 16 14:43 /etc/passwd
</pre><p>
Тем не менее, у пользователей должна быть возможность изменять свою информацию в этом файле. Это достигается путем предоставления программой <strong>passwd</strong> специальных разрешений:</p>
<pre>
mia:~> <strong>which passwd</strong>
passwd is /usr/bin/passwd

mia:~> <strong>ls -l /usr/bin/passwd</strong>
-r-s--x--x    1 root     root    13476 Aug  7 06:03 /usr/bin/passwd*
</pre><p>
При вызове команда passwd выполняется с использованием прав доступа <em>root</em>, что позволяет обычному пользователю редактировать файл паролей, который принадлежит системному администратору.</p>
<p>SGID режимы на файл не распространяются так же часто, как SUID, потому что SGID зачастую включает в себя создание дополнительных групп. В некоторых случаях, однако, мы должны пройти через эту неприятность, с тем чтобы выполнить элегантное решение (слишком об этом не беспокойтесь - необходимые группы обычно создаются при установке). Это происходит для программ <strong>write</strong> и <strong>wall</strong>, которые используются для отправки сообщений другим пользовательским терминалами (ttys). Команда <strong>write</strong> выводит сообщение одному пользователю, а <strong>wall</strong> пишет всем подключенным пользователям.</p>
<p>Отправка текста иным пользовательским терминалам или на графический дисплей, как правило, не допускается. Для того чтобы обойти эту проблему, была создана группа, которая является владельцем всех терминальных устройств. Когда команды <strong>write</strong> и <strong>wall</strong> получают SGID разрешения, команды запустятся с помощью прав доступа, применимых к этой группе, <em>tty</em> в примере. Поскольку у этой группы есть право на запись в назначенный терминал, то пользователь, не имеющий разрешения на использование этого терминала, в любом случае может отправлять туда сообщения.</p>
<p>В приведенном ниже примере пользователь <em>joe</em> в начале узнает, с каким терминалом связан его корреспондент, для этого он использует команду <strong>who</strong>. Затем он отправляет ей сообщение с помощью команды <strong>write</strong>. Кроме того, иллюстрируются права доступа на программу <strong>write</strong> и какие терминалы занимает принимающий пользователь: очевидно, что отличные от пользователя-владельца не имеют разрешения на устройство, за исключением владельца-группы, которая может писать в него.</p>
<pre>
joe:~> <strong>which write</strong>
write is /usr/bin/write

joe:~> <strong>ls -l /usr/bin/write</strong>
-rwxr-sr-x    1 root     tty      8744 Dec  5 00:55 /usr/bin/write*

joe:~> <strong>who</strong>
jenny     tty1     Jan 23 11:41
jenny     pts/1    Jan 23 12:21 (:0)
jenny     pts/2    Jan 23 12:22 (:0)
jenny     pts/3    Jan 23 12:22 (:0)
joe       pts/0    Jan 20 10:13 (lo.callhost.org)

joe:~> <strong>ls -l /dev/tty1</strong>
crw--w----    1 jenny   tty  4,     1 Jan 23 11:41 /dev/tty1

joe:~> <strong>write jenny tty1</strong>
hey Jenny, shall we have lunch together?
^C
</pre><p>
Пользователь <em>jenny</em> получает это на ее экране:</p>
<pre>
Message from joe@lo.callhost.org on ptys/1 at 12:36 ...
hey Jenny, shall we have lunch together?
EOF
</pre><p>
После получения сообщения, терминал может быть очищен помощью комбинации клавиш <strong>Ctrl + L</strong>. Для того, чтобы не получать никакие сообщения вообще (кроме тех, что от системного администратора), используйте команду <strong>mesg</strong>. Чтобы узнать, какие подключенные пользователи принимают сообщения от других, используют <strong>who </strong> <span class="mono"> -w</span>. Все особенности полностью разъяснены на info-страницах для каждой команды.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Названия групп могут быть различными. </strong><br />
Групповая схема специфична для дистрибутива. Разные дистрибутивы могут использовать разные имена или различные решения.</p>
  </div>
    </div></div>
  </body>
</html>
