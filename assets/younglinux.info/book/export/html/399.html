<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Статьи</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
        
    <div id="node-399" class="section-1">
  <h1 class="book-heading">Статьи</h1>
    <div id="node-314" class="section-2">
  <h1 class="book-heading">Linux&#039;ы и неттоп IRU 115</h1>
  <p>Мой обзор самого неттопа, общие впечатления и заметки о его производительности  можно найти здесь — http://inf1.info/nettopiru. Теперь подробнее о том, какие Линуксы я на него пыталась установить, что удалось, а что нет; несколько слов о графических средах.</p>
<p>Основу моего старого компьютера составлял процессор Celeron с частотой в 2.2Ггц, видеокарта была интегрированной (компьютер 2003 года выпуска). Современные дистрибутивы Linux (с их GUI) он уже давно не тянул, но в остальном все мои запросы решал. К новому компьютеру было основное требование - бесшумность. Решила остановиться на неттопе. К сожалению, оказалось, что его бесшумность весьма условное понятие. </p>
<p>На неттоп устанавливались (с успехом и без)  следующие дистрибутивы:<br />
Xubuntu 11<br />
Debian 6<br />
Simply 6 (beta)<br />
Simply 5.0.2<br />
AltLinux Master 5.0.2<br />
Fedora 15 (Gnome 3)<br />
Fedora 15 (KDE)</p>
<p>У данной модели компьютера нет привода для дисков, поэтому установка производилась с флэшки. Для создания загрузочного устройства USB c Линуксами на борту пользовалась утилитами Unetbootin и YUMI (Your Universal Multiboot Installer). Следует отметить, что с помощью второй удавалось благополучно создавать мультизагрузочную флешку только с дистрибутивами и системными утилитами, упомянутыми в ее списке. Сторонние для нее дистрибутивы не распаковываются, а помещаются в специальный каталог как есть, и установить их легко и беззаботно не получится. Программа Unetbootin - более универсальная вещь для создания загрузочных девайсов из образов iso, но способна установить на usb-устройство только одну систему. </p>
<p>С флэшки не удалось установить Simply 5.0.2 и AltLinux 5.0.2. В первом случае возникала какая-то ошибка памяти. Во втором вроде бы шло все хорошо, но при установке пакетов появились сообщения об ошибках, и установка завершалась ничем. Simply 6.0 установилась благополучно, но почему-то на английском языке. Это бы ладно, но после установки драйвера nvidia слетел звук, да так, что колонки гудели, как будто ни к чему не подключены. Восстановить звук не удалось. Поэтому до лучших времен, дорогой AltLinux.</p>
<p>Xubuntu действительно удобна и при установке, и при использовании. Ее загрузчик подключил все Линуксы, установленные до этого. Следовательно, Xubuntu надо ставить последней, если не хочется или не умеется конфигурировать grub. Производительность Xubuntu на неттопе нормальная. Комфортно работать можно. Например, Blender работает шустро, а вот Inkscape несколько неповоротливо. В обоих программах почему-то не работают горячие клавиши.</p>
<p>В Debian стоило установить драйвер видеокарты, как графический режим перестал запускаться, выдается ошибка. Лечится удалением xorg.conf. Пока живем без драйверов.</p>
<p>Fedora Gnome 3. Вот это интерфейс! Афигеть. Жаль, что неудобно и непривычно. А так круто вообще. Отсутствие привычных вещей на своих местах пугает. А где кнопка выхода? Неужели все открывают терминал и пишут reboot? Прям как в магазине я и два продавца прыгали вокруг MeeGo и так и не нашли как отрубить это чудо техники. </p>
<p>Вместо этого была установлена Fedora KDE. При установке было следующее. Предложили выбрать язык. Выбираю русский. Система ставится на английском, весь интерфейс английский, а по умолчанию ввод с клавиатуры осуществляется на русском. То, что по умолчанию язык переключается двумя шифтами, как-то мы не догадались. Поэтому пароль и имя вводила циферками. После установке пришлось пользователя убить, другого добавить. Сейчас стоит красавица вся на английском такая, разделы дисков я почему-то вручную подключаю, пакеты с поддержкой русского языка сама доустанавливаю. Прям как в старые добрые времена. Inkscape работает быстрее, чем в Xubuntu. В нем и Blender горячие клавиши работают. Хотя впечатление о шрифтах и быстродействии самой системы хуже, чем у Xubuntu. </p>
<p>Короче в Linux на этом неттопе работать можно, причем в любой графической среде. Что касается самих этих сред, то есть ощущение, что со временем большую популярность набирают так называемые "легкие" среды типа Xfce (по сравнению с 2006-2008 годами). Красота и спецэффекты зачастую дополнительной функциональности не добавляют, а наоборот вводят в заблуждение и мешают работать (похоже всё функционально полезное, что надо было изобрести в этой области, уже изобрели давно). Видимо старый верный Gnome канет влету, т.к. тот же Xfce по общему впечатлению его переплевывает. </p>
  </div>
<div id="node-400" class="section-2">
  <h1 class="book-heading">Сравнение переменных в языках программирования C и Python</h1>
  <p>Цель этой статьи обобщить текущие знания по языкам <span class="blue">C</span> и <span class="blue">Python</span> в части особенностей работы с переменными. Статья содержит ряд догадок, поэтому содержательные комментарии приветствуются.</p>
<p>Как известно <span class="blue">C</span> относится к языкам со строгим определением типа переменных, а <span class="blue">Python</span> – с динамическим. В основном именно этим обстоятельством обусловлены различия при работе с памятью и, как следствие, с переменными.</p>
<p>В <span class="blue">С</span> мы обязаны сначала объявить переменную, а потом присваивать ей значение (хотя можно делать это в одном месте). В <span class="blue">Python</span> объявить переменную без присвоения ей значения невозможно в принципе, переменные как бы не объявляются вовсе, а сразу используются.</p>
<p>Когда в <span class="blue">C</span> мы объявляем переменные, то обязаны указывать их тип. Например, так: <span class="geshifilter"><code class="c geshifilter-c"><span style="color: #993333;">int</span> base<span style="color: #339933;">,</span> <span style="color: #993333;">float</span> width</code></span>. Тип переменной сообщает программе сколько памяти надо выделить под данные, и программа при обращении к переменной правильно может их прочитать (она читает определенное типом количество байт). В языке программирования <span class="blue">C</span> сведения о типе данных привязаны к переменным. Когда программа, созданная на <span class="blue">C</span> запускается, то все объявленные в ней переменные привязываются к определенным ячейкам памяти и уже не могут быть связаны с другими ячейками до конца выполнения программы.</p>
<p>В <span class="blue">Python</span> переменные не хранят информацию о типе данных, с которыми связаны. Сведения о типе привязаны к данным. Поэтому в <span class="blue">Python</span> не надо объявлять переменные заранее и не надо указывать их тип. Переменным все равно с чем их свяжут. Они появляются в момент присвоения им значения (<span class="geshifilter"><code class="python geshifilter-python">count = <span style="color: #ff4500;">10</span>, height = <span style="color: #ff4500;">1.45</span></code></span>). Но, понятное дело, нельзя использовать в выражении переменную, которой не было присвоено значение ранее.</p>
<p>Можно сказать, в <span class="blue">Python</span> переменная в процессе выполнения скрипта может менять сколь угодно раз свой тип. На самом деле типа у нее просто нет. </p>
<p>Рассмотрим конкретный пример. Пусть есть вот такой код на языке <span class="blue">C</span>:<br />
<div class="geshifilter"><pre class="c geshifilter-c" style="font-family:monospace;"><span style="color: #993333;">int</span> qty<span style="color: #339933;">;</span>
scanf<span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;%d&quot;</span><span style="color: #339933;">,</span> <span style="color: #339933;">&amp;</span>qty<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
qty <span style="color: #339933;">=</span> qty <span style="color: #339933;">+</span> <span style="color: #0000dd;">2</span><span style="color: #339933;">;</span></pre></div></p>
<p>Если вы не знаете язык, отмечу, что во второй строке у пользователя просто запрашивается целое число и присваивается переменной qty. Когда программа, содержащая такой код, запускается, то в памяти "бронируется" ряд ячеек под эту переменную. Устанавливается связь между именем <span class="geshifilter"><code class="c geshifilter-c">qty</code></span> и первой ячейкой блока памяти, отведенного под данные. Программа анализирует тип переменной и получат сведения, что ее значение простирается на четыре байта (в языке <span class="blue">C</span> integer обычно имеет длину в 4 байта). Переменная <span class="geshifilter"><code class="c geshifilter-c">qty</code></span> на все время выполнения программы прикреплена к определенным ячейкам. Нельзя оторвать имя <span class="geshifilter"><code class="c geshifilter-c">qty</code></span> от этих ячеек и связать с другими. Мы можем только менять содержимое определенных ячеек. Далее сначала запрашивается число у пользователя и кладется в <span class="geshifilter"><code class="c geshifilter-c">qty</code></span>, пусть это будет число 5 (понятно, что в памяти хранится двоичный код, но для наглядности на картинке десятичные цифры), затем это число увеличивается на два и содержимое ячеек переписывается.</p>
<p><img src="../../../img/python-c/memory0.png" width="547" height="768" alt="Создание переменной и изменение ее значение в языке C" /></p>
<p>Еще раз отметим, что в данном случае память выделяется в момент запуска программы и ее объем не меняется в процессе выполнения. Не меняется и место: где выделилось, там и лежит.</p>
<p>Куда интересней обстоит дело с переменными-указателями (будем далее называть их просто указатели, чтобы отличать от обычных переменных).<br />
<div class="geshifilter"><pre class="c geshifilter-c" style="font-family:monospace;"><span style="color: #993333;">int</span> a <span style="color: #339933;">=</span> 3<span style="color: #339933;">,</span> num <span style="color: #339933;">=</span> <span style="color: #0000dd;">5</span><span style="color: #339933;">;</span>
<span style="color: #993333;">int</span> <span style="color: #339933;">*</span>pa<span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">// это указатель</span>
pa <span style="color: #339933;">=</span> <span style="color: #339933;">&amp;</span>a<span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">// записали адрес данных переменной a</span>
<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;%d &quot;</span><span style="color: #339933;">,</span> <span style="color: #339933;">*</span>pa<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">// получим 3</span>
pa <span style="color: #339933;">=</span> <span style="color: #339933;">&amp;</span>num<span style="color: #339933;">;</span>
<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;%d &quot;</span><span style="color: #339933;">,</span> <span style="color: #339933;">*</span>pa<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">// получим 5</span></pre></div></p>
<p>Да, указатели конечно тоже привязываются к определенным ячейкам. Под любой указатель (независимо от типа) в языке <span class="blue">C</span> выделяется 4 или 8 байтов (зависит от операционной системы). В указателе хранится адрес области памяти. А тип указателя сообщает на сколько простирается память определенного значения под этим адресом. Если в процессе выполнения программы сначала в указателе хранился один адрес, а затем другой, то получается интересная ситуация, когда с помощью одного указателя мы можем обращаться то к одному участку памяти, то к другому:</p>
<p><img src="../../../img/python-c/memory1.png" width="547" height="741" alt="Изменение значения указателя" /></p>
<p>Если еще учесть, что в языке <span class="blue">C</span> есть специальные функции позволяющие захватывать участки памяти, то мы можем хранить в указателе адрес ранее недоступной памяти. т.е. динамически захватывать и освобождать память.<br />
<div class="geshifilter"><pre class="c geshifilter-c" style="font-family:monospace;"><span style="color: #993333;">char</span> <span style="color: #339933;">*</span>pch<span style="color: #339933;">;</span>
pch <span style="color: #339933;">=</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">char</span> <span style="color: #339933;">*</span><span style="color: #009900;">&#41;</span> malloc<span style="color: #009900;">&#40;</span>10<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
pch <span style="color: #339933;">=</span> <span style="color: #ff0000;">&quot;hello&quot;</span><span style="color: #339933;">;</span>
pch <span style="color: #339933;">=</span> NULL<span style="color: #339933;">;</span></pre></div></p>
<p><img src="../../../img/python-c/memory2.png" width="548" height="813" alt="Динамическое выделение памяти в языке программирования C" /></p>
<p>В <span class="blue">Python</span> все переменные являются ссылками. Предположим, что они могут менять свои адреса "на корню", т.е. там, где хранится информация о переменных.</p>
<p>Все осложняется тем, что в <span class="blue">Python</span> есть изменяемые и неизменяемые типы данных. Числа и строки — это неизменяемые данные, а списки и словари — изменяемые. Разница не всегда очевидна, когда пытаются объяснить это так: строку и число мы не можем изменить, а список запросто. Например, <span class="geshifilter"><code class="python geshifilter-python">a = <span style="color: #483d8b;">&quot;Hello&quot;</span></code></span>. Попытка сделать так: <span class="geshifilter"><code class="python geshifilter-python">a<span style="color: black;">&#91;</span><span style="color: #ff4500;">0</span><span style="color: black;">&#93;</span> = <span style="color: #483d8b;">&quot;h&quot;</span></code></span>, чтобы получить "hello" вызовет ошибку. Но если есть список <span class="geshifilter"><code class="python geshifilter-python">b = <span style="color: black;">&#91;</span><span style="color: #483d8b;">'a'</span>, <span style="color: #483d8b;">'b'</span>, <span style="color: #483d8b;">'c'</span><span style="color: black;">&#93;</span></code></span>, то выражение <span class="geshifilter"><code class="python geshifilter-python">b<span style="color: black;">&#91;</span><span style="color: #ff4500;">0</span><span style="color: black;">&#93;</span> = <span style="color: #483d8b;">'z'</span></code></span> пройдет гладко, и <span class="geshifilter"><code class="python geshifilter-python">b</code></span> будет содержать <span class="geshifilter"><code class="python geshifilter-python"><span style="color: black;">&#91;</span><span style="color: #483d8b;">'z'</span>, <span style="color: #483d8b;">'b'</span>, <span style="color: #483d8b;">'c'</span><span style="color: black;">&#93;</span></code></span>.</p>
<p>Однако значение переменной a можно изменить так: <span class="geshifilter"><code class="python geshifilter-python">a = <span style="color: #483d8b;">&quot;hello&quot;</span></code></span>. На самом деле происходит следующее. Создается новый объект "hello", переменная привязывается к нему, а старый объект остается на прежнем месте. Поскольку на него больше не ссылается ни одна переменная, то он уничтожается.<br />
<div class="geshifilter"><pre class="python geshifilter-python" style="font-family:monospace;">a = <span style="color: #483d8b;">&quot;Hello&quot;</span>
a = <span style="color: #483d8b;">&quot;hello&quot;</span>
a = <span style="color: #ff4500;">12</span></pre></div></p>
<p><img src="../../../img/python-c/memory3.png" width="594" height="694" alt="Изменение значения переменной в языке программирования Python" /></p>
<p>Со списками, как изменяемыми объектами, несколько иная история. Предположим, переменная хранит сведения о том, где находится информация о списке. А сам список уже хранит сведения о том, как разбросаны в памяти его элементы. Когда меняется состав и содержание элементов списка, переменной все равно, ей положено знать, только где начинается список. Поэтому для переменной, а значит и для нас, список - изменяемый объект, т.к. переменная не устанавливает новую связь с другим объектом, а продолжает указывать на прежний.<br />
<div class="geshifilter"><pre class="python geshifilter-python" style="font-family:monospace;">nums = <span style="color: black;">&#91;</span><span style="color: #ff4500;">100</span>, <span style="color: #ff4500;">38</span><span style="color: black;">&#93;</span>
nums<span style="color: black;">&#91;</span><span style="color: #ff4500;">0</span><span style="color: black;">&#93;</span> =  <span style="color: #ff4500;">89</span>
nums.<span style="color: black;">append</span><span style="color: black;">&#40;</span><span style="color: #ff4500;">26.5</span><span style="color: black;">&#41;</span></pre></div></p>
<p><img src="../../../img/python-c/memory4.png" width="580" height="768" alt="Изменение списка" /></p>
<p>В <span class="blue">Python</span> есть еще одна интересная вещь. Все изменяемые и некоторые простые значения неизменяемых объектов (0, 1 и т.п.) при присваивании их другим переменным не копируются, а просто связываются с еще одной переменной. В результате получаем множество ссылок на один объект. Эти объекты существуют до тех пор, пока есть хотя бы одна ссылка на них. Если на один изменяемый тип ссылается несколько переменных, то его изменение по одной из них можно увидеть через другую. А вот если тип неизменяемый, то изменение значения одной переменной создает новый объект, а другая переменная остается связанной с прежним значением.<br />
<div class="geshifilter"><pre class="python geshifilter-python" style="font-family:monospace;">dt = <span style="color: black;">&#91;</span><span style="color: #ff4500;">1</span>, <span style="color: #483d8b;">'a'</span><span style="color: black;">&#93;</span>
n = <span style="color: #ff4500;">0</span>
mdt = dt
m = n
mdt<span style="color: black;">&#91;</span><span style="color: #ff4500;">1</span><span style="color: black;">&#93;</span> = <span style="color: #483d8b;">'b'</span>
m = 100
<span style="color: #ff7700;font-weight:bold;">del</span> dt</pre></div></p>
<p><img src="../../../img/python-c/memory5.png" width="624" height="991" alt="Поведение изменяемых и неизменяемых типов в языке программирования Python" /></p>
<p>Следует отметить, что в <span class="blue">C</span> адрес определенного места в памяти также может содержаться в качестве значения нескольких указателей. В результате изменение данных в этой памяти с помощью одного указателя можно будет увидеть с помощью другого.</p>
  </div>
</div>
    
  </body>
</html>
