<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Глава 5. Перенаправление ввода-вывода (I/O)</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
              <div class="section-1">
          
    <div id="node-214" class="section-2">
  <h1 class="book-heading">Глава 5. Перенаправление ввода-вывода (I/O)</h1>
  <h3>Аннотация</h3>
<p>В этой главе подробно описываются мощные механизмы UNIX, связанные с перенаправлением ввода, вывода и ошибок. Темы включают:</p>
<ul>
<li>Стандартные ввод, вывод и ошибки</li>
<li>Операторы перенаправления</li>
<li>Как использовать выходные данные одной команды в качестве входных данных другой</li>
<li>Как отправить вывод команды в файл для последующего использования</li>
<li>Как добавить вывод множества команд в файл</li>
<li>Перенаправления ввода</li>
<li>Обработка сообщений стандартных ошибок</li>
<li>Комбинирование перенаправления потоков ввода, вывода и ошибок</li>
<li>Выходные фильтры</li>
</ul>
  <div id="node-225" class="section-3">
  <h1 class="book-heading">Простые перенаправления</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<h2>Что такое стандартный ввод и стандартный вывод?</h2>
<p>Большинство команд Linux считывают с ввода, которым может быть файл или другой атрибут команды, и записывают в вывод. По умолчанию ввод принимается с клавиатуры, а вывод отображается на экране. Клавиатура является вашим стандартным устройством <em>ввода</em> (stdin), а экран или конкретное окно терминала — стандартным устройством <em>вывода</em> (stdout).</p>
<p>Однако, поскольку Linux - гибкая система, эти настройки по умолчанию не обязательны к применению. Стандартный вывод, например, на сильно загруженном сервере может быть направлен на принтер.</p>
<h2>Операторы перенаправления</h2>
<h3>Перенаправление вывода с > и | </h3>
<p>Когда-нибудь вам захочется отправить вывод команды в файл, или вам может потребоваться применить другую команду к выводу первой. Это явление известно как перенаправление вывода. Перенаправление производится с использованием либо ">" (символ "больше чем"), либо с помощью оператора "|" (канал), который направляет стандартный вывод одной команды к другой команде в качестве стандартного ввода.</p>
<p>Как мы видели раньше, команда <strong>cat</strong> объединяет файлы и отправляет их все вместе на стандартный вывод. При перенаправлении этого вывода в файл он будет создан или  перезаписан, если он уже существует, так что будьте аккуратнее.</p>
<pre>
nancy:~> <strong>cat test1</strong>
some words

nancy:~> <strong>cat test2</strong>
some other words

nancy:~> <strong>cat test1 test2 > test3</strong>

nancy:~> <strong>cat test3</strong>
some words
some other words
</pre><p class="note"><img src="../../../img/linuxintro/warning.gif" alt="" /><strong> Не перезаписывайте!</strong><br />
Будьте осторожны, чтобы не перезаписать существующие (важные) файлы при перенаправлении вывода. Многие оболочки, в том числе и Bash, имеют встроенную функцию для защиты вас от этого риска: <strong>noclobber</strong>. См. info-страницы для получения дополнительной информации. В Bash возможно вам захочется добавить команду <span class="mono"><strong>set</strong> <em>-o noclobber</em></span> в ваш файл конфигурации <span class="mono">.bashrc</span> в целях предотвращения случайной перезаписи файлов.
</p>
<p>Если перенаправить в файл «ничего», то он станет пустым:</p>
<pre>
nancy:~><strong> ls -l list</strong>
-rw-rw-r--    1 nancy   nancy     117 Apr  2 18:09 list

nancy:~> <strong>> list</strong>

nancy:~> <strong>ls -l list</strong>
-rw-rw-r--    1 nancy   nancy       0 Apr  4 12:01 list
</pre><p>
Этот процесс называется усечением.</p>
<p>Такое же перенаправление на несуществующий файл создаст новый пустой файл с заданным именем:</p>
<pre>
nancy:~> <strong>ls -l newlist</strong>
ls: newlist: No such file or directory

nancy:~> <strong>> newlist</strong>

nancy:~> <strong>ls -l newlist</strong>
-rw-rw-r--  1 nancy   nancy	    0 Apr  4 12:05 newlist
</pre><p>
В <a href="http://younglinux.info/#">Главе 7, Дом, сладкий /home</a> дается еще несколько примеров использования подобного способа переадресации.</p>
<p>Далее идут некоторые примеры использования конвейера команд.</p>
<p>Чтобы найти слово в каком-то тексте, отображаются все строки, соответствующие "pattern1", а также исключаются строки, соответствующие "pattern2":</p>
<p><span class="mono">grep <em>pattern1</em> file | grep -v <em>pattern2</em> </span> </p>
<p>Отображение вывода каталога с перелистыванием одной страницы за раз:</p>
<p><span class="mono">ls -la | less</span></p>
<p>Нахождение файла в каталоге:</p>
<p><span class="mono">ls -l | grep <em>part_of_file_name</em></span> </p>
<h3>Перенаправление ввода</h3>
<p>В другом случае вам может понадобиться файл, который послужит вводом для команды, которая обычно не принимает файл в качестве параметра. Такое перенаправление ввода осуществляется с помощью оператора "&lt;" (символ "меньше, чем").</p>
<p>Ниже приведен пример отправки кому-то файла с использованием перенаправления ввода.</p>
<pre>
andy:~> mail mike@somewhere.org &lt; to_do
</pre><p>
Если пользователь mike существует в данной системе, вам не нужно вводить полный адрес. Если вы хотите достать кого-то в Интернете, введите полный адрес в качестве аргумента <strong>mail</strong>.</p>
<p>По началу это читается немного сложнее, чем <span class="mono"><strong>cat</strong> file | <strong>mail</strong> someone</span>, но это, без сомнения, гораздо более удобный способ использования имеющихся инструментов.</p>
<h3>Объединение перенаправлений</h3>
<p>В следующем примере объединяются входное и выходное перенаправление. Файл text.txt сначала проверяется на наличие орфографических ошибок, а вывод перенаправляется в файл журнала ошибок:</p>
<p><span class="mono"><strong>spell</strong> &lt; text.txt > error.log</span></p>
<p>Следующая команда выводит список всех команд, которые вы можете передать на  рассмотрение другому файлу при использовании <strong>less</strong>: </p>
<pre>
mike:~> less --help | grep -i examine
  :e [file]      Examine a new file.
  :n          *  Examine the (N-th) next file from the command line.
  :p          *  Examine the (N-th) previous file from the command line.
  :x          *  Examine the first (or N-th) file from the command line.
</pre><p>
Опция <span class="mono">-i</span> используется для поиска без учета регистра - вспомните, что системы UNIX очень чувствительны к регистру.</p>
<p>Если вы хотите сохранить вывод этой команды на будущее, перенаправьте вывод в файл:</p>
<pre>
mike:~> <strong>less --help | grep -i examine > examine-files-in-less</strong>

mike:~> <strong>cat examine-files-in-less</strong>
  :e [file]      Examine a new file.
  :n          *  Examine the (N-th) next file from the command line.
  :p          *  Examine the (N-th) previous file from the command line.
  :x          *  Examine the first (or N-th) file from the command line.
</pre><p>
Вывод одной команды может быть передан другой команде фактически столько раз, сколько вам потребуется, но только до тех пор, пока эти команды читают со стандартного ввода и отправляют результат на стандартный вывод. Иногда этого не происходит, в таком случае могут существовать специальные опции, которые отдают распоряжение таким командам, делая их поведение соответствующим стандартным установкам; так что читайте документацию (man и info-страницы) используемым вами командам, если вам приходится сталкиваться с ошибками.</p>
<p>Опять же, убедитесь, что вы не используете имена существующих файлов, которые вам все еще нужны. Перенаправление вывода в существующий файл заменит его содержимое.</p>
<h3>Оператор >></h3>
<p>Вместо перезаписи данных файла, вы можете также добавить текст в существующий файл с помощью двух следующих друг за другом символов "больше, чем".</p>
<p>Пример:</p>
<pre>
mike:~> <strong>cat wishlist</strong>
more money
less work

mike:~> <strong>date >> wishlist</strong>

mike:~> <strong>cat wishlist</strong>
more money
less work
Thu Feb 28 20:23:07 CET 2002
</pre><p>
Команда <strong>date</strong>, как правило, выводит результат на экран, но теперь добавляется к файлу <span class="mono">wishlist</span>.</p>
  </div>
<div id="node-226" class="section-3">
  <h1 class="book-heading">Расширенные свойства перенаправления</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<h2>Использование дескрипторов файла</h2>
<p>Существует три типа I/O (ввода-вывода), которые имеют свои собственные идентификаторы, называемые дескрипторами файла:</p>
<ul>
<li>стандартный ввод: 0</li>
<li>стандартный вывод: 1</li>
<li>стандартная ошибка: 2</li>
</ul>
<p>В следующих описаниях, если номер дескриптора файла не указан, и первый символ перенаправления оператор &lt;, перенаправление ссылается на стандартный ввод (дескриптор файла 0). Если первый символ перенаправления оператор >, перенаправление ссылается на стандартный вывод (дескриптор файла 1).</p>
<p>Некоторые практические примеры внесут больше ясности:</p>
<p><span class="mono">ls > dirlist 2>&amp;1</span></p>
<p>направит как стандартный вывод, так и стандартную ошибку в файл <span class="mono">dirlist</span>, в то время как команда</p>
<p><span class="mono">ls 2>&amp;1 > dirlist</span></p>
<p>направит только стандартный вывод в <span class="mono">dirlist</span>. Это может быть полезным вариантом для программистов.</p>
<p>Существует сложность: не следует путать использование амперсанда здесь с использованием его в <a href="http://younglinux.info/#">разделе "Интерактивные процессы"</a>, где амперсанд используется для запуска процесса в фоновом режиме. В данном случае он просто служит признаком того, что число, которое следует за ним, является не именем файла, а местом, на которое указывается потоку данных. Также отметим, что символ "больше, чем" не должен быть отделен пробелами от номера дескриптора файла. Если он будет отделен, мы снова укажем на вывод в файл. Пример ниже демонстрирует это:</p>
<pre>
[nancy@asus /var/tmp]$ <strong>ls 2> tmp</strong>

[nancy@asus /var/tmp]$ <strong>ls -l tmp</strong>
-rw-rw-r--  1 nancy nancy 0 Sept  7 12:58 tmp

[nancy@asus /var/tmp]$ <strong>ls 2 > tmp</strong>
ls: 2: No such file or directory
</pre><p>
Первая команда, которую выполняет nancy, правильна (даже несмотря на отсутствие ошибок, и поэтому файл, в который перенаправлялась стандартная ошибка пуст). Вторая команда предполагает, что 2 - это имя файла, которого в данном случае нет, поэтому отображается ошибка.<br />
Все эти особенности подробно описаны в info-страницах Bash.</p>
<h2>Примеры</h2>
<h3>Анализ ошибок</h3>
<p>Если ваш процесс порождает много ошибок, есть способ тщательно их изучить:</p>
<p><span class="mono">command 2>&amp;1 | less</span></p>
<p>Такое часто используется при создании нового программного обеспечения с использованием команды <strong>make</strong>, так как здесь:</p>
<pre>
andy:~/newsoft> <strong>make all 2>&1 | less</strong>
--output ommitted--
</pre><h3>Отделение стандартного вывода от стандартной ошибки</h3>
<p>Конструкции подобные этим часто используется программистами, в результате вывод отображается в одном окне терминала, а ошибки в другом. Сначала выясняется, какой псевдо терминал вы используете выдачей команды <strong>tty</strong>.</p>
<pre>
andy:~/newsoft> make all 2> /dev/pts/7
</pre><h3>Одновременная запись в вывод и в файлы</h3>
<p>Вы можете использовать команду <strong>tee</strong> для копирования ввода на стандартный вывод и один или несколько выходных файлов за один раз. Использование опции <span class="mono">-a</span> c <strong>tee</strong> в результате добавляет ввод в файл(ы). Эта команда полезна, если вы хотите как увидеть, так и сохранить вывод. Операторы > и >> не позволяют выполнить оба действия одновременно.</p>
<p>Этот инструмент обычно называется подачей на конвейер (|), что демонстрируется в следующем примере:</p>
<pre>
mireille ~/test> <strong>date | tee file1 file2</strong>
Thu Jun 10 11:10:34 CEST 2004

mireille ~/test> <strong>cat file1</strong>
Thu Jun 10 11:10:34 CEST 2004

mireille ~/test> <strong>cat file2</strong>
Thu Jun 10 11:10:34 CEST 2004

mireille ~/test> <strong>uptime | tee -a file2</strong>
 11:10:51 up 21 days, 21:21, 57 users,  load average: 0.04, 0.16, 0.26

mireille ~/test> <strong>cat file2</strong>
Thu Jun 10 11:10:34 CEST 2004
 11:10:51 up 21 days, 21:21, 57 users,  load average: 0.04, 0.16, 0.26
</pre>  </div>
<div id="node-227" class="section-3">
  <h1 class="book-heading">Фильтры</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<p>Когда программа выполняет операции с вводом и записывает результат в стандартный вывод, она называется фильтром. Одним из наиболее распространенных видов использования фильтров является использование по реогранизованному выводу. Ниже мы обсудим несколько наиболее важных фильтров.</p>
<h2>Дополнительная информация о grep</h2>
<p>Как мы уже видели в <a href="http://younglinux.info/#">разделе "Команда grep"</a>, <strong>grep</strong> сканирует строку вывода через строку поиска по определенным шаблонам. Все строки, содержащие шаблон будут распечатаны на стандартном выводе. Такое поведение может быть отменено путем использования опции <span class="mono">-v</span>.</p>
<p>Некоторые примеры: допустим, мы хотим знать, какие файлы в определенной директории были изменены в феврале:</p>
<pre>
jenny:~> <strong>ls -la | grep Feb</strong>
</pre><p>
Команда <strong>grep</strong>, как и большинство команд, учитывает регистр. Используйте опцию <span class="mono">-i</span>, чтобы не учитывать различие между верхним и нижним регистром. Также доступны многие расширения GNU, например <span class="mono">--color</span>, который полезен для подсветки терминов поиска в длинных строках, и <span class="mono">--after-context</span>, который печатает число строк после последней совпавшей строки. Вы можете оформить рекурсивных <strong>grep</strong>, который ищет во всех подкаталогах встречающихся каталогов, с помощью опции <span class="mono">-r</span>. Как обычно, опции могут быть объединены.</p>
<p>Регулярные выражения могут быть использованы для более подробной детализации совпадений, которые вы хотите выбрать из всех строк ввода. Лучшим способом познакомиться с регулярными выражениями является чтение документации по <strong>grep</strong>. Отличная глава включена в info-страницу <strong>grep</strong>. Поскольку обсуждение вводов и выводов регулярных выражений завело бы нас слишком далеко, настоятельно рекомендуется начать с документации, если вы хотите знать о них больше.</p>
<p>Поиграйте немного с <strong>grep</strong>, это займет у вас какое-то время для изучения этой самой базовой, но очень мощной команды фильтрации. Упражнения в конце этой главы помогут вам начать работу, см. <a href="http://younglinux.info/#">раздел 5.5. "Упражнения"</a>.</p>
<h2>Фильтрация вывода</h2>
<p>Команда <strong>sort</strong> по умолчанию сортирует строки в алфавитном порядке:</p>
<pre>
thomas:~> <strong>cat people-I-like | sort</strong>
Auntie Emmy
Boyfriend
Dad
Grandma
Mum
My boss
</pre><p>
Но есть множество другого, что <strong>sort</strong> может делать. Просмотр размера файла, например. С помощью этой команды, содержимое каталога сортируется от  наименьших файлов в начале, до самых больших в конце:</p>
<p><span class="mono">ls -la | sort -nk 5</span></p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Старый синтаксис sort. </strong><br />
Вы можете получить тот же результат с <strong>ls</strong> <span class="mono">-la |</span> <strong>sort</strong> <span class="mono">+4n</span>, но это старая форма, которая не соответствует текущим стандартам.
</p>
<p>Команда <strong>sort</strong> также используется в сочетании с программой <strong>uniq</strong> (или <strong>sort</strong> <span class="mono">-u</span>) для сортировки вывода и отфильтровывания двойных записей:</p>
<pre>
thomas:~> <strong>cat itemlist</strong>
1
4
2
5
34
567
432
567
34
555

thomas:~> <strong>sort itemlist | uniq</strong>
1
2
34
4
432
5
555
567
</pre>  </div>
<div id="node-228" class="section-3">
  <h1 class="book-heading">Резюме</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<p>В этой главе мы узнали, как команды могут быть связаны друг с другом, и как вывод одной команды может быть использован в качестве ввода для другой.</p>
<p>Перенаправление ввода/вывода — обычная задача на машинах UNIX и Linux. Этот мощный механизм позволяет гибко использовать блоки, из которых сделан UNIX.</p>
<p>Наиболее часто используемыми перенаправлениями являются > и |. См. <a href="http://younglinux.info/#">Приложение C, "Особенности Shell"</a> для обзора команд перенаправления и других конструкций shell.</p>
<table class="il">
<tr>
<td width="100"><strong>Команда</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td><strong>date</strong></td>
<td>Отображает дату и время</td>
</tr>
<tr>
<td><strong>set</strong></td>
<td>Настройка опций оболочки</td>
</tr>
<tr>
<td><strong>sort</strong></td>
<td>Сортирует строки текста</td>
</tr>
<tr>
<td><strong>uniq</strong></td>
<td>Удаляет повторяющиеся строки из отсортированного файла</td>
</tr>
</table>
  </div>
<div id="node-229" class="section-3">
  <h1 class="book-heading">Упражнения</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<p>Эти упражнения представляют дополнительные примеры того, как объединять команды. Основная цель - попытаться использовать клавишу Enter как можно меньше.</p>
<p>Все упражнения выполняются под обычным пользовательским ID, так что появляются некоторые ошибки. Когда вы их видите, не забывайте прочитать man-страницы!</p>
<ul>
<li>Используйте команду <strong>cut</strong> на вывод длинного списка каталога, чтобы отобразить только права доступа к файлам. Затем отправьте в конвейере этот вывод на <strong>sort</strong> и <strong>uniq</strong>, чтобы отфильтровать все повторяющиеся строки. Потом с помощью <strong>wc</strong> посчитайте различные типы разрешений в этом каталоге.</li>
<li>Отправьте вывод <strong>date</strong> в файл. Добавьте выход <strong>ls</strong> в этот же файл. Отправьте этот файл на ваш локальный почтовый ящик (не указывайте ничего вроде «@домен», достаточно просто имени пользователя). В случае успеха при использовании Bash вы увидите новое почтовое уведомление.</li>
<li>Отобразите список устройств в <span class="mono">/dev</span>, которые в настоящее время используются вашим UID. Организуйте конвейер через <strong>less</strong>, чтобы посмотреть их должным образом.</li>
<li>Выполните следующие команды под непривилегированным пользователем. Определите стандартный ввод, вывод и ошибку для каждой команды.
<p>Теперь проверьте ваши результаты выдачи команд снова, теперь перенаправляя стандартный вывод в файл <span class="mono">/var/tmp/output</span> и стандартную ошибку в файл <span class="mono">/var/tmp/error</span>.</p>
<ul>
<li><span class="mono">cat nonexistentfile </span></li>
<li><span class="mono">file /sbin/ifconfig </span></li>
<li><span class="mono">grep root /etc/passwd /etc/nofiles > grepresults </span></li>
<li><span class="mono">/etc/init.d/sshd start > /var/tmp/output </span></li>
<li><span class="mono">/etc/init.d/crond start > /var/tmp/output 2>&amp;1</span></li>
</ul>
</li>
</ul>
<ul>
<li>Как много процессов у вас сейчас работает?</li>
<li>Сколько скрытых файлов в вашем домашнем каталоге?</li>
<li>Используйте locate, чтобы найти документацию по ядру.</li>
<li>Узнайте, какой файл содержит следующую запись:</li>
</ul>
<pre>
root:x:0:0:root:/root:/bin/bash
</pre><p>
А эту:</p>
<pre>
system:		root
</pre><ul>
<li>Посмотрите, что произойдет после выполнения этой команды:</li>
</ul>
<p><span class="mono">> time; date >> time; cat &lt; time</span></p>
<ul>
<li>Какие команды вы бы использовали, чтобы проверить, какие сценарии в <span class="mono">/etc/init.d</span> запускают данный процесс?</li>
</ul>
  </div>
</div>
    </div>
  </body>
</html>
