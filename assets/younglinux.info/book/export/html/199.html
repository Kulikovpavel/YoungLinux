<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Глава 3. О файлах и файловых системах</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
              <div class="section-1">
          
    <div id="node-199" class="section-2">
  <h1 class="book-heading">Глава 3. О файлах и файловых системах</h1>
  <h4>Аннотация</h4>
<p>После начальной разведки в <a href="http://younglinux.info/quickstart">Главе 2, Быстрый старт</a>, мы готовы более подробно обсудить файлы и каталоги системы Linux. Многие пользователи испытывают трудности с Linux, т.к. они недостаточно изучили, где и какие данные хранятся в системе. Мы постараемся пролить свет на организацию файлов в файловой системе.</p>
<p>Мы также составим список наиболее важных файлов и каталогов, будем использовать разные способы просмотра содержимого тех файлов, и узнаем, как могут быть созданы, перемещены и удалены файлы и каталоги.</p>
<p>После выполнения упражнений этой главы, вы будете уметь:</p>
<ul>
<li>Описывать схему файловой системы Linux</li>
<li>Отображать и вводить адреса</li>
<li>Описывать более важные файлы, в том числе ядро и shell</li>
<li>Искать потерянные и скрытые файлы</li>
<li>Создавать, перемещать и удалять файлы и каталоги</li>
<li>Показать содержимое файлов</li>
<li>Понимать и использовать различные типы ссылок</li>
<li>Узнавать свойства файла и изменять права доступа к файлу</li>
</ul>
  <div id="node-200" class="section-3">
  <h1 class="book-heading">Общий обзор файловой системы Linux</h1>
  <h2>Файлы</h2>
<h3>Общее</h3>
<p>Простое описание системы UNIX, также применимое к Linux, заключается в следующем:</p>
<p>"В системе UNIX, все есть файл; а если что-то не файл, то это процесс".</p>
<p>Это утверждение правда, т.к. существуют специальные файлы, которые больше, чем просто файлы (именованные каналы и сокеты, например), но для простоты допускают обобщение и говорят, что все есть файл. Система Linux, как и UNIX, не делает никакой разницы между файлом и каталогом, так как каталог - это просто файл, содержащий имена других файлов. Программы, службы, тексты, изображения и т.д. — все это файлы. В системе Linux устройства ввода и вывода и вообще все устройства считаются файлами.</p>
<p>Для того, чтобы организованно управлять всеми этими файлами, человеку удобно представлять их в виде упорядоченной древовидной структуры на жестком диске,  что нам известна из MS-DOS (Дисковая Операционная Система), например. Большие ветви содержат больше ветвей, а в конце ветви содержат листья деревьев, т.е. обычные файлы. В настоящее время мы будем использовать это представление о дереве, но потом мы узнаем, почему это не совсем точный образ.</p>
<h3>Виды файлов</h3>
<p>Большинство файлов просто файлы, называемые обычными файлами; они содержат обычные данные, например, текстовые файлы, исполняемые файлы (или программы), файлы ввода или вывода программ и т.д.</p>
<p>Хотя предположение, что все что вы обнаружите в системе Linux представляет собой файл достаточно верное, есть некоторые особенности.</p>
<ul>
<li><em>Каталоги</em>: файлы, которые представляют собой списки других файлов.</li>
<li><em>Специальные файлы</em>: механизм использования ввода-вывода. Большинство специальных файлов находятся в /dev, мы их обсудим позже.</li>
<li><em>Ссылки</em>: механизм обеспечения видимости файла или каталога во множестве частей файлового дерева системы. Мы в деталях поговорим о ссылках.</li>
<li><em>(Домены) сокеты</em>: особый тип файла, подобный сокетам TCP/IP, обеспечивающий взаимодействие в сети процессов, защищенных контролем файловой системы на доступ.</li>
<li><em>Именованные каналы</em>: действуют более или менее похоже на сокеты и обеспечивают способ коммуникации между процессами без использования правил поведения сетевых сокетов.</li>
</ul>
<p>Опция <span class="mono">-l</span> команды <strong>ls</strong> отображает тип файла, на что указывает первый символ в каждой выводимой строке:</p>
<pre>
jaime:~/Documents> <strong>ls -l</strong>
total 80
-rw-rw-r--   1 jaime   jaime   31744 Feb 21 17:56 intro Linux.doc
-rw-rw-r--   1 jaime   jaime   41472 Feb 21 17:56 Linux.doc
drwxrwxr-x   2 jaime   jaime    4096 Feb 25 11:50 course
</pre><p>Эта таблица дает обзор символов, характеризующих тип файла:</p>
<p><strong>Таблица 3.1. Типы файлов</strong></p>
<table class="il">
<tr>
<td width="100"><strong>Символ</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td>-</td>
<td>Обычный файл</td>
</tr>
<tr>
<td>d</td>
<td>Директория </td>
</tr>
<tr>
<td>l</td>
<td>Ссылка</td>
</tr>
<tr>
<td>c</td>
<td>Специальный файл</td>
</tr>
<tr>
<td>s</td>
<td>Сокет</td>
</tr>
<tr>
<td>p</td>
<td>Именованный канал</td>
</tr>
<tr>
<td>b</td>
<td>Блочное устройство</td>
</tr>
</table>
<p>Чтобы не нужно было всегда выводить длинный список для просмотра файлового типа, многие системы по умолчанию выдают не просто <strong>ls</strong>, а <strong>ls</strong> <span class="mono">-F</span>, который добавляет суффиксы к именам файлов с виде одного из символов “/=*|@”, которые указывают на тип файла. Чтобы было еще легче начинающим пользователям, обе опции и <span class="mono"> -F</span> и <span class="mono"> --color</span> обычно комбинируют, см. <a href="http://younglinux.info/#">Раздел, "Дополнительная информация о ls"</a>. Для лучшей удобочитаемости в этом документе мы будем использовать <strong>ls</strong> <span class="mono"> -F</span>.</p>
<p>Как пользователю вам приходится иметь дело только непосредственно с текстовыми файлами, исполняемыми файлами, каталогами и ссылками. Специальные типы файлов существуют для того, чтобы ваша система делала то, что вы требуете от нее и рассматриваются системными администраторами и программистами.</p>
<p>Теперь, прежде чем мы рассмотрим важные файлы и каталоги, нам нужно узнать побольше о разделах.</p>
<h2>О разметке</h2>
<h3>Зачем разделы?</h3>
<p>Большинство людей имеют смутное представление о том, что такое разделы, так как каждая операционная система самостоятельно способна их создавать или удалять. Может показаться странным, что Linux использует более чем один раздел на одном диске, даже когда выполняется стандартная процедура установки; для этого должно быть какое-то объяснение.</p>
<p>Одной из целей разделения на разделы является повышение сохранности данных на случай непредвиденных происшествий. Путем разделения жесткого диска на разделы, данные могут быть сгруппированы и разобщены. Когда происходит авария, повреждаются данные только одного раздела, а данные других разделов скорее всего уцелеют.</p>
<p>Этот принцип датируется теми днями, когда у Linux не было журналируемой файловой системы и сбои питания могли привести к катастрофе. По причинам обеспечения надежности и безопасности использование разделов осталось, так нарушение одной части системы, автоматически не означает, что весь компьютер в опасности. В настоящее время это самая важная причина для разметки. Простой пример: пользователь создает скритп, программу или веб-приложение, которые начинают заполнять диск. Если диск содержит только один большой раздел, вся система перестает работать, если диск заполнен. Если пользователь хранит данные на отдельном разделе, то только тот (с данными) раздел будет затронут, в то время как системные разделы и, возможно, другие разделы с данными сохранят функциональность.</p>
<p>Помните, что имеющаяся журналируемая файловая система обеспечивает только  защиту данных в случае сбоя питания и неожиданного отключения устройств хранения. Она не защищает ваши данные от испорченных блоков и логических ошибок в файловой системе. В этих случаях, вам следует использовать RAID (избыточный массив недорогих жёстких дисков) решение.</p>
<h3>Схемы и типы разделения</h3>
<p>Есть два вида основных разделов в системе Linux:</p>
<ul>
<li><em>раздел с данными</em>: обычные данные системы Linux, включая <em>корневой раздел</em>, содержащий все данные для старта и запуска системы; и</li>
<li><em>раздел подкачки</em>: расширение физической памяти компьютера, представляет собой дополнительную память на жестком диске.</li>
</ul>
<p>Большинство систем содержат корневой раздел, один или несколько разделов с данными, и один или несколько разделов подкачки. Системы в смешанных средах, могут содержать разделы данных других систем, такие как разделы файловых системам FAT или VFAT  с данными MS Windows.</p>
<p>Большинство систем Linux во время установки используют <strong>fdisk</strong>, чтобы задать тип раздела. Как вы могли заметить в ходе упражнений к Главе 1, это обычно происходит автоматически. Но однажды вам может так не повести. В таких случаях вам придется выбрать тип раздела вручную и даже вручную сделать настоящее разбиение на разделы. Стандартные разделы Linux имеют номера 82 для раздела подкачки и 83 для данных, который может быть журналируемым (ext3) или обычным (ext2, на старых системах). Утилита <strong>fdisk</strong> имеет встроенную помощь, на случай если вы забудете эти значения.</p>
<p>Наряду с этими двумя, Linux поддерживает множество других типов файловых систем, такие как относительно новая файловая система Reiser, JFS, NFS, FATxx и многие другие файловые системы, изначально доступные на других (проприетарных) операционных системах.</p>
<p>Стандартный корневого раздела (обозначается одиночной косой чертой, /), составляет около 100-500 МБ и содержит системные конфигурационные файлы, большинство основных команд и серверные программы, системные библиотеки, некоторое временное пространство и домашний каталог пользователя с правами администратора. Стандартная установка для корневого раздела требуется около 250 МБ.</p>
<p>Пространство для подкачки (обозначается как <em>swap</em>) доступно только для самой системы, и скрыто из виду при обычной работе. Раздел подкачки - это механизм, который обеспечивает, как и на обычных системах UNIX, продолжение вашей  работы, что бы ни случилось. Из-за этой дополнительной памяти в Linux вы практически никогда не увидите раздражающих сообщений типа <em>"Недостаточно памяти, пожалуйста закройте сначала некоторые приложения и попробуйте еще раз"</em>. Процедура подкачки или виртуальной памяти давно принята операционными системами уже вне мира UNIX.</p>
<p>Используемая память на жестком диске естественно медленнее, чем при использовании реальных микросхем памяти компьютера, но обеспечивает дополнительный комфорт. Мы узнаем больше о разделе подкачки, когда будем обсуждать процессы в <a href="http://younglinux.info/#">Главе 4, Процессы</a>.</p>
<p>Linux обычно рассчитывает на использование удвоенного количества физической памяти в пространстве подкачки на жестком диске. При установке системы, вы должны решить, как собираетесь это сделать. Например на системе с 512 Мб RAM:</p>
<ul>
<li>1-й вариант: один раздел подкачки в 1 Гб</li>
<li>2-й вариант: два раздела подкачки по 512 МБ</li>
<li>3-й вариант: с двумя жесткими дисками: по одному разделу в 512 МБ на каждом диске.</li>
</ul>
<p>Последний вариант даст лучшие результаты, <span style="background-color:yellow;">when a lot of I/O is to be expected</span>.</p>
<p>Читайте документации к программному обеспечению для специфичных установок. Некоторые приложения, такие как базы данных, могут требовать большего пространства подкачки. Другие, такие как портативные системы, могут вообще не иметь никакой подкачки из-за нехватки жесткого диска. Пространство для подкачки может также зависеть от версии вашего ядра.</p>
<p>Кроме того во многих дистрибутивах ядро находится на отдельном разделе, поскольку это самый важный файл вашей системы. Если это так, вы увидите, что у вас также есть раздел <em>/boot</em>, содержащий ваше ядро (ядра) и сопутствующие файлы данных.</p>
<p>Остаток жесткого диска(ов) обычно делится на разделы данных, хотя может быть, что все не критичные для системы данные будут находиться на одном разделе, например, при выполнении стандартной установки рабочей станции. Когда некритичные данных разделяется на несколько разделов, то обычно это происходит по следующему принципу:</p>
<ul>
<li>раздел для пользовательских программ (<em>/usr</em>)</li>
<li>раздел, содержащий персональные данные пользователей (<em>/home</em>)</li>
<li>раздел для хранения временных данных, таких как очереди печати и почты (<em>/var</em>)</li>
<li>раздел для дополнительного программного обеспечения (<em>/opt</em>)</li>
</ul>
<p>После того как разделы сделаны, можно только добавить дополнительные. Изменение размеров или свойств существующих разделов возможно, но не рекомендуется.</p>
<p>Разделение жесткого диска на разделы определяется системным администратором. На больших системах он или она может даже развернуть один раздел на несколько жестких дисков, используя соответствующее ПО. Большинство дистрибутивов при стандартных установках имеют возможность оптимизироваться под рабочие станции (для обычных пользователей), под обычные цели сервера, но также допускают настройку разделов. Во время процесса установки вы можете определить вашу собственную схему разделов, используя либо специфический инструмент вашего дистрибутива, который обычно запускается в начале в графическом интерфейсе, или <strong>fdisk</strong>, инструмент текстового режима для создания разделов и установки их свойств.</p>
<p>Установка рабочей станции или клиентская установка осуществляется для использования главным образом одним и тем же человеком. Выбранное ПО для установки отражает это и акцент делается на общие пользовательские пакеты, такие как красивые темы рабочего стола, инструменты разработки, клиентские программы для работы с электронной почтой, мультимедийный софт, web и другие службы. Все это объединяется на одном большом разделе, добавляется пространство подкачки в два раза превышает объем оперативной памяти и ваша стандартная рабочая станция готова и обеспечивает наибольший объем дискового пространства для возможности личного пользования, но с недостатком возможной потери целостности данных во время проблемных ситуаций.</p>
<p>На сервере системные данные стремятся отделить от пользовательских данных. Программы различных служб хранятся отдельно от данных, которые они обрабатывают. На таких системах создаются различные разделы:</p>
<ul>
<li>раздел со всеми данными, необходимыми для загрузки машины</li>
<li>раздел с конфигурационными данными и серверными программами</li>
<li>один или несколько разделов, содержащих серверные данные, такие как таблицы базы данных, почта пользователей, FTP-архив и т.д.</li>
<li>раздел с пользовательскими программами и приложениями</li>
<li>один или несколько разделов для конкретных пользовательских файлов (домашние каталоги)</li>
<li>один или несколько разделов подкачки (виртуальная память)</li>
</ul>
<p>Службы обычно используют больше памяти и, следовательно, им нужно больше пространства подкачки. Некоторые процессы сервера, такие как связанные с базами данных, могут потребовать больше пространства подкачки, чем обычно; см. специальную документацию для подробной информации. Для повышения производительности swap часто разделяют на несколько разделов.</p>
<h3>Точки монтирования</h3>
<p>Все разделы подключаются к системе через точки монтирования. Точка монтирования определяет место расположения конкретных данных в файловой системе. Как правило все разделы связаны через раздел <em>root</em>. В этом разделе, который обозначается косой чертой (/), создаются каталоги. Эти пустые каталоги будут начальной точкой разделов, которые подключаются к нему. Например: дан раздел, содержащий следующие каталоги:</p>
<pre>
videos/		cd-images/	pictures/
</pre><p>Мы хотим подключить этот раздел к файловой системе в каталог <span class="mono">/opt/media</span>. Для того, чтобы сделать это, системный администратор должен убедиться, что каталог <span class="mono">/opt/media</span> существует в системе. Желательно, это должен быть пустой каталог. Как это делается объясняется далее в этой главе. Затем, используя команду <strong>mount</strong>, администратор может подключить раздел к системе. Если вы посмотрите на содержимое ранее пустой директории <span class="mono">/opt/media</span>, оно будет содержать файлы и каталоги, которые имеются на смонтированном носителе (жестком диске или разделе жесткого диска, CD, DVD, флэш-карте, USB или других устройствах хранения).</p>
<p>Во время запуска системы, именно так монтируются все разделы, которые описаны в файле <span class="mono">/etc/fstab</span>. Некоторые разделы не монтируются по умолчанию, если они постоянно не подключены к системе, например устройство хранения, используемое в вашей цифровой камере. Если все правильно настроено, то устройство будет смонтировано, сразу же как система замечает, что оно подсоединено, или оно может быть смонтировано пользователем, тогда вам не нужно быть системным администратором, чтобы подключать и отключать устройства к системе и от нее. Пример есть в <a href="http://younglinux.info/#">Разделе "Использование rsync"</a>.</p>
<p>На работающей системе информацию о разделах и их точках монтирования можно получить с помощью команды <strong>df</strong> (которая показывает используемое пространство диска). В Linux команда <strong>df</strong> GNU варианта, и поддерживает опцию <span class="mono">-h</span>, которая значительно улучшает читаемость. Отметим, что на коммерческих системах UNIX есть свои собственные версии <strong>df</strong> и многих других команд. Обычно у них такое же поведение, хотя версии обычных инструментов от GNU, часто имеют больше функций и они лучше.</p>
<p>Команда <strong>df</strong> отображает только  информацию об активных разделах (исключая раздел подкачки). Они могут включать разделы других доступных по сети систем, как в примере, приведенном ниже, где домашние каталоги монтируются с файлового сервера по сети, такая ситуация часто встречается в корпоративных средах.</p>
<pre>
freddy:~> <strong>df -h</strong>
Filesystem          Size  Used Avail Use% Mounted on
/dev/hda8           496M  183M  288M  39% /
/dev/hda1           124M  8.4M  109M   8% /boot
/dev/hda5            19G   15G  2.7G  85% /opt
/dev/hda6           7.0G  5.4G  1.2G  81% /usr
/dev/hda7           3.7G  2.7G  867M  77% /var
fs1:/home           8.9G  3.7G  4.7G  44% /.automount/fs1/root/home
</pre><h2>Подробнее о схеме файловой системы</h2>
<h3>Обзор</h3>
<p>Для удобства файловая система Linux обычно представляется в виде древовидной структуры. В стандартной системе Linux вы обнаружите подобный перечень и расположение, как на схеме приведенной ниже.</p>
<p><strong>Рисунок 3.1. Схема файловой системы Linux</strong></p>
<p><img src="../../../img/linuxintro/FS-layout.png" width="653" height="693" alt="Структура каталогов ОС Linux" /></p>
<p>Это схема из системы RedHat. В зависимости от системного администратора, операционной системы и назначения UNIX-машины, структура может меняться, и каталоги по желанию могут быть опущены или добавлены. Даже не обязательно соответствие имен, они лишь соглашение.</p>
<p>Дерево файловой системы начинается со <em>слэша</em>, обозначаемого наклоненной вперед косой чертой (/). Это каталог, содержащий все основные каталоги и файлы, также называется <em>корневой директорией</em> или "корнем" файловой системы.</p>
<p>Каталогам, которые ниже корневого каталога лишь на один уровень, зачастую предшествует слэш, для указания их положения и предотвращения путаницы с другими каталогами, которые могут иметь такое же имя. Знакомясь с новой системой, всегда хорошая идея - заглянуть в корневую директорию. Давайте посмотрим, с чем вы можете там столкнуться:</p>
<pre>
emmy:~> <strong>cd /</strong>
emmy:/> <strong>ls</strong>
bin/   dev/  home/    lib/         misc/  opt/     root/  tmp/  var/
boot/  etc/  initrd/  lost+found/  mnt/   proc/    sbin/  usr/
</pre><p><strong>Таблица 3.2. Подкаталоги корневого каталога</strong></p>
<table class="il">
<tr>
<td width="100"><strong>Директория</strong></td>
<td><strong>Содержимое</strong></td>
</tr>
<tr>
<td>/bin</td>
<td>Общие программы для совместного использования системой, системным администратором и пользователями.</td>
</tr>
<tr>
<td>/boot</td>
<td>Загрузочные файлы и ядро, <span class="mono">vmlinuz</span>. В некоторых последних дистрибутивах также данные <span class="mono">grub</span>. Grub – это большой единый загрузчик, который представляет собой попытку избавиться от многих различных загрузчиков известных нам на сегодняшний день.</td>
</tr>
<tr>
<td>/dev</td>
<td>Содержит ссылки на все периферийные устройства, которые представлены файлами с особыми свойствами.</td>
</tr>
<tr>
<td>/etc</td>
<td>Большинство важных системных файлов конфигурации находятся в <span class="mono">/etc</span>, этот каталог содержит данные, аналогичные тем что в Панели Управления Windows</td>
</tr>
<tr>
<td>/home</td>
<td>Домашние каталоги обычных пользователей.</td>
</tr>
<tr>
<td>/initrd</td>
<td>(в некоторых дистрибутивах) Информация для загрузки. Не удаляйте!</td>
</tr>
<tr>
<td>/lib</td>
<td>Файлы библиотек, включает файлы для всех разновидностей программ, необходимых системе и пользователям.</td>
</tr>
<tr>
<td>/lost+found</td>
<td>Каждый раздел имеет <span class="mono">lost+found</span> в его верхней директории. Здесь находятся файлы, которые были спасены во время сбоев.</td>
</tr>
<tr>
<td>/misc</td>
<td>Для разных целей.</td>
</tr>
<tr>
<td>/mnt</td>
<td>Стандартные точки монтирования для внешних файловых систем, например, CD-ROM'а или цифровой камеры.</td>
</tr>
<tr>
<td>/net</td>
<td>Стандартные точки монтирования для удаленных файловых систем</td>
</tr>
<tr>
<td>/opt</td>
<td>Как правило, содержит дополнительное ПО и ПО третьих сторон.</td>
</tr>
<tr>
<td>/proc</td>
<td>Виртуальная файловая система, содержащая информацию о системных ресурсах. Более подробная информация о назначении файлов в <span class="mono">proc</span> можно получить, введя команду <strong>man</strong> <span class="monoi"> proc</span> в окне терминала. Файл <span class="mono">proc.txt</span> рассматривает виртуальную файловую систему в деталях.</td>
</tr>
<tr>
<td>/root</td>
<td>Домашняя директория администратора. Помните о разнице между / (корневым каталогом) и /root (домашним каталогом пользователя <em>root</em>).</td>
</tr>
<tr>
<td>/sbin</td>
<td>Программы для использования системой и системным администратором.</td>
</tr>
<tr>
<td>/tmp</td>
<td>Временное место для использования системой, которое очищается после перезагрузки, так что не используйте ее под сохранение какой-нибудь работы!</td>
</tr>
<tr>
<td>/usr</td>
<td>Программы, библиотеки, документация и т.д. для всех пользовательских программ.</td>
</tr>
<tr>
<td>/var</td>
<td>Место хранения всех изменяемых и временных файлов, созданных пользователями, такие как log-файлы, почтовые очереди, <span style="background-color:yellow;">the print spooler area</span>, место для временного хранения файлов, загружаемых из Интернета, или сохранения образа CD перед записью.</td>
</tr>
</table>
<p>Как вы можете узнать на каком разделе находится какой-нибудь каталог? Использование команды <strong>df</strong> с точкой (.) в качестве опции показывает раздел, которому принадлежит текущий каталог, и уведомляет о количестве используемого дискового пространства на этом разделе:</p>
<pre>
sandra:/lib> <strong>df -h .</strong>
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda7             980M  163M  767M  18% /
</pre><p>Как правило, каждый каталог в корневом каталоге находится на корневом разделе, за исключением когда он имеет отдельный вход в полным листинге команды <strong>df</strong> (или <strong>df</strong> <span class="mono"> -h</span> без каких-либо других опций).</p>
<p>Узнайте больше в <strong>man </strong> <span class="mono"> hier</span>.</p>
<h3>Файловая система в реальности</h3>
<p>Для большинства пользователей, и для большинства обычных задач системного администрирования, приемлемо допускать, что файлы и каталоги организованы в древовидную структуру. Однако компьютер ничего не понимает о деревьях или древовидных структурах.</p>
<p>Каждый раздел имеет свою собственную файловую систему. Представляя все эти файловые системы вместе, мы можем говорить о древовидной структуре всей системы, но все не так просто. В файловой системе, файл представлен с помощью <em>inode (индексного дескриптора)</em>, своего рода серийного номера, содержащего информацию о данных этого файла: кому принадлежит этот файл, и где он находится на жестком диске.</p>
<p>Каждый раздел имеет свой собственный набор индексных дескрипторов; на всей системе с несколькими разделами могут существовать файлы с одним и тем же номером индексного дескриптора.</p>
<p>Каждый inode описывает структуру данных на жестком диске, хранит информацию о свойствах файла, в том числе физическое местоположение его данных. Когда жесткий диск назначается для хранения данных (обычно во время начала процесса установки системы или при добавлении дополнительных дисков к существующей) в разделе создается определенное количество индексных дескрипторов. Этот число будет максимальным количеством файлов всех типов (в том числе каталогов, специальных файлов, ссылок и т.д.), которые могут существовать в одно и то же время на данном разделе. Как правило, мы рассчитываем на 1 inode от 2 до 8 килобайт памяти.</p>
<p>Во время создания нового файла, он получает свободный inode. В этом индексном дескрипторе содержится следующая информация:</p>
<ul>
<li>Владельца и группа-владелец файла.</li>
<li>Тип файла (обычный, каталог, ...)</li>
<li>Разрешения на файл (<a href="http://younglinux.info/#">Раздел "Права доступа: первая линия обороны Linux"</a>)</li>
<li>Дата и время создания, последнего открытия и изменения.</li>
<li>Дата и время, когда эта информация была изменена в индексном дескрипторе.</li>
<li>Количество ссылок на этот файл (см. далее в этой главе).</li>
<li>Размер файла</li>
<li>Адрес, определяющий фактическое расположение данных файла.</li>
</ul>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Время создания и время изменения.</strong><br />
В man-страницах вы натолкнетесь на <em>atime</em> (время доступа), <em>ctime</em> (время изменения свойств файла) и <em>mtime</em> (время изменения данных (содержания) файла). Вы не всегда можете узнать время создания файла. Если вы измените права доступа  на файл, ctime изменится также и больше не будет отражать реального времени создания.</p>
<p>Единственная информация, не включенная в индексный дескриптор, это имя файла и каталога. Они хранятся в каталогах, этих особенных файлах. Сопоставляя имена файлов и номера inode, система может составлять древовидную структуру, которая понятна пользователю. Пользователи могут отображать номера inode, используя опцию <span class="mono">-i</span> команды <strong>ls</strong>. Индексные дескрипторы имеют свои собственные отдельные места на диске.</p>
  </div>
<div id="node-201" class="section-3">
  <h1 class="book-heading">Ориентация в файловой системе</h1>
  <p>Когда вы хотите, чтобы система выполнила команду, вам почти никогда не надо давать полный путь к этой команде. Например, мы знаем, что команда <strong>ls</strong> находится в каталоге <span class="mono"> /bin</span> (проверьте командой <strong>which </strong> <span class="mono"> -a ls</span>), тем не менее, мы не обязаны вводить команду <strong><strong><strong>/bin/ls</strong></strong></strong> в компьютер, чтобы получить список содержимого текущей директории.</p>
<p>Дело в том, что об этом заботится переменная окружения <span class="mono">PATH</span>. В ней перечисляются те каталоги системы, где могут быть найдены исполняемые файлы, что освобождает пользователя от излишнего ввода символов  и запоминания местонахождения команд. Естественно <span class="mono">PATH</span> (путь) содержит множество каталогов, обычно содержащих где-то в своих именах <span class="mono">bin</span>, что показано ниже. Команда <strong>echo</strong> используется для отображения содержимого ("$") переменной <span class="mono">PATH</span>:</p>
<pre>
rogier:> <strong>echo $PATH</strong>
/opt/local/bin:/usr/X11R6/bin:/usr/bin:/usr/sbin/:/bin
</pre><p>В этом примере, каталоги <span class="mono">/opt/local/bin, /usr/X11R6/bin, /usr/bin, /usr/sbin</span> и <span class="mono">/bin</span> являются местами последовательного поиска нужной программы. Как только она найдена, поиск останавливается, даже если еще не каждый каталог в path проверен. Это может привести к странным ситуациям. В первом примере ниже пользователь знает, что есть программа под названием <strong>sendsms</strong> для отправления SMS сообщений, и другой пользователь в той же самой системе может ей пользоваться, но не первый пользователь. Разница заключается в конфигурации переменной <span class="mono">PATH</span>:</p>
<pre>
[jenny@blob jenny]$ <strong>sendsms</strong>
bash: sendsms: command not found
[jenny@blob jenny]$ echo $PATH
/bin:/usr/bin:/usr/bin/X11:/usr/X11R6/bin:/home/jenny/bin
[jenny@blob jenny]$ su - tony
Password:
tony:~>which sendsms
sendsms is /usr/local/bin/sendsms

tony:~>echo $PATH
/home/tony/bin.Linux:/home/tony/bin:/usr/local/bin:/usr/local/sbin:\
/usr/X11R6/bin:/usr/bin:/usr/sbin:/bin:/sbin
</pre><p>
Обратите внимание на использование средства <strong>su</strong> (переключение пользователей), которое позволяет запускать shell в среде другого пользователя, конечно при условии, что вы знаете пароль этого пользователя.</p>
<p>Обратная косая черта обозначает продолжение данной строки на другую и игнорирует разделение с помощью клавиши <strong>Enter</strong>.</p>
<p>В следующем примере, пользователь хочет вызвать команду <strong>wc</strong> (количество слов), чтобы проверить количество строк в файле, но ничего не происходит, и он вынужден прервать ее работу, используя комбинацию <strong>Ctrl + C</strong>:</p>
<pre>
jumper:~> <strong>wc -l test</strong>

(Ctrl-C)
jumper:~> <strong>which wc</strong>
wc is hashed (/home/jumper/bin/wc)

jumper:~> <strong>echo $PATH</strong>
/home/jumper/bin:/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin:\
/usr/bin:/usr/sbin:/bin:/sbin
</pre><p>
Использование команды <strong>which</strong> показывает нам, что у этого пользователя есть <span class="mono">bin</span>-каталог в его домашней директории, содержащей программу также под названием <strong>wc</strong>. Поскольку программа в домашнем каталоге находится первой при просмотре путей при вызове <strong>wc</strong>, выполняется эта «самодельная» программа, которая, вероятно, не понимает ввод, поэтому потребовалось ее завершить. Для решения проблем подобного рода есть несколько способов (вообще в UNIX/Linux всегда есть несколько вариантов решения проблем): одно решение — это переименовать  программу <strong>wc</strong> пользователя, или пользователь может вводить полный путь к требуемой ему команде, который можно определить, используя опцию <span class="mono">-a</span> команды <strong>which</strong>.</p>
<p>Однако, если пользователь чаще использует программы из других каталогов, то может изменить последовательность просмотра каталогов на свой собственный вариант:</p>
<pre>
jumper:~> <strong>export PATH=/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin:\
/usr/bin:/usr/sbin:/bin:/sbin:/home/jumper/bin</strong>
</pre><p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>  Изменения не постоянны!</strong><br />
Обратите внимание, что при использовании в командной строке команды <strong>export</strong>, изменения носят временный характер и действуют только в данной сессии (до выхода). Открытие новой сессии (даже если текущая первая по прежнему работает) не приводи к наличию в ней новых путей. Мы увидим в <a href="http://younglinux.info/#">Разделе "Ваше текстовое окружение"</a>, как можно сделать такого рода изменения окружения постоянными, путем добавления этих строк в конфигурационные файлы оболочки.</p>
<h2>Абсолютные и относительные пути</h2>
<p>Путь, по которым вы должны следовать в древовидной структуре, чтобы получить заданный файл, может быть описан, начиная от ствола дерева (/ или корневого каталога). В этом случае путь начинается со слэша и называется абсолютным путем, поскольку не может быть никакого заблуждения: только один файл в системе может подойти под него.</p>
<p>В другом случае, путь не начинается со слэша и возможна путаница по сравнению с предыдущим вариантом между <span class="mono">~/bin/wc</span> (в домашнем каталоге пользователя) и <span class="mono">bin/wc</span> в <span class="mono">/usr</span>. Пути, которые не начинаются со слэша всегда относительные.</p>
<p>В относительных путях мы также используем . и .., указывающие на текущий и родительский каталоги. Пара практических примеров:</p>
<ul>
<li>Если вы хотите компилировать исходный код, документация к установке часто инструктирует вас выполнить команду <strong>./configure</strong>, которая запускает программу <em>configure</em>, расположенную в текущем каталоге (и которая поставляется с новым кодом), а ни где-то в  другом месте системы.</li>
<li>В файлах HTML, относительных пути часто используются, чтобы сделать ряд страниц, легко переносимыми в другое место:</li>
</ul>
<p><div class="geshifilter"><pre class="python geshifilter-python" style="font-family:monospace;"><span style="color: #66cc66;">&lt;</span>img alt=<span style="color: #483d8b;">&quot;Garden with trees&quot;</span> src=<span style="color: #483d8b;">&quot;../images/garden.jpg&quot;</span><span style="color: #66cc66;">&gt;</span></pre></div></p>
<ul>
<li>Обратите внимание на различие еще раз:</li>
</ul>
<pre>
theo:~> <strong>ls /mp3</strong>
ls: /mp3: No such file or directory
theo:~> <strong>ls mp3/</strong>
oriental/  pop/  sixties/
</pre><h2>Наиболее важные файлы и каталоги</h2>
<h3>Ядро</h3>
<p>Ядро является сердцем системы. Оно управляет связью между основной аппаратурой и периферией. Ядро также гарантирует, что процессы и демоны (серверные процессы) начинаются и останавливаются строго в требуемое время. У ядра много других важных задач, так много, что специальная рассылка по разработки ядра существуют только по тому вопросу, где огромные объемы информации являются общими. Мы бы зашли слишком далеко, обсуждая ядро в деталях. Сейчас достаточно знать, что ядро – это самый важный файл в системе.</p>
<h3>Оболочка (Shell)</h3>
<h4>Что такое shell?</h4>
<p>Когда я смотрела соответствующее разъяснение по концепции оболочки, это дало мне больше хлопот, чем я ожидала. Все доступные определения, от простого сравнения, что "оболочка - это руль автомобиля", к расплывчатому определению в руководстве Bash, где говорится, что "bash является sh-совместимым интерпретатором командного языка", до еще более неясного выражения "оболочка управляет взаимодействием между системой и ее пользователями". Shell гораздо больше, чем все это.</p>
<p>Самым лучшим сравнением для оболочки может быть представление о способе общения с компьютером, сравнение оболочки с языком. Большинство пользователей знают другой «язык», это язык «укажи-и-щелкни» графического рабочего стола. Но на этом языке компьютер задает беседу, а пользователю отведена пассивная роль выбора задач их тех, что представлены. Для программиста очень трудно включить в GUI-формат все опции и способы применения команд. Поэтому графические интерфейсы почти всегда менее способные, чем команды, стоящие за ним.</p>
<p>Оболочка, с другой стороны, это расширенный способ общения с системой, поскольку она позволяет вести двустороннюю беседу и проявлять инициативу. Оба партнера в сообщении равны, так что могут быть проверены новые идеи. Оболочка позволяет пользователю очень гибко управлять системой. Дополнительным преимуществом является то, что оболочка позволяет автоматизировать задачи.</p>
<h4>Типы оболочек</h4>
<p>Так же как люди знают различных языки и диалекты, компьютеру известны различные типы оболочек:</p>
<ul>
<li><strong>sh</strong> или Bourne Shell: первая оболочка, которая до сих пор используются в системах UNIX. Это базовая оболочка, представляющая собой небольшую программу с незначительным числом функций. В POSIX-совместимом режиме bash будет эмулировать эту оболочку.</li>
<li><strong>bash</strong> или Bourne Again Shell: стандартная оболочка GNU, интуитивно понятная и гибкая. Наиболее предпочтительная для начинающих пользователей, и в то же время являющаяся мощным инструментом для опытных и профессиональных пользователей. На Linux <strong>bash</strong> – это стандартная оболочка обычных пользователей. Эта оболочка является так называемой расширенной Bourne shell, с множеством дополнений и плагинов. Это означает, что Bourne Again SHell совместима с Bourne shell: команды, которые работают в <strong>sh</strong>, также работают в <strong>bash</strong>. Однако, обратное не всегда соответствует действительности. Все примеры и упражнения в этой книге приведены с использованием <strong>bash</strong>.</li>
<li><strong>csh</strong> или C Shell: синтаксис этой оболочки напоминает синтаксис языка программирования Си. Иногда используется программистами.</li>
<li><strong>tcsh</strong> или Turbo C Shell: расширенный вариант обычной C Shell, обеспечивает большее удобство и скорость.</li>
<li><strong>ksh</strong> или оболочка Корна: иногда ценится людьми с опытом работы в UNIX. Расширение оболочки Борна; в стандартной конфигурации – кошмар для начинающих пользователей.</li>
</ul>
<p>Файл <span class="mono">/etc/shells</span> дает обзор известных системе Linux оболочек:</p>
<pre>
mia:~> <strong>cat /etc/shells</strong>
/bin/bash
/bin/sh
/bin/tcsh
/bin/csh
</pre><p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Хитрость оболочки Борна.</strong><br />
Обратите внимание, что <span class="mono">/bin/sh</span>, как правило, ссылка на Bash, которая будет при вызове по этому пути выполнять в оболочке Борна совместимый режим.</p>
<p>Ваша оболочка, которая используется по умолчанию, описывается в файле <span class="mono">/etc/passwd</span>, подобно этой строке для пользователя <em>mia</em>:</p>
<pre>
mia:L2NOfqdlPrHwE:504:504:Mia Maya:/home/mia:/bin/bash
</pre><p>
Чтобы перейти из одной оболочки в другую, просто введите название новой оболочки в активном терминале. Система находит каталог, где встречается это имя  с помощью установок PATH, и поскольку оболочка является исполняемым файлом (программой), текущая оболочка активирует ее, после чего она запустится. Обычно это отражает новое приглашение, т.к. у каждой оболочки оно имеет типичный внешний вид:</p>
<pre>
mia:~> <strong>tcsh</strong>
[mia@post21 ~]$
</pre><h4>Какую оболочку я использую?</h4>
<p>Если вы не знаете, какую оболочку используете, либо проверьте строку для вашей учетной записи в <span class="mono">/etc/passwd</span>, либо введите команду<br />
<span class="mono">echo $SHELL</span></p>
<h3>Ваш домашний каталог</h3>
<p>Ваш каталог является вашим местонахождением по умолчанию при подключении к системе. В большинстве случаев это подкаталог <span class="mono">/home</span>, хотя это можно изменить. Ваш домашний каталог может находиться на жестком диске удаленного файлового сервера, в этом случае домашнюю директорию можно найти в <span class="mono">/nethome/your_user_name</span>. В другом случае системный администратор может сделать выбор в пользу менее понятной схемы и ваша домашняя директория может оказаться на <span class="mono">/disk6/HU/07/jgillard</span>.</p>
<p>Каким бы ни был путь к вашей домашней директории, вы не должны слишком беспокоиться об этом. Правильный путь к вашей домашней директории хранится в переменной окружения <span class="mono">HOME</span> на случай, если какой-нибудь программе это потребуется. С помощью команды echo вы можете вывести на экран содержимое этой переменной:</p>
<pre>
orlando:~> <strong>echo $HOME</strong>
/nethome/orlando
</pre><p>
В вашем домашнем каталоге вы можете делать все, что вам нравится. Вы можете поместить любое количество файлов в такое количество каталогов, как вам захочется, хотя, естественно, общий объем данных и файлов ограничивается размерами разделов и иногда тем, что системный администратор применил квоты для системы. Ограничение использования дискового пространства было обычной практикой, когда память на жестком диске оставалась дорогой. В наши дни такие ограничения встречаются почти исключительно в больших средах. Вы можете выяснить для себя,  устанавливается ли ограничение с помощью команды <strong>quota</strong>:</p>
<pre>
pierre@lamaison:/> <strong>quota -v</strong>
Diskquotas for user pierre (uid 501): none
</pre><p>
В случае, если квоты были установлены, вы получите список разделов, на которые распространяются ограничения, и размер последних. Превышение пределов может быть допущено во время льготного периода с меньшими ограничениями или их отсутствием. Детальную информацию можно получить с помощью команд <strong>info </strong> <span class="monoi"> quota</span> или <strong>man </strong> <span class="monoi"> quota</span>.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Нет Quota?</strong><br />
Если ваша система не может найти quota, то никаких ограничений в отношении использования файловой системы не применяется.</p>
<p>Ваш домашний каталог обозначается символом тильды (~), это сокращение для <span class="mono">/path_to_home/user_name</span> (домашнего каталога пользователя). Этот же путь хранится в переменной <span class="mono">HOME</span>, так что вам не нужно набирать лишнее для перехода в домашний каталог. Простое применение: переход из <span class="mono">/var/music/albums/arno/2001</span> в <span class="mono">images</span> в вашем домашнем каталоге с помощью одной элегантной команды:</p>
<pre>
rom:/var/music/albums/arno/2001> <strong>cd ~/images</strong>

rom:~/images> pwd
/home/rom/images
</pre><p>
Далее в этой главе мы поговорим о командах для управления файлами и каталогами, все это поможет сохранить порядок в вашем домашнем каталоге.</p>
<h2>Наиболее важные конфигурационные файлы</h2>
<p>Как мы уже отмечали ранее, подавляющее большинство конфигурационных файлов хранятся в директории <span class="mono">/etc</span>. Содержание файлов может быть просмотрено с помощью команды <span class="mono">cat</span>, которая отправляет текст файлов на стандартный вывод (обычно ваш монитор). Синтаксис прямо вперед вами:</p>
<p><span class="mono">cat file1 file2 ... fileN  </span></p>
<p>В этом разделе мы постараемся дать обзор наиболее распространенных конфигурационных файлов. Это, конечно, не полный список. Добавление дополнительных пакетов может также привести к добавлению дополнительных файлов конфигурации в <span class="mono">/etc</span>. При чтении конфигурационных файлов, вы увидите, что они, как правило, очень хорошо прокомментированы и не требуют пояснений. У некоторых файлов также имеются man-страницы, которые содержат дополнительную документацию, например <strong>man</strong> <span class="monoi">group</span>.</p>
<p><strong>Таблица 3.3. Большинство распространенных конфигурационных файлов</strong></p>
<table>
<tr>
<td width="150"><strong>Файл</strong></td>
<td><strong>Информация/служба</strong></td>
</tr>
<tr>
<td>aliases</td>
<td>Файл почтовых псевдонимов для использования с почтовыми серверами Sendmail и Postfix. Запуск почтового сервера на каждой системе давно стал обычным делом в мире UNIX, и почти каждый дистрибутив Linux по-прежнему поставляется с пакетом Sendmail. В этом файле локальные имена пользователей сопоставляются с реальными именами, которые имеют место в E-mail адресах или других локальных адресах.</td>
</tr>
<tr>
<td>apache</td>
<td>Config-файлы для веб-сервера Apache.</td>
</tr>
<tr>
<td>bashrc</td>
<td>Общесистемный конфигурационный файл для Bourne Again Shell. Определяет возможности и псевдонимы для всех пользователей. У других оболочек могут быть свои собственные общесистемные конфигурационные файлы, к примеру <span class="mono">cshrc</span>.</td>
</tr>
<tr>
<td>Каталоги crontab  и cron.* </td>
<td>Настройка задач, которые должны периодически выполняться - резервное копирование, обновления баз данных системы, очистка системы, изменяющиеся журналы и т.д</td>
</tr>
<tr>
<td>default</td>
<td>Параметры по умолчанию для некоторых команд, таких как <strong>useradd</strong>.</td>
</tr>
<tr>
<td>filesystems</td>
<td>Известные файловые системы: ext3, vfat, iso9660 и т.д.</td>
</tr>
<tr>
<td>fstab</td>
<td>Список разделов и их точек монтирования.</td>
</tr>
<tr>
<td>ftp*</td>
<td>Настройка FTP-сервера: кто может подключаться, какие части системы доступны и т.д.</td>
</tr>
<tr>
<td>group</td>
<td>Файл конфигурации для пользовательских групп. Используйте теневые утилиты <strong>groupadd, groupmod</strong> и <strong>groupdel</strong> для редактирования этого файла. Редактируйте вручную, только если точно знаете, что делаете.</td>
</tr>
<tr>
<td>hosts</td>
<td>Список машин, с которыми можно связаться по сети, но без использования службы доменных имен. Это не имеет ничего общего с сетевой конфигурацией системы, которая настраивается в <span class="mono">/etc/sysconfig</span>.</td>
</tr>
<tr>
<td>inittab</td>
<td>Информация для загрузки: режим, количество текстовых консолей и т.д.</td>
</tr>
<tr>
<td>issue</td>
<td>Информация о дистрибутиве (версия и/или информация о ядре).</td>
</tr>
<tr>
<td>ld.so.conf</td>
<td>Места файлов библиотек.</td>
</tr>
<tr>
<td>lilo.conf, silo.conf, aboot.conf и т.д.</td>
<td>Загрузочная информации для LInux LOader, системы для загрузки, которую в настоящее время постепенно вытесняет GRUB.</td>
</tr>
<tr>
<td>logrotate.*</td>
<td>Ротация журналов, система предотвращения накопления огромного количества лог-файлов.</td>
</tr>
<tr>
<td>mail</td>
<td>Каталог, содержащий инструкции для деятельности почтового сервера.</td>
</tr>
<tr>
<td>modules.conf</td>
<td>Конфигурация модулей, которые включают специальные функции (драйвера).</td>
</tr>
<tr>
<td>motd</td>
<td>Сообщение дня. Показывается каждому, кто подключается к системе (в текстовом режиме), может быть использована системным администратором для объявления о техническом обслуживании системы и т.д.</td>
</tr>
<tr>
<td>mtab</td>
<td>Смонтированные в данный момент файловые системы. Рекомендуется никогда не редактировать этот файл.</td>
</tr>
<tr>
<td>nsswitch.conf</td>
<td><span style="background-color:yellow;">Order in which to contact the name resolvers when a process demands resolving of a host name</span>.</td>
</tr>
<tr>
<td>pam.d</td>
<td>Конфигурация модулей аутентификации.</td>
</tr>
<tr>
<td>passwd</td>
<td>Список локальных пользователей. Используйте теневые утилиты  <strong>useradd, usermod</strong> и <strong>userdel</strong> для редактирования этого файла. Правьте вручную только, когда действительно знаете что делаете.</td>
</tr>
<tr>
<td>printcap</td>
<td>Устаревший, но по-прежнему часто используемый файл конфигурации принтера. Не изменяйте его вручную, если точно не знаете, что  делаете.</td>
</tr>
<tr>
<td>profile</td>
<td>Система расширенной конфигурации среды shell: переменные, свойства по умолчанию новых файлов, ограничение ресурсов и т.д.</td>
</tr>
<tr>
<td>rc*</td>
<td>Каталоги, определяющие активные службы для каждой запущенной ступени.</td>
</tr>
<tr>
<td>resolv.conf</td>
<td>Последовательность, в которой связываются с DNS-серверами (только серверы доменных имен).</td>
</tr>
<tr>
<td>sendmail.cf</td>
<td>Главный конфигурационный файл сервера Sendmail.</td>
</tr>
<tr>
<td>services</td>
<td>Соединения, принятые на этой машине (открытые порты).</td>
</tr>
<tr>
<td>sndconfig или sound</td>
<td>Настройка звуковой карты и звуковых событий.</td>
</tr>
<tr>
<td>ssh</td>
<td>Каталог, содержащий конфигурационные файлы для защиты оболочки клиента или сервера.</td>
</tr>
<tr>
<td>sysconfig</td>
<td>Каталог, содержащий системные конфигурационные файлы: мышь, клавиатура, сеть, рабочий стол, системные часы, управление питанием т.д. (характерно для RedHat).</td>
</tr>
<tr>
<td>X11</td>
<td>Параметры графического сервера, X. RedHat использует XFree, что находит отражение в имени основного конфигурационного файла, XFree86Config. Также содержит общие каталоги оконных менеджеров, имеющихся в системе, например, <strong>gdm, fvwm, twm</strong> и т.д</td>
</tr>
<tr>
<td>xinetd.* или inetd.conf</td>
<td>Конфигурационные файлы для Интернет-сервисов, <span style="background-color:yellow;">that are run from the system's (extended) Internet services daemon (servers that don't run an independent daemon)</span>.</td>
</tr>
</table>
<p>В данном руководстве мы узнаем больше об этих файлах и изучим в деталях некоторые из них.</p>
<h2>Наиболее распространенные устройства</h2>
<p>Устройства, под которыми обычно понимается все, что принадлежит периферии ПК, что не является самим процессором, представлены в системе как запись в каталоге <span class="mono">/dev</span>. Одним из преимуществ этого UNIX-способа управления устройствами является то, что ни пользователю, ни системе не нужно  беспокоиться о спецификации устройств.</p>
<p>Пользователи, которые не знакомы с Linux или UNIX в целом, часто перегруженные количеством новых имен и понятий, должны учиться. Поэтому приведем список обычных устройств, описанных в этом введении.</p>
<p><strong>Таблица 3.4. Основные устройства</strong></p>
<table width="150">
<tr>
<td><strong>Имя</strong></td>
<td><strong>Устройство</strong></td>
</tr>
<tr>
<td>cdrom</td>
<td>CD привод</td>
</tr>
<tr>
<td>console</td>
<td>Специальный вход для используемой в настоящее время консоли.</td>
</tr>
<tr>
<td>cua*</td>
<td>Последовательные порты</td>
</tr>
<tr>
<td>dsp*</td>
<td>Устройства для оцифровки и записи</td>
</tr>
<tr>
<td>fd*</td>
<td>Записи для большинства видов гибких дисков, по умолчанию это <span class="mono">/dev/fd0</span>, дисковод для дискет по 1,44 Мбайт.</td>
</tr>
<tr>
<td>hd[a-t][1-16]</td>
<td>Стандартная поддержка дисков IDE с максимальным количеством разделов для каждого.</td>
</tr>
<tr>
<td>ir*</td>
<td>Инфракрасные устройства</td>
</tr>
<tr>
<td>isdn*</td>
<td>Управление соединением ISDN</td>
</tr>
<tr>
<td>js*</td>
<td>Джойстики</td>
</tr>
<tr>
<td>lp*</td>
<td>Принтеры</td>
</tr>
<tr>
<td>mem</td>
<td>Память</td>
</tr>
<tr>
<td>midi*</td>
<td>MIDI-плеер</td>
</tr>
<tr>
<td>mixer* и music</td>
<td>Идеализированная модель миксера (смешивает или добавляет сигналы)</td>
</tr>
<tr>
<td>modem</td>
<td>Модем</td>
</tr>
<tr>
<td>mouse (также msmouse, logimouse, psmouse, input/mice, psaux)</td>
<td>Все виды мышей</td>
</tr>
<tr>
<td>null</td>
<td>Бездонный ящик для мусора</td>
</tr>
<tr>
<td>par*</td>
<td>Записи для поддержки параллельных портов</td>
</tr>
<tr>
<td>pty*</td>
<td>Псевдотерминалы</td>
</tr>
<tr>
<td>radio*</td>
<td>Для радиолюбителей (HAM).</td>
</tr>
<tr>
<td>ram*</td>
<td>Загрузочное устройство</td>
</tr>
<tr>
<td>sd*</td>
<td>SCSI диски с их разделами</td>
</tr>
<tr>
<td>sequencer</td>
<td>Для аудио приложений, использующих особенности синтезатора звуковой карты (контроллер MIDI-устройства).</td>
</tr>
<tr>
<td>tty*</td>
<td>Виртуальные консоли моделирования терминалов vt100.</td>
</tr>
<tr>
<td>usb*</td>
<td>USB карта и сканер.</td>
</tr>
<tr>
<td>video*</td>
<td>Для использования с графической картой, поддерживающей видео.</td>
</tr>
</table>
<h2>Наиболее распространенные временные файлы</h2>
<p>В каталоге <span class="mono">/var</span>  мы находим множество каталогов, предназначенных для хранения особых непостоянных данных (в отличие от конфигурационных файлов системы, которые меняют сравнительно редко или никогда вообще). Все файлы, которые часто изменяются, например, лог-файлы, почтовые ящики, заблокированные файлы, очередь печати и т.д., хранятся в подкаталоге <span class="mono">/var</span>.</p>
<p>В качестве меры безопасности эти файлы обычно хранят отдельно от основных системных файлов, поэтому мы можем закрыть на них глаза, а где нужно устанавливать более строгие разрешения. Многие из этих файлов также требуют больше прав, чем обычно, как <span class="mono">/var/tmp</span>, который должен быть доступен для записи для всех. Основную массу пользовательской активности можно обнаружить именно здесь, которая даже может генерироваться анонимными интернет-пользователями, подключенными к вашей системе. Это одна из причин, почему каталог <span class="mono">/var</span>, включая все его подкаталоги, обычно делают на отдельном разделе. Таким образом, например, пытаются избежать риска, ведь может случиться почтовая бомба, заполняющая свободную часть файловой системы, содержащей более важные данные, такие как ваши программы и файлы конфигурации.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>  /var/tmp и /tmp</strong><br />
Файлы в <span class="mono">/tmp</span> могут быть удалены без уведомления в процессе выполнения очередных задач системы или в результате перезагрузки. В некоторых (индивидуально настроенных) системах <span class="mono">/var/tmp</span> может вести себя непредсказуемо. Тем не менее, поскольку это не так по умолчанию, мы рекомендуем использовать директорию <span class="mono">/var/tmp</span> для сохранения временных файлов. Если есть сомнения, обратитесь к системному администратору. Если вы управляете вашей системой сами, то можете быть уверены в безопасности этого места, если целенаправленно не изменяли настройки для <span class="mono">/var/tmp</span> (с правами администратора, обычный пользователь этого сделать не может).<br />
Что бы вы не делали, старайтесь придерживаться привилегий, предоставленных обычному пользователю - не сохраняйте файлы непосредственно в корневой каталог (/) файловой системы, не помещайте их в каталог <span class="mono">/usr</span> или или его подкаталог или в другое непредназначенное место. Это в значительной степени ограничивает ваш доступ к безопасной файловых систем.</p>
<p>Одной из основных систем безопасности в UNIX, и конечно в каждом дистрибутиве Linux, является журнал учета объектов, который записывает все действия пользователя, процессы, системные события и т.д. Файл конфигурации так называемого syslogdaemon определяет, какая и как долго вошедшая информация будет храниться. По умолчанию все журналы находятся в каталоге <span class="mono">/var/log</span>, содержащем различные файлы журналов доступа, серверов, системных сообщений и т.д. </p>
<p>В <span class="mono">/var</span> мы обычно находим серверные данные, которые сохраняются здесь с целью отделить их от критически важных данных, таких как сама программа-сервер и ее конфигурационные файлы. Типичным примером в системах Linux является <span class="mono">/var/www</span>, который содержит настоящие страницы HTML, скрипты и изображения, которые передал веб-сервер. FTP-дерево сервера FTP (данные, которые могут быть загружены удаленным клиентом) также лучше хранить в одном из подкаталогов <span class="mono">/var</span>. Эти данные общедоступны и часто изменяемы анонимными пользователями, поэтому безопаснее их держать здесь, подальше от разделов или каталогов с конфиденциальными данными.</p>
<p>На большинстве установленных рабочих станций <span class="mono">/var/spool</span> как минимум будет содержать <span class="mono">at</span> и каталог <span class="mono">cron</span>, содержащий запланированные задания. В офисных окружениях этот каталог также обычно содержит <span class="mono">lpd</span>, который хранит очередь(и) печати и далее файлы конфигурации принтера, а также log-файлы принтера. </p>
<p>На серверных системах мы будем обычно находить <span class="mono">/var/spool/mail</span>, содержащий входящую почту для локальных пользователей, отсортированную в один файл для каждого пользователя, "почтовый ящик пользователя". Связанный каталог <span class="mono">mqueue</span>, диспетчер очереди для неотправленных почтовых сообщений. Эти компоненты системы могут быть сильно задействованы на почтовых серверах с большим количеством пользователей. Новости серверов также используют пространство <span class="mono">/var/spool</span> из-за огромного количества сообщений, которые они должны обработать. </p>
<p>Каталог <span class="mono">/var/lib/rpm</span> специфичен для базирующихся на RPM (RedHat Package Manager) дистрибутивов; это те, в которых информация сохраняется в RPM-пакетах. Другие менеджеры пакетов обычно также сохраняют их данные где-то в <span class="mono">/var</span>.</p>
  </div>
<div id="node-203" class="section-3">
  <h1 class="book-heading">Управление файлами</h1>
  <h2>Просмотр свойств файла</h2>
<h3>Дополнительная информация о ls</h3>
<p>Помимо имени файла команда <strong>ls</strong> может дать много другой информации, например, тип файла (это мы уже обсуждали). Она может также показать права доступа к файлу, его размер, номер индексного дескриптора, дату и время создания, владельцев и количество ссылок на файл. Также использование <strong>ls</strong> вместе с опцией <span class="mono">-a</span> может отобразить файлы, обычно скрытые от глаз. Имена таких файлов начинается с точки. Типичный пример — это конфигурационные файлы в вашем домашнем каталоге. Когда вы проработаете в определенной системе некоторое время, то заметите, что были созданы десятки файлов и каталогов, <span style="background-color:yellow;">that are not automatically listed in a directory index</span>. Наряду с этим, каждый каталог содержит файл, именуемый просто точкой (.) и один с двумя точками (..), которые используются в сочетании с номером их индексного дескриптора для определения расположения каталога в древовидной структуре файловой системы.</p>
<p>Вам действительно следует прочитать страницы info о команде <strong>ls</strong>, так как это часто используемая команда с большим количеством полезных опций. Опции могут быть скомбинированы, как и в случае с большинством команд UNIX и их параметрами. Часто используемая комбинация <strong>ls</strong> <span class="mono"> -al</span>; она отображает длинный список файлов и их свойств, а также пути, на которые указывают символические ссылки. <strong>ls </strong> <span class="mono"> -latr</span> отображает те же файлы, только теперь в обратном порядке по признаку последнего изменения, так что файл, измененный в самое последнее время, находится в нижней части списка. Вот несколько примеров:</p>
<pre>
krissie:~/mp3> <strong>ls</strong>
Albums/  Radio/  Singles/  gene/  index.html

krissie:~/mp3> <strong>ls -a</strong>
./   .thumbs  Radio     gene/
../  Albums/  Singles/  index.html

krissie:~/mp3> <strong>ls -l Radio/</strong>
total 8
drwxr-xr-x    2 krissie krissie  4096 Oct 30  1999 Carolina/
drwxr-xr-x    2 krissie krissie  4096 Sep 24  1999 Slashdot/

krissie:~/mp3> <strong>ls -ld Radio/</strong>
drwxr-xr-x    4 krissie krissie  4096 Oct 30  1999 Radio/

krissie:~/mp3> <strong>ls -ltr</strong>
total 20
drwxr-xr-x    4 krissie krissie  4096 Oct 30  1999 Radio/
-rw-r--r--    1 krissie krissie   453 Jan  7  2001 index.html
drwxrwxr-x   30 krissie krissie  4096 Oct 20 17:32 Singles/
drwxr-xr-x    2 krissie krissie  4096 Dec  4 23:22 gene/
drwxrwxr-x   13 krissie krissie  4096 Dec 21 11:40 Albums/
</pre><p>
В большинстве версий Linux <strong>ls</strong> является псевдонимом «цветного <strong>ls</strong>» по умолчанию. Это свойство позволяет увидеть тип файла без использования какой-либо опции <strong>ls</strong>. Для достижения этого каждому типу файла присваивается свой собственный цвет. Стандартная схема находится в <span class="mono">/etc/DIR_COLORS</span>:</p>
<p><strong>Таблица 3.5. Цветовая схема color-ls по умолчанию</strong></p>
<table class="il">
<tr>
<td width="100"><strong>Цвет</strong></td>
<td><strong>Тип файла</strong></td>
</tr>
<tr>
<td>Голубой</td>
<td>каталоги</td>
</tr>
<tr>
<td>Красный</td>
<td>сжатые архивы</td>
</tr>
<tr>
<td>Белый</td>
<td>текстовые файлы</td>
</tr>
<tr>
<td>Розовый</td>
<td>изображения</td>
</tr>
<tr>
<td>Голубой</td>
<td>ссылки</td>
</tr>
<tr>
<td>Желтый</td>
<td>устройства</td>
</tr>
<tr>
<td>Зеленый</td>
<td>исполняемые файлы</td>
</tr>
<tr>
<td>Мигающий красный</td>
<td>неисправные ссылки</td>
</tr>
</table>
<p>Больше информации найдется на man-странице. В прежние дни та же информация отображалась с помощью суффиксов для каждого имени нестандартного файла. При использовании моно-цвета (например, печати списка содержимого каталога) и для общей очевидности эта схема используется до сих пор:</p>
<p><strong>Таблица 3.6. Схема суффиксов по умолчанию для команды ls </strong></p>
<table class="il">
<tr>
<td width="100"><strong>Символ</strong></td>
<td><strong>Тип файла</strong></td>
</tr>
<tr>
<td>Ничего</td>
<td>Обычный файл</td>
</tr>
<tr>
<td>/</td>
<td>Каталог</td>
</tr>
<tr>
<td>*</td>
<td>Исполняемый файл</td>
</tr>
<tr>
<td>@</td>
<td>Ссылка</td>
</tr>
<tr>
<td>=</td>
<td>Сокет</td>
</tr>
<tr>
<td>|</td>
<td>Именованный канал</td>
</tr>
</table>
<p>Полное описание функциональности и особенностей команды <strong>ls</strong> можно узнать с помощью <strong>info </strong> <span class="monoi"> coreutils ls</span>.</p>
<h3>Дополнительные инструменты</h3>
<p>Чтобы узнать больше о типе данных, с которыми имеем дело, мы используем команду <strong>file</strong>. Применяя определенные тесты, которые проверяют свойства файла в файловой системе, «магические числа» и делают «лингвистические пробы», <strong>file</strong> пытается догадаться о формате файла. Вот некоторые примеры:</p>
<pre>
mike:~> <strong>file Documents/</strong>
Documents/: directory

mike:~> <strong>file high-tech-stats.pdf</strong>
high-tech-stats.pdf: PDF document, version 1.2

mike:~> <strong>file Nari-288.rm</strong>
Nari-288.rm: RealMedia file

mike:~> <strong>file bijlage10.sdw</strong>
bijlage10.sdw: Microsoft Office Document

mike:~> <strong>file logo.xcf</strong>
logo.xcf: GIMP XCF image data, version 0, 150 x 38, RGB Color

mike:~> <strong>file cv.txt</strong>
cv.txt: ISO-8859 text

mike:~> <strong>file image.png</strong>
image.png: PNG image data, 616 x 862, 8-bit grayscale, non-interlaced

mike:~> <strong>file figure</strong>
figure: ASCII text

mike:~> <strong>file me+tux.jpg</strong>
me+tux.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI),
            "28 Jun 1999", 144 x 144

mike:~> <strong>file 42.zip.gz</strong>
42.zip.gz: gzip compressed data, deflated, original filename,
         `42.zip', last modified: Thu Nov  1 23:45:39 2001, os: Unix

mike:~> <strong>file vi.gif</strong>
vi.gif: GIF image data, version 89a, 88 x 31

mike:~> <strong>file slide1</strong>
slide1: HTML document text

mike:~> <strong>file template.xls</strong>
template.xls: Microsoft Office Document

mike:~> <strong>file abook.ps</strong>
abook.ps: PostScript document text conforming at level 2.0

mike:~> <strong>file /dev/log</strong>
/dev/log: socket

mike:~> <strong>file /dev/hda</strong>
/dev/hda: block special (3/0)
</pre><p>
Команда <strong>file</strong> имеет ряд опций, в частности <span class="mono">-z</span>, которая просматривает сжатые файлы. Чтобы получить более детальное описание, посмотрите <strong>info </strong> <span class="monoi"> file</span>. Имейте в виду, что результаты выполнения команды <strong>file</strong> не являются абсолютно достоверными, это только предположение. Другими словами, <strong>file</strong> может ошибиться.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Зачем весь этот шум о типах файлов и форматах?</strong><br />
В ближайшее время мы обсудим пару инструментов командной строки для просмотра текстовых файлов. Эти инструменты не будут работать при использовании «неправильного» типа файла. В худшем случае, они создадут аварийную ситуацию в вашем терминале и/или приведут к возникновению множества звуковых сигналов. Если у вас это случится, просто закройте сеанс терминала и начните новый. Но постарайтесь избегать этого, т.к. обычно это нервирует других людей.</p>
<h2>Создание и удаление файлов и каталогов</h2>
<h3>Создание беспорядка...</h3>
<p>... к этому легко придти. На сегодняшний день практически каждая система работает в сети, поэтому естественно файлы копируются с одного компьютера на другой. Особенно это происходит при работе в графической среде, где создание новых файлов часто происходит без согласия пользователя. Для иллюстрации этой проблемы здесь полное содержимое каталога нового пользователя, созданного на стандартной системе RedHat:</p>
<pre>
[newuser@blob user]$ <strong>ls -al</strong>
total 32
drwx------   3 user 	user        4096 Jan 16 13:32 .
drwxr-xr-x   6 root     root        4096 Jan 16 13:32 ..
-rw-r--r--   1 user 	user      24 Jan 16 13:32 .bash_logout
-rw-r--r--   1 user 	user     191 Jan 16 13:32 .bash_profile
-rw-r--r--   1 user 	user     124 Jan 16 13:32 .bashrc
drwxr-xr-x   3 user 	user    4096 Jan 16 13:32 .kde
-rw-r--r--   1 user 	user    3511 Jan 16 13:32 .screenrc
-rw-------   1 user 	user      61 Jan 16 13:32 .xauthDqztLr
</pre><p>
Также на первый взгляд содержание "используемого" домашнего каталога не выглядит так плохо:</p>
<pre>
olduser:~> <strong>ls</strong>
app-defaults/ crossover/   Fvwm@     mp3/      OpenOffice.org638/
articles/     Desktop/     GNUstep/  Nautilus/ staroffice6.0/
bin/          Desktop1/    images/   nqc/      training/
brol/         desktoptest/ Machines@ ns_imap/  webstart/
C/            Documents/   mail/     nsmail/   xml/
closed/       Emacs@       Mail/     office52/ Xrootenv.0
</pre><p>
Но если учесть все каталоги и файлы, начинающиеся с точки, то в данном каталоге уже обнаруживается 185 объектов. Причина этого в том, что у большинства приложений есть их собственные каталоги и/или файлы в домашнем каталоге этого пользователя, содержащие пользовательские настройки. Как правило, эти файлы создаются при первом запуске приложения. В некоторых случаях вы будете уведомлены, когда несуществующая директория должна быть создана, но по большей части все будет делаться автоматически.</p>
<p>К тому же новые файлы создаются, по-видимому, беспрерывно, потому что пользователи хотят сохранять файлы, хранить различные версии своих работ, использовать интернет-приложения, а также загружать файлы и сопутствующие материалы на их локальный компьютер. Это не остановить. Ясно одно, безусловно потребуются инструменты для сохранения порядка.</p>
<p>В следующем разделе мы обсудим имеющиеся средства для поддержания порядка. Мы только обсуждаем текстовые инструменты доступные в shell, поскольку графические инструменты интуитивны, выглядят и ощущаются также как известный метод «указать-и-щелкнуть» файлового менеджера MS Windows, в том числе графические функции помощи и другие свойства, которые вы ожидаете от такого рода приложений. Ниже приведен обзор наиболее популярных файловых менеджеров для GNU/Linux. Большинство файловых менеджеров могут быть запущены из меню вашей графической среды, щелчком по иконке домашнего каталога или из командной строки с помощью приведенных команд:</p>
<p><noindex></noindex></p>
<ul>
<li><strong>nautilus</strong>. Файловый менеджер Gnome (графической среды GNU) по умолчанию. Отличную документацию о работе с этим инструментом можно найти на http://www.gnome.org.</li>
<li><strong>konqueror</strong>. Файловый менеджер, обычно используемый в графической среде KDE. Пособие есть на http://docs.kde.org.</li>
<li><strong>mc</strong>. Midnight Commander, файловый менеджер Unix по образу Norton Commander. Вся документация доступна на http://gnu.org/directory/  или через зеркало, такое как http://www.ibiblio.org.</li>
</ul>
<p></p>
<p>Несомненно эти приложения стоит попробовать, и они обычно впечатляют новичков Linux даже тем, что существует такой широкий выбор: это только самые популярные инструменты для управления каталогами и файлами, также многие другие проекты находятся в разработке. Теперь давайте выясним, что за всем этим стоит, и посмотрим, как эти графические инструменты используют стандартные команды UNIX.</p>
<h3>Инструменты</h3>
<h4>Создание каталогов</h4>
<p>Способ хранения объектов на своих местах - это помещение определенных файлов в специально для них созданные каталоги и подкаталоги (или, если хотите, папки и подпапки). Это делается с помощью команды <strong>mkdir</strong>:</p>
<pre>
richard:~> <strong>mkdir archive</strong>

richard:~> <strong>ls -ld archive</strong>
drwxrwxrwx  2 richard richard           4096 Jan 13 14:09 archive/
</pre><p>
Создание каталогов и подкаталогов за один шаг делается с помощью опции <span class="mono">-p</span>:</p>
<pre>
richard:~> <strong>cd archive</strong>

richard:~/archive> <strong>mkdir 1999 2000 2001</strong>

richard:~/archive> <strong>ls</strong>
1999/  2000/  2001/

richard:~/archive> <strong>mkdir 2001/reports/Restaurants-Michelin/</strong>
mkdir: cannot create directory `2001/reports/Restaurants-Michelin/':
No such file or directory

richard:~/archive> <strong>mkdir -p 2001/reports/Restaurants-Michelin/</strong>

richard:~/archive> <strong>ls 2001/reports/</strong>
Restaurants-Michelin/
</pre><p>
Если у нового файла должны быть другие права, чем те, что присваиваются по умолчанию при его создании, то новые права доступа могут быть установлены одним движением,  также используя команду <strong>mkdir</strong>, см. страницы info для дополнительной информации. Мы собираемся обсудить режимы доступа в следующем разделе, посвященном безопасности файлов.</p>
<p>Имя каталога должно соответствовать тем же нормам, которые применяются для имен обычных файлов. Одним из наиболее важных ограничений является то, что у вас не может быть двух файлов с одинаковым названием в одном каталоге (но имейте в виду, операционная система Linux, как и UNIX, чувствительна к регистру). В сущности нет никаких ограничений на длину имени файла, но обычно оно содержит меньше, чем 80 символов, т. е. может поместиться в одной строке терминала. Вы можете использовать в имени файла любой символ, который вам захочется, хотя рекомендуется исключить символы, которые имеют специальное значение для оболочки. При сомнении сверьтесь с <a href="http://younglinux.info/#">Приложением C, Особенности Shell.</a></p>
<h4>Перемещение файлов</h4>
<p>Теперь, когда мы должным образом создали структуру в нашем домашнем каталоге, настало время уборки «несекретных» файлов с использованием команды <strong>mv</strong>:</p>
<pre>
richard:~/archive> <strong>mv ../report[1-4].doc reports/Restaurants-Michelin/</strong>
</pre><p>
Эта же команда используется для переименования файлов:</p>
<pre>
richard:~> <strong>ls To_Do</strong>
-rw-rw-r--    1 richard richard      2534 Jan 15 12:39 To_Do

richard:~> <strong>mv To_Do done</strong>

richard:~> <strong>ls -l done</strong>
-rw-rw-r--    1 richard richard      2534 Jan 15 12:39 done
</pre><p>
Очевидно, что изменяется только имя файла. Все остальные свойства остаются неизменными.</p>
<p>Подробные сведения о синтаксисе и особенностях команды <strong>mv</strong> можно найти в man или info-страницах. Использование данной документации должно всегда быть вашим первым рефлексом при столкновении с проблемой. Вероятно ответ на ваш вопрос найдется в системной документации. Даже опытные пользователи читают man-страницы каждый день, поэтому начинающим пользователям следует читать их все время. Через некоторое время, вы узнаете, наиболее распространенные опции к часто используемым командам, но вам все равно будет нужна документация как основной источник информации. Обратите внимание, что информация, содержащаяся в HOWTO, FAQ, man-страницах и других источниках постепенно сливается на страницах info, которые на сегодняшний день являются наиболее современными источниками online-документации (также как и легко доступным в системе).</p>
<h4>Копирование файлов</h4>
<p>Копирование файлов и каталогов осуществляется с помощью команды <strong>cp</strong>. Есть полезная опция рекурсивного копирования (копирования всех файлов и подкаталогов), используйте опцию <span class="mono">-R</span> команды <strong>ср</strong>. Общий синтаксис</p>
<p><span class="mono">cp [-R] fromfile tofile </span></p>
<p>В качестве примера рассмотрим случай пользователя <em>newguy</em>, который захотелось иметь такие же настройки рабочего стола Gnome, какие есть у пользователя <em>oldguy</em>. Одним из способов решения проблемы является копирование настроек <em>oldguy</em> в домашний каталог <em>newguy</em>:</p>
<pre>
victor:~> <strong>cp -R ../oldguy/.gnome/ .</strong>
</pre><p>
Это выдает некоторые ошибки, связанные с разрешением на файлы, но все эти ошибки связаны с личными файлами, в которых <em>newguy</em> в любом случае не нуждается. В следующем разделе мы обсудим, как изменить эти разрешения, если это действительно является проблемой.</p>
<h4>Удаление файлов</h4>
<p>Используйте команду rm для удаления отдельных файлов, <strong>rmdir</strong> для удаления пустых каталогов. (Используйте <strong>ls </strong> <span class="mono"> -a</span> для проверки пуст каталог или нет). Команда <strong>rm</strong> также имеет опции для удаления непустых каталогов со всеми их подкаталогами, но об этих опасных опциях читайте, пожалуй, info-страницы.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Как пустота может быть каталогом? </strong><br />
Это нормально, что каталоги . (точка) и .. (точка-точка) не могут быть удалены, т.к. они также являются необходимыми в пустой директории для определения расположения каталогов в иерархии файловой системы.</p>
<p>В Linux, как и в UNIX, нет мусорных ящиков, по крайней мере, для shell, хотя есть множество решений для графического использования. Так однажды удаленный, файл действительно исчезает, и, как правило, уже нет возможности вернуть его обратно, кроме случаев, когда у вас есть резервные копии, или вы очень быстры и у вас действительно хороший системный администратор. Чтобы защитить начинающих пользователей от этой напасти, интерактивное поведение команд <strong>rm, cp</strong> и <strong>mv</strong> может быть запущено с помощью опции <span class="mono">-i</span>. В этом случае система не будет сразу действовать после запроса. Вместо этого, появится запрос на подтверждение, что потребует дополнительного нажатия клавиши Enter для причинения вреда:</p>
<pre>
mary:~> <strong>rm -ri archive/</strong>
rm: descend into directory `archive'? y
rm: descend into directory `archive/reports'? y
rm: remove directory `archive/reports'? y
rm: descend into directory `archive/backup'? y
rm: remove `archive/backup/sysbup200112.tar'? y
rm: remove directory `archive/backup'? y
rm: remove directory `archive'? Y
</pre><p>
Мы обсудим, как сделать это опцией по умолчанию в <a href="http://younglinux.info/#">Главе 7, «Дом сладкий /home»</a>, в которой обсуждается настройка окружения вашей оболочки.</p>
<h2>Поиск файлов</h2>
<h3>Использование возможностей shell</h3>
<p>В приведенном ранее примере перемещения файлов мы уже видели, как shell может манипулировать сразу несколькими файлами. В том примере оболочка автоматически понимает, что пользователь имел ввиду требованием между квадратными скобками "[" и "]". Оболочка может заменить диапазоны номеров, а также прописных или строчных буквы. Она также заменяет звездочку на любое количество символов и знак вопроса на любой один.</p>
<p>Все виды замещения могут быть использованы одновременно; оболочка очень последовательна в этом. Оболочка Bash, например, не имеет никаких проблем с такими выражениями как <strong>ls </strong> <span class="monoi"> dirname/*/*/*[2-3]</span>.</p>
<p>В других оболочках, звездочка обычно используется, чтобы свести к минимуму усилия ввода: можно ввести <strong>cd</strong> <span class="monoi"> dir*</span> вместо <strong>cd</strong> <span class="monoi"> directory</span>. В Bash однако, это не является необходимым, поскольку у оболочки GNU есть свойство, называемое автозавершением имени файла. Это означает, что вы можете набрать первые несколько символов команды или файла (в текущем каталоге), и если никакой путаницы не может быть, оболочка поймет, что вы имеете в виду. Например, в каталоге, содержащем много файлов, вы можете проверить, если ли какие-нибудь файлы, начинающиеся с буквы A просто набрав <strong>ls</strong> <span class="mono">A</span> и нажать клавишу <strong>Tab</strong> дважды, вместо нажатия <strong>Enter</strong>. Если только один файл начинается с "А", то этот файл немедленно отобразится в качестве аргумента <strong>ls</strong> (или любой другой команды оболочки, если на то пошло).</p>
<h3>Which</h3>
<p>Самый простой способ просматривать файлы — это использование команды <strong>which</strong> для посмотра в каталогах, перечисленных в пути поиска пользователя на требуемый файл. Конечно, путь поиска содержит только пути к каталогам, содержащим исполняемые программы, которые не работают для обычных файлов. Команда <strong>which</strong> полезна при выяснении причины возникновения проблемы "Команда не найдена" ("Command not Found"). В приведенном ниже примере пользователь <em>tina</em> не может использовать программу <strong>acroread</strong>, а ее коллега не испытывает никаких проблем на той же системе. Эта проблема аналогична проблеме <span class="mono">PATH</span> из предыдущей части: коллега <em>tina</em> сказал ей, что он может увидеть нужную программу в <span class="mono">/opt/acroread/bin</span>, но этого каталога нет в ее path:</p>
<pre>
tina:~> <strong>which acroread</strong>
/usr/bin/which: no acroread in (/bin:/usr/bin:/usr/bin/X11
</pre><p>
Проблема может быть решена путем предоставления полного пути к команде запуска, или нужно заново экспортировать содержание переменной PATH:</p>
<pre>
tina:~> <strong>export PATH=$PATH:/opt/acroread/bin</strong>

tina:~> <strong>echo $PATH</strong>
/bin:/usr/bin:/usr/bin/X11:/opt/acroread/bin
</pre><p>
Используя команду <strong>which</strong> также можно проверить, является ли команда  псевдонимом другой команды:</p>
<pre>
gerrit:~> <strong>which -a ls</strong>
ls is aliased to `ls -F --color=auto'
ls is /bin/ls
</pre><p>
Если это не сработает в вашей системе, используйте псевдоним команды:</p>
<pre>
tille@www:~/mail$ <strong>alias ls</strong>
alias ls='ls —color'
</pre><h3>Find и locate </h3>
<p>Кроме перечисления в path, есть инструменты, специально предназначенные для поиска. Есть очень мощный инструмент <strong>find</strong>, известный из UNIX, который можно расценить, как имеющий достаточно трудный синтаксис. GNU <strong>find</strong>, однако, имеет дело с синтаксическими проблемами. Эта команда позволяет не только вести поиск имен файлов, она также может принимать размер файла, дату последнего изменения и другие свойства файла в качестве критериев для поиска. Наиболее часто используется поиск файлов по именам:<br />
<div class="geshifilter"><pre class="python geshifilter-python" style="font-family:monospace;">find <span style="color: #66cc66;">&lt;</span>path<span style="color: #66cc66;">&gt;</span> -name <span style="color: #66cc66;">&lt;</span>searchstring<span style="color: #66cc66;">&gt;</span></pre></div></p>
<p>Это может быть истолковано как "Просмотреть все файлы и подкаталоги, содержащихся в заданном пути, и выдать имена файлов, содержащих строку поиска в их имени" (но не в содержании).</p>
<p>Другое применение <strong>find</strong> поиск файлов по определенному размеру, как и в примере ниже, где пользователь <em>peter</em> хочет найти все файлы в текущей директории или одном из ее подкаталогов, которые больше 5 MB:</p>
<pre>
peter:~> <strong>find . -size +5000k</strong>
psychotic_chaos.mp3
</pre><p>
Если вы покопаетесь в man-страницах, то увидите, что <strong>find</strong> также может совершать действия над найденными файлами. Типичным примером является удаление файлов. Лучше всего первый тест совершить без опции <span class="mono">-exec</span>, когда нужные файлы отобраны, после чего команда может быть повторно запущена для удаления выбранных файлов. Ниже, мы ищем файлы с расширением <span class="mono">.tmp</span>:</p>
<pre>
peter:~> <strong>find . -name "*.tmp" -exec rm {} \;</strong>

peter:~>
</pre><p class="note"><img src="../../../img/linuxintro/tip.gif" alt="" /><strong>  Оптимизация!</strong><br />
Эта команда будет вызывать <strong>rm</strong> так много раз, сколько подходящих к требованию файлов найдется. В худшем случае, это может быть тысячи или миллионы раз. Это довольно сильно загрузит вашу систему.<br />
Более реалистичным подходом к работе будет использование канала (|) и инструмента <strong>xargs</strong> с командой <strong>rm</strong> в качестве аргумента. Таким образом, команда <strong>rm</strong> вызывается только, когда командная строка заполнена, а не для каждого файла. См. <a href="http://younglinux.info/#">Главу 5, «Перенаправление ввода/вывода (I/O)»</a> для дополнительной информации об использовании I/O перенаправления для облегчения повседневных задач.</p>
<p>Позднее (в 1999 году в след за man-страницами, после 20 лет существования <strong>find</strong>), была разработана <strong>locate</strong>. Эта программа проще в использовании, но более ограничена, чем <strong>find</strong>, т.к. ее выдача основана на базе данных файловых индексов, который обновляется только раз в день. С другой стороны, поиск в базе данных <strong>locate</strong> использует меньше ресурсов, чем <strong>find</strong> и, следовательно, показывает результаты практически мгновенно.</p>
<p>В наши дни большинство дистрибутивов Linux используют <strong>slocate</strong> (поиск снабженный безопасностью), современная версия <strong>locate</strong> позволяет пользователям получать выдачу, которую они не имеют права читать. Так, например, файлы из домашнего каталога root, обычно не доступны для публичного просмотра. Пользователь, который хочет найти того, кто знает об оболочке C, может задать команду <strong>locate </strong> <span class="mono"> .cshrc</span>, для просмотра всех пользователей, у которых конфигурационный файл настроен на оболочку C. Если предположить, что пользователи <em>root</em> и <em>jenny</em> находятся под управлением оболочки C, то только файл <span class="mono"> /home/jenny/.cshrc</span> будет отображен, и не один из домашней директории <em>root</em>. На большинстве систем, <strong>locate</strong> является символической ссылкой на программу <strong>slocate</strong>:</p>
<pre>
billy:~> <strong>ls -l /usr/bin/locate</strong>
lrwxrwxrwx 1 root slocate  7 Oct 28 14:18 /usr/bin/locate -> slocate*
</pre><p>
Пользователь <em>tina</em> могла бы использоваться <strong>locate</strong>, чтобы найти необходимое приложение:</p>
<pre>
tina:~> <strong>locate acroread</strong>
/usr/share/icons/hicolor/16x16/apps/acroread.png
/usr/share/icons/hicolor/32x32/apps/acroread.png
/usr/share/icons/locolor/16x16/apps/acroread.png
/usr/share/icons/locolor/32x32/apps/acroread.png
/usr/local/bin/acroread
/usr/local/Acrobat4/Reader/intellinux/bin/acroread
/usr/local/Acrobat4/bin/acroread
</pre><p>
Каталоги, которые не содержат имя <span class="mono">bin</span><br />
, не могут содержать программы - они не содержат исполняемые файлы. Есть три возможности. Файл в <span class="mono">/usr/local/bin </span><br />
и есть то, что хотела бы <em>tina</em>: это ссылка на shell-скрипт, который  запускает настоящую программу:</p>
<pre>
tina:~> <strong>file /usr/local/bin/acroread</strong>
/usr/local/bin/acroread: symbolic link to ../Acrobat4/bin/acroread

tina:~> <strong>file /usr/local/Acrobat4/bin/acroread</strong>
/usr/local/Acrobat4/bin/acroread: Bourne shell script text executable

tina:~> <strong>file /usr/local/Acrobat4/Reader/intellinux/bin/acroread</strong>
/usr/local/Acrobat4/Reader/intellinux/bin/acroread: ELF 32-bit LSB 
executable, Intel 80386, version 1, dynamically linked (uses 
shared libs), not stripped
</pre><p>
Для того, чтобы сохранить путь как можно короче, и системе не приходилось искать слишком долго каждый раз, когда пользователь хочет выполнить команду, мы добавляем <span class="mono">/usr/local/bin</span><br />
 к пути, а не другие каталоги, которые содержат только двоичные файлы одной конкретной программы, также <span class="mono">/usr/local/bin</span> содержит другие полезные программы.</p>
<p>Опять же, полное описание возможностей <strong>find</strong> и <strong>locate</strong> можно найти на страницах info.</p>
<h3>Команда grep</h3>
<h4>Общая строка фильтрации</h4>
<p>Простая, но мощная программа <strong>grep</strong> используется для фильтрации входных строк и выдачи подходящих к образцу на вывод. Существуют буквально тысячи применений для  программы <strong>grep</strong>. В приведенном ниже примере, <em>jerry</em> использует <strong>grep</strong>, чтобы посмотреть, что он делал с <strong>find</strong>:</p>
<pre>
jerry:~> <strong>grep -a find .bash_history</strong>
find . -name userinfo
man find
find ../ -name common.cfg
</pre><p class="note"><img src="../../../img/linuxintro/tip.gif" alt="" /><strong>  История поиска.</strong><br />
Также полезна в этих случаях функция поиска в <strong>bash</strong>, которая сразу же запускается нажатием <strong>Ctrl + R</strong>, как в примере, где мы хотим проверить  еще раз, что мы делали в прошлом с командой <strong>find</strong>:</p>
<pre>
thomas ~> <strong>^R</strong> 
(reverse-i-search)`find': find `/home/thomas` -name *.xml
</pre><p>
Введите строку поиска для начала поиска. Чем больше символов вы вводите, тем более ограниченный поиск получаете. Здесь читается история команды для этой сессии оболочки (которая записывается в <span class="mono">.bash_history</span> в вашем домашнем каталоге при выходе из той сессии). Показывается самый последний случай строки вашего поиска. Если вы хотите увидеть предыдущие команды, содержащие ту же строку, нажмите <strong>Ctrl + R</strong> опять.</p>
<p>Чтобы узнать больше, изучайте info-страницы в <strong>bash</strong>.</p>
<p>Все ОС Unix имеют он-лайн словарь. Так же и Linux. Словарь представляет собой список известных слов в файле под названием <span class="mono">words</span>, расположенный в <span class="mono">/usr/share/dict</span>. Чтобы быстро проверить правильность написания слова, не графическое приложение, необходимо:</p>
<pre>
william:~> <strong>grep pinguin /usr/share/dict/words</strong>

william:~> <strong>grep penguin /usr/share/dict/words</strong>
penguin
penguins
</pre><p class="note"><img src="../../../img/linuxintro/tip.gif" alt="" /><strong>   Словарь против списка слов.</strong><br />
Некоторые дистрибутивы предлагают команду <strong>dict</strong>, которая предоставляет больше функций, чем просто поиск слов в списке.</p>
<p>Кто является владельцем того домашнего каталога рядом со мной? Эй, есть его номер телефона!</p>
<pre>
lisa:~> <strong>grep gdbruyne /etc/passwd</strong>
gdbruyne:x:981:981:Guy Debruyne, tel 203234:/home/gdbruyne:/bin/bash
</pre><p>
И какой был адрес электронной почты Arno также?</p>
<pre>
serge:~/mail> <strong>grep -i arno *</strong>
sent-mail: To: <Arno.Hintjens@celeb.com>
sent-mail: On Mon, 24 Dec 2001, Arno.Hintjens@celeb.com wrote:
</arno.hintjens@celeb.com></pre><p>
<strong>find</strong> и <strong>locate</strong> часто используются в сочетании с grep для решения некоторых  важных задач. Для получения дополнительной информации см. <a href="http://younglinux.info/#">Главу 5, «Перенаправление ввода/вывода (I/O)»</a>.</p>
<h4>Специальные символы</h4>
<p>Символы, имеющие специальное значение для оболочки должны быть <em>экранированы</em>. Символом экранирования в Bash является обратная косая черта, как и в большинстве оболочек; она придает специальное значение последующему символу. Оболочка знает о многих специальных символов, к числу наиболее распространенных относятся /,.,? и *. Полный список можно найти на info-страницах и документации к вашей оболочке.<br />
Так, например, чтобы сказать, что вы хотите отобразить файл «*» вместо всех файлов в каталоге, вам придется использовать</p>
<p><span class="mono">less \*</span></p>
<p>То же самое касается имен файлов, содержащих пробел:</p>
<p><span class="mono">cat This\ File</span></p>
<h2>Другие способы просмотра содержимого файла</h2>
<h3>Общее</h3>
<p>Кроме <strong>cat</strong>, который действительно не делать больше, чем передача файлов на стандартный вывод, есть другие инструменты для просмотра содержимого файла.</p>
<p>Самый простой способ, конечно, будет заключаться в использовании графических инструментов вместо инструментов командной строки. Во введении мы уже мельком видели офисное приложение OpenOffice.org. Другие примеры GIMP (запускается командой <strong>gimp</strong> из командной строки), GNU программа обработки изображений; <strong>xpdf</strong> для просмотра файлов формата Portable Document (PDF); GhostView (<strong>gv</strong>) для просмотра файлов PostScript; браузер Mozilla/FireFox, Konqueror, Opera и многое другое для веб-контента; XMMS, CDplay и других для мультимедийных файлов, AbiWord, Gnumeric, KOffice и т.д. для всех видов офисных приложениях и т.д. Есть тысячи приложений Linux; перечисление их всех заняло бы дни.</p>
<p>Вместо этого мы продолжим сосредотачиваться на приложениях текстового режима, которые создают основу для всех других приложений. Эти команды работают лучше всего в текстовом окружении для файлов, содержащих текст. В случае сомнений, сначала проверьте с помощью команды <strong>file</strong>.</p>
<p>Итак, давайте посмотрим, какие текстовые инструменты у нас есть, которые полезны, для просмотра содержимого файлов.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Проблемы шрифта.</strong><br />
Инструменты для простого (плоского) текста, такие как те, что мы сейчас будем обсуждать, часто имеют проблемы с "плоскими" текстовыми файлами из-за кодировок шрифта, используемых в этих файлах. Специальные символы, такие как "акцентированные" буквы алфавита, китайские иероглифы и другие символы языков, использующих различные наборы символов, а не по умолчанию en_US кодировку и так далее, будут отображаться неправильно или будут заменены нечитаемым мусором. Эти проблемы обсуждаются в <a href="http://younglinux.info/#">Разделе 7.4. "Региональные специфические настройки"</a>.</p>
<h3>Меньше (less) значит больше</h3>
<p>Несомненно рано или поздно вы услышите как кто-то скажет эту фразу при работе в среде UNIX. Немного истории UNIX объяснит это:</p>
<ul>
<li>Сначала была <strong>cat</strong>. Поток вывода был неконтролируемым.</li>
<li>Потом была <strong>pg</strong>, которую все еще можно обнаружить на старых версиях Unix. Эта команда выдает текст на вывод по одной странице за раз.</li>
<li>Программа <strong>more</strong> подправленный вариант <strong>pg</strong>. Эта команда по-прежнему есть в каждой системе Linux.</li>
<li><strong>less</strong> GNU версия <strong>more</strong> и включает дополнительные функции, позволяющие подсвечивать строки поиска, прокрутку назад  и т.д. Синтаксис очень прост:</li>
</ul>
<p><span class="mono">less name_of_file</span></p>
<p>Более подробная информация находится на info-страницах.</p>
<p>К настоящему времени вы уже знаете о пейджерах, поскольку они используются для просмотра man-страниц.</p>
<h3>Команды head и tail</h3>
<p>Эти две команды отображают соответственно n первых/последних строк файла. Чтобы посмотреть последние десять команд ввели следующее:</p>
<pre>
tony:~> <strong>tail -10 .bash_history</strong> 
locate configure | grep bin
man bash
cd
xawtv &
grep usable /usr/share/dict/words 
grep advisable /usr/share/dict/words 
info quota
man quota
echo $PATH
frm
</pre><p>
<strong>head</strong> работает аналогично. У команды <strong>tail</strong> есть удобная функция, постоянно показывающая последние n строк файла, которые меняются все время. Это опция <span class="mono">-f</span>, которая часто используется системными администраторами для проверки файлов журналов. Более подробная информация находится в файлах системной документации.</p>
<h2>Связывание файлов</h2>
<h3>Типы ссылок</h3>
<p>Поскольку мы уже знаем достаточно о файлах и их представлении в файловой системе, понимание ссылок (или ярлыков) добавит составляющую в общую картину. Ссылка — это не более чем способ сопоставления двух или более имен файлов с одним и тем же  набором данных. Есть два пути достижения этой цели:</p>
<ul>
<li>Жесткая ссылка: Связывает два или более имени файла с одним и тем же индексным дескриптором. Жесткие ссылки определяют одни и те же блоки данных на жестком диске, в то время они продолжают вести себя как независимые файлы.</li>
</ul>
<p>Существует очевидное неудобство: жесткие ссылки не могут распространяться на разделы, т.к. номера индексных дескрипторов уникальны только в пределах данного раздела.</p>
<ul>
<li>Мягкая или символическая (символьная) ссылка (или для краткости: symlink - симлинк): маленький файл, который является указателем на другой файл. Символическая ссылка содержит путь к целевому файлу, а не указание на физическое расположение данных на жестком диске. Поскольку в данном механизме не задействованы индексные дескрипторы, мягкие ссылки могут существовать между разными разделами.</li>
</ul>
<p>Поведение этих двух типов ссылок похожее, но не одинаковое, что проиллюстрировано на схеме ниже:</p>
<p><strong>Рисунок 3.2. Механизм жестких и мягких ссылок</strong></p>
<div style="text-align:center;"><img src="../../../img/linuxintro/links.png" width="295" height="401" alt="Механизм жестких и мягких ссылок в Linux" /></div>
<p>Обратите внимание, что удаление целевого файла для символьной ссылки делает ссылку бесполезной.</p>
<p>Каждый обычный файл, в принципе, - жесткая ссылка. Жесткие ссылки файла не простираются на все разделы, так как они отсылают к индексным дескрипторам, а номера ID уникальны только в пределах данного раздела.</p>
<p>Можно утверждать, что существует третий вид ссылок, <em>user-space</em> ссылки, которые похожи на ярлык в MS Windows. Это файлы, содержащие метаданные, которые могут быть интерпретированы только графическим файловым менеджером. Для ядра и оболочки это просто обычные файлы. У них может быть в конце суффикс  <em>.desktop</em> или <em>.lnk</em>; например, можно найти <span class="mono">~/.gnome-desktop</span>:</p>
<pre>
[dupont@boulot .gnome-desktop]$ <strong>cat La\ Maison\ Dupont</strong>
[Desktop Entry]
Encoding=Legacy-Mixed
Name=La Maison Dupont
Type=X-nautilus-home
X-Nautilus-Icon=temp-home
URL=file:///home/dupont
</pre><p>Этот пример взят из графической среды KDE:</p>
<pre>
[lena@venus Desktop]$ <strong>cat camera</strong>
[Desktop Entry]
Dev=/dev/sda1
FSType=auto
Icon=memory
MountPoint=/mnt/camera
Type=FSDevice
X-KDE-Dynamic-Device=true
</pre><p>
Создать такого рода ссылку достаточно легко путем использования особенностей вашей графической среды. Если вам нужна помощь, то системная документация должна быть вашим первым источником.</p>
<p>В следующем разделе мы рассмотрим создание символических ссылок в UNIX-стиле с помощью командной строки.</p>
<h3>Создание символических ссылок</h3>
<p>Символическая ссылка представляет особый интерес для начинающих пользователей: они достаточно очевидны для понимания и вам не нужно беспокоиться о разделах.</p>
<p>Команды для создания ссылок является <strong>ln</strong>. Для того чтобы создать символические ссылки, следует использовать опцию <span class="mono">-s</span>:</p>
<p><span class="mono">ln -s targetfile linkname</span></p>
<p>В приведенном ниже примере пользователь <em>freddy</em> создает ссылку в подкаталоге своей домашней папки на каталог другой части системы:</p>
<pre>
freddy:~/music> <strong>ln -s /opt/mp3/Queen/ Queen</strong>

freddy:~/music> <strong>ls -l</strong>
lrwxrwxrwx  1 freddy  freddy  17 Jan 22 11:07 Queen -> /opt/mp3/Queen
</pre><p>
Символические ссылки всегда очень маленькие файлы, в то время как жесткие ссылки имеют те же размеры, что и исходный файл.</p>
<p>Применение символических ссылок имеет широкое распространение. Они часто используются для экономии дискового пространства за счет создания «копии» файла для удовлетворения требований при установке новой программы, которая ожидает наличие файла в другом месте; они используются для исправления сценариев, которые внезапно запускаются в новых окружениях, в общем могут предотвратить большие затраты. Системный администратор может принять решение перенести домашние каталоги пользователей на новое место, <span class="mono">disk2</span> например, но если он хочет, чтобы все работало, как раньше, в том числе файл <span class="mono">/etc/passwd</span>, с минимумом усилий он создаст символическую ссылку из <span class="mono">/home</span> на новое место <span class="mono">/disk2/home</span>.</p>
  </div>
<div id="node-204" class="section-3">
  <h1 class="book-heading">Защита файлов</h1>
  <h2>Права доступа: первая линия обороны Linux</h2>
<p>Модель безопасности Linux основана на той, которая используется в системах UNIX, и является такой же строгой (и иногда даже более). В системе Linux каждый файл принадлежит пользователю и группе пользователей. Есть также третья категория пользователей, которые не являются пользователем-владелецем и не принадлежат группе, владеющей файлом. Для каждой категории пользователей, разрешение на чтение, запись и выполнение может быть предоставлено или отклонено.</p>
<p>Мы уже использовали "длинный" вариант просмотра файлов с помощью команды <strong>ls </strong> <span class="mono"> -l</span>, хотя и по другим причинам. Эта команда также отображает разрешения файла (права доступа) для этих трех категорий пользователей; они указаны девятью символами, которые следуют за первым символом (индикатором типа файла). Как видно из приведенных ниже примеров, первые три символа из этой серии девяти отображают права доступа реального пользователя, который является владельцем файла. Следующие три — предназначены для группы-владельца файла, последние три — для других пользователей. Разрешения всегда описываются в одном и том же порядке: чтение, запись и исполнение (выполнение, запуск) для пользователя, группы и других. Вот некоторые примеры:</p>
<pre>
marise:~> <strong>ls -l To_Do</strong>
-rw-rw-r--    1 marise  users      5 Jan 15 12:39 To_Do
marise:~> <strong>ls -l /bin/ls</strong>
-rwxr-xr-x    1 root    root   45948 Aug  9 15:01 /bin/ls*
</pre><p>
Первый файл является обычным (вначале прочерк). Пользователь с именем <em>marise</em> или пользователи, принадлежащие к группе <em>users</em>, могут читать и переписывать (изменять/перемещать/удалять) файл, но они не могут исполнять его (второе и третье тире). Другим пользователям разрешено только читать этот файл, но они не могут изменять или выполнять его (четвертое и пятое тире).</p>
<p>Второй пример — это исполняемый файл; отличие: все могут запустить данную программу, но вам нужно быть суперпользователем, чтобы изменить его.</p>
<p>Info-страницы подробно объясняют, каким образом команда <strong>ls</strong> управляет отображением прав доступа (см. в разделе <em>What information is listed</em>).</p>
<p>Для удобства работы с командами, как права доступа (или режимы), так и категории пользователей имеют коды. См. таблицы ниже.</p>
<p><strong>Таблица 3.7. Коды режимов доступа</strong></p>
<table class="il">
<tr>
<td width="100"><strong>Код</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td>0 или -</td>
<td>Права доступа, которые должны были прописаны в данном месте, не предоставляются.</td>
</tr>
<tr>
<td>4 или r</td>
<td>Предоставляется право на чтение для определенной категории пользователей.</td>
</tr>
<tr>
<td>2 или w</td>
<td>Право на запись для категории пользователей, определенных в данном месте.</td>
</tr>
<tr>
<td>1 или x</td>
<td>Право на выполнение для определенной категории пользователей.</td>
</tr>
</table>
<p><strong>Таблица 3.8. Коды группы пользователей</strong></p>
<table class="il">
<tr>
<td width="100"><strong>Код</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td>u</td>
<td>Права пользователя</td>
</tr>
<tr>
<td>g</td>
<td>Права группы</td>
</tr>
<tr>
<td>o</td>
<td>Права для остальных</td>
</tr>
</table>
<p>Использование данного механизма разделения прав обязательно; это позволяет обеспечить высокий уровень безопасности даже без сетевой защиты. Среди прочих функций такая схема безопасности заботится о доступе пользователей к программам, <span style="background-color:yellow;">it can serve files on a need-to-know basis</span> и защищает конфиденциальные данные, такие как домашние каталоги и системные конфигурационные файлы.</p>
<p>Вы должны знать ваше имя пользователя. Если вы не знаете, то его можно отобразить, используя команду <strong>id</strong>, которая также отображает группу по умолчанию, к которой вы принадлежите и, в конечном итоге, другие группы, членом которых вы являетесь:</p>
<pre>
tilly:~> <strong>id</strong>
uid=504(tilly) gid=504(tilly) groups=504(tilly),100(users),2051(org)
Ваше имя пользователя, также хранится в переменной окружения USER:
tilly:~> <strong>echo $USER</strong>
tilly
</pre><h2>Инструменты</h2>
<h3>Команда chmod</h3>
<p>Обычным следствием применения строгих правил доступа к файлам, а иногда и неудобством, является то, что права доступа должны быть изменены по тем или иным причинам. Чтобы это сделать, мы используем команду <strong>chmod</strong>, что привело  к тому, что <em>chmod</em> стал почти приемлемым английским глаголом, обозначающим  изменение режима доступа к файлу. Команда <strong>chmod</strong> может быть использована с буквенными и числовыми опциями, что вам больше всего нравится.</p>
<p>В приведенном ниже примере используются буквенные параметры для решения  проблемы, с которой обычно сталкиваются начинающие пользователи:</p>
<pre>
asim:~> <strong>./hello</strong>
bash: ./hello: bad interpreter: Permission denied

asim:~> <strong>cat hello</strong>
#!/bin/bash
echo "Hello, World"

asim:~> <strong>ls -l hello</strong>
-rw-rw-r--    1 asim    asim    32 Jan 15 16:29 hello

asim:~> <strong>chmod u+x hello</strong>

asim:~> <strong>./hello</strong>
Hello, World

asim:~> <strong>ls -l hello</strong>
-rwxrw-r--   1 asim    asim    32 Jan 15 16:29 hello*
</pre><p>
+ и - используются для разрешения или запрещения конкретного права для определенной категории. Комбинации через запятую не допускаются. Info и man-страницы содержат полезные примеры. Здесь еще один, в котором файл из предыдущего примера становится личным файлом пользователя <em>asim</em>:</p>
<pre>
asim:~> <strong>chmod u+rwx,go-rwx hello</strong>

asim:~> <strong>ls -l hello</strong>
-rwx------    1 asim    asim    32 Jan 15 16:29 hello*
</pre><p>
Ситуации, в которых появляются сообщения об ошибках, говорящих, что допуск запрещен, как правило, связаны с проблемой прав доступа. Также, реплики вроде: "Это работало вчера" и "Когда я запускаю это как <em>root</em>, то оно работает", скорее всего, вызваны тем, что не были учтены права доступа к файлам.</p>
<p>При использовании <strong>chmod</strong> с цифровыми аргументами, значения для каждого предоставляемого права доступа указываются в "месторасположение" категории. Таким образом, получается трехзначное число, которое представляет собой символическое обозначение того, что должна сделать команда <strong>chmod</strong>. В следующей таблице перечислены наиболее распространенные комбинации.</p>
<p><strong>Таблица 3.9. Защита файлов с помощью chmod</strong></p>
<table class="il">
<tr>
<td width="200"><strong>Код</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> 400 file</span></td>
<td>Защита файла от случайной перезаписи</td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> 500 directory</span></td>
<td>Чтобы защитить себя от случайного удаления, переименования или перемещения файлов из этой директории.</td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> 600 file</span></td>
<td>Личный файл, изменяемый только пользователем, который ввел эту команду.</td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> 644 file</span></td>
<td>Всеми читаемый файл, который может быть изменен только  пользователем-владельцем.</td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> 660 file</span></td>
<td>Пользователи, принадлежащие вашей группе, могут изменить этот файл, другие не имеют никакого отношения к нему вообще.</td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> 700 file</span></td>
<td>Защищает файл от любого доступа посторонних, в то же время пользователь-владелец имеет полный контроль.</td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> 755 directory</span></td>
<td>Для файлов, которые должны быть читаемыми и исполняемыми всеми, но изменяемые только пользователем-владельцем.</td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> 775 file</span></td>
<td>Стандартный режим совместного использования файла  группой.</td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> 777 file</span></td>
<td>Каждый может делать с этим файлом все, что хочет.</td>
</tr>
</table>
<p>Если в качестве аргумента <strong>chmod</strong> вы вводите число, состоящее менее чем из трех цифр, опущенные символы заменяются на нули, начиная слева. В системах Linux на самом деле существует четвертая цифра, которая предшествует первому из трех и устанавливает специальные режимы доступа. Все об этом и многом другом находится в info-страницах.</p>
<h3>Вступление в другую группу</h3>
<p>Когда вы введете <strong>id</strong> в командной строке, то получите список всех групп, к которым  вы можете принадлежать; перед этим будет ваше имя пользователя и ID, а также название группы и ее ID, с которой вы в настоящее время связаны. Однако, во многих системах Linux можно активно входить только в одну группу в одно и то же время. По умолчанию, это активная или первичная группа является первой, которая вам устанавливается из файла <span class="mono">/etc/passwd</span>. Четвертое поле в этом файле содержит ID основной группы пользователей, что можно также увидеть в файле <span class="mono">/etc/group</span>. Например:</p>
<pre>
asim:~> <strong>id</strong>
uid=501(asim) gid=501(asim) groups=100(users),501(asim),3400(web)

asim:~> <strong>grep asim /etc/passwd</strong>
asim:x:501:501:Asim El Baraka:/home/asim:/bin/bash

asim:~> <strong>grep 501 /etc/group</strong>
asim:x:501:
</pre><p>
В приведенном выше примере четвертое поле в строке из <span class="mono">/etc/passwd</span> содержит значение "501", которое представляет собой группу asim. Из <span class="mono">/etc/group</span> мы можем получить имя, соответствующие этому идентификатору группы. При первом подключении к системе, это та группа, к которой будет принадлежать <em>asim</em>.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>"Механизм" индивидуальной группы пользователя. </strong><br />
В целях обеспечения большей гибкости, большинство систем Linux преследуют так называемую индивидуальную групповую схему пользователей, которая, в первую очередь, присваивает каждому пользователю его собственную группу. Этой группе принадлежит только данный пользователь, отсюда и название "личная группа". Обычно эта группа имеет такое же имя как название логина пользователя, что может приводить к небольшой путанице.</p>
<p>Помимо своей собственной группы, пользователь <em>asim</em> также может быть в группах <em>users</em> и <em>web</em>. Т.к. это вторые группы для данного пользователя, ему придется использовать команду <strong>newgrp</strong>, чтобы войти в любую из этих групп (сначала используйте <strong>gpasswd</strong> для установки пароля для группы). В этом примере asim необходимо создать файлы, которые принадлежат группе <em>web</em>.</p>
<pre>
asim:/var/www/html> <strong>newgrp web</strong>

asim:/var/www/html> <strong>id</strong>
uid=501(asim) gid=3400(web) groups=100(users),501(asim),3400(web)
</pre><p>
Теперь, когда <em>asim</em> создает новые файлы, они будут находиться в собственности группы <em>web</em>, вместо того, чтобы принадлежать группе <em>asim</em>:</p>
<pre>
asim:/var/www/html> <strong>touch test</strong>

asim:/var/www/html> <strong>ls -l test</strong>
-rw-rw-r--  1 asim web   0 Jun 10 15:38 test
</pre><p>
Вход в новую группу освобождает вас от необходимости использовать chown (см. <a href="http://younglinux.info/#">Раздел "Смена владельцев и групп"</a>) или вызывать системного администратора для смены владельцев для вас.</p>
<p>См. man-страницу для <strong>newgrp</strong> для получения дополнительной информации.</p>
<h3>Маска файла</h3>
<p>Прежде чем новый файл куда-то сохраняется, он подвергаться стандартной процедуре защиты. В Linux не существуют файлы без установленных прав доступа. Стандартное разрешение на файл определяется маской при его создании. Значение этой маски может быть получено с помощью команды <strong>umask</strong>:</p>
<pre>
bert:~> umask
0002
</pre><p>
Вместо добавления символических значений друг к другу, как с <strong>chmod</strong>, для выяснения разрешения на новый файл, необходимо вычесть из суммарной возможности прав доступа. Однако в примере выше мы видим четыре значения, но есть только три категории разрешений: для пользователя, группы и других. Первый ноль — это установленные специальные файловые атрибуты, которые мы будем обсуждать в <a href="http://younglinux.info/#">Разделе "Смена владельцев и групп"</a> и в <a href="http://younglinux.info/#">Разделе "SUID и SGID"</a>. Возможно, с тем же успехом, в вашей системе этот первый ноль не отображается при вводе команды <strong>umask</strong>, и тогда вы видите только три числа, представляющих маску по умолчанию, «накладываемую» на файл.</p>
<p>Каждая UNIX-подобная система имеет системную функцию для создания новых файлов, которая вызывается каждый раз, когда пользователь использует программу, которая создает новые файлы, например, при загрузке файлов из Интернета, при сохранении нового текстового документа и т.д. Эта функция создает как новые файлы, так и директории. Полные права на чтение, запись и выполнение предоставляются всем при создании нового каталога. При создании нового файла, эта функция создаст право на чтение и запись для всех, но прав на выполнение отсутствует для всех категорий пользователей. Таким образом, первоначально применяется маска для каталога с разрешением <em>777</em> или <em>rwxrwxrwx</em>, а для обычного файла <em>666</em> или <em>rw-rw-rw-</em>.</p>
<p>Значение <strong>umask</strong> вычитается из этих разрешений по умолчанию, определенных инструментом, создающим новый файл или каталог. Таким образом, каталог будет иметь права доступа <em>775</em> по умолчанию, а файл <em>664</em>, если значение маски <em>(0)002</em>. Это демонстрируется на примере ниже:</p>
<pre>
bert:~> <strong>mkdir newdir</strong>

bert:~> <strong>ls -ld newdir</strong>
drwxrwxr-x    2 bert    bert		4096 Feb 28 13:45 newdir/

bert:~> <strong>touch newfile</strong>

bert:~> <strong>ls -l newfile</strong>
-rw-rw-r--    1 bert    bert		   0 Feb 28 13:52 newfile
</pre><p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Файлы по сравнению с каталогами. </strong><br />
Каталог получает больше разрешений по умолчанию: он всегда имеет разрешение на выполнение. Если бы не это, они не были бы доступны. Исследуйте это, изменив режим доступа к каталогу на 644!</p>
<p>Если вы войдете в другую группу, используя команду <strong>newgrp</strong>, маска остается неизменной. Таким образом, если она установлена на <em>002</em>, файлы и каталоги, которые вы создаете, находясь в новой группе, также будут доступны для других членов этой группы; вам не придется использовать команду <strong>chmod</strong>.</p>
<p>Пользователь <em>root</em> обычно имеет более строгую маску по умолчанию:</p>
<pre>
[root@estoban root]# <strong>umask</strong>
022
</pre><p>
Эти значения по умолчанию — общесистемная установка в конфигурационном файле shell, например <span class="mono">/etc/bashrc</span> или <span class="mono">/etc/profile</span>. Вы можете изменить их на ваш собственный файл конфигурации shell, см. в <a href="http://younglinux.info/#">Главе 7, “Дом сладкий /home”</a> о настройках окружения оболочки.</p>
<h3>Смена владельцев и групп</h3>
<p>Если файл находится в собственности не того пользователя или группы, то недочет может быть устранен с помощью команд <strong>chown</strong> (смена владельца) и <strong>chgrp</strong> (смена группы). В среде, где файлы должны находиться в коллективном доступе группы, изменение владельца является частой задачей системного администрирования. Обе команды достаточно гибкие, о чем можно узнать с помощью опции <span class="mono">--help</span>.</p>
<p>Команда <strong>chown</strong> может использоваться как для изменения владельца-пользователя файла, так и группы, а <strong>chgrp</strong> изменяет только группу. Конечно, система проверит, имеет ли пользователь, использующий эти команды, достаточно прав на файл(ы), чтобы изменять владельцев.</p>
<p>Чтобы изменить лишь владельца-пользователя файла, используйте следующий синтаксис:</p>
<p><span class="mono">chown <em>newuser</em> file</span> </p>
<p>Если вы используете двоеточие после имени пользователя (см. info-страницы), группа-владелец будет изменена также на основную группу пользователя, запускающего команду. В системе Linux каждый пользователь имеет свою собственную группу, так что эта особенность может использоваться, чтобы делать файлы личными:</p>
<pre>
jacky:~> <strong>id</strong>
uid=1304(jacky) gid=(1304) groups=1304(jacky),2034(pproject)

jacky:~> <strong>ls -l my_report</strong>
-rw-rw-r--  1 jacky   project       29387 Jan 15 09:34 my_report

jacky:~> <strong>chown jacky: my_report</strong>

jacky:~> <strong>chmod o-r my_report</strong>

jacky:~> <strong>ls -l my_report</strong>
-rw-rw----  1 jacky   jacky         29387 Jan 15 09:34 my_report
</pre><p>
Если <em>jacky</em> захотел бы поделиться этим файлом, без предоставления всем разрешения на запись, то он может использовать команду <strong>chgrp</strong>:</p>
<pre>
jacky:~> <strong>ls -l report-20020115.xls</strong>
-rw-rw---- 1 jacky   jacky   45635 Jan 15 09:35 report-20020115.xls

jacky:~> <strong>chgrp project report-20020115.xls</strong>

jacky:~> <strong>chmod o= report-20020115.xls</strong>

jacky:~> <strong>ls -l report-20020115.xls</strong>
-rw-rw---- 1 jacky   project 45635 Jan 15 09:35 report-20020115.xls
</pre><p>
Таким образом, пользователи из группы <em>project</em> смогут работать с этим файлом. У пользователей не из этой группы нет никакого доступа к нему вообще.</p>
<p>Как <strong>chown</strong>, так и <strong>chgrp</strong> могут быть использованы для рекурсивной смены владельца с помощью опции <span class="mono">-r</span>. В этом случае, все вложенные файлы и подкаталоги данного каталога будет принадлежать указанному пользователю и/или группе.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Ограничения.</strong><br />
На большинстве систем, использование команд <strong>chown</strong> и <strong>chgrp</strong> ограничено для непривилегированных пользователей. Если вы не администратор системы, то не можете изменить пользователя или группу по соображениям безопасности. Если использование этих команд не будет ограничено, то злостные пользователи могут назначать владельцами файлов других пользователей и/или другие группы, и изменить поведение окружения пользователей, и даже повредить чужие для них файлы.</p>
<h3>Специальные режимы</h3>
<p>Чтобы все время не беспокоить системного администратора решением проблем, связанных с правами, специальные права доступа могут быть предоставлены для целых каталогов или отдельных программ. Есть три специальных режима:</p>
<ul>
<li>Режим "липкого бита": После выполнения задания, команда находится в оперативной памяти. Первоначально это была функция, которая использовалась в основном для сохранения памяти: большие рабочие части загружались в память только один раз. Но в наши дни память не такая дорогая и есть технологии, которые управляют ей лучше, поэтому это больше не используются для оптимизации возможностей на отдельных файлах. По отношению к целому каталогу, однако, у липкого бита есть другое значение. В этом случае, пользователь может изменять файлы в данной директории, если является владелец файла или файл имеет соответствующие разрешения. Эта возможность используется для таких каталогов как <span class="mono">/var/tmp</span>, которые должны быть доступны для всех, но где нельзя пользователям изменять или удалять данные друг друга. Липкий бит указывает в конце поля прав доступа к файлу:</li>
</ul>
<pre>
mark:~> <strong>ls -ld /var/tmp</strong>
drwxrwxrwt   19 root     root         8192 Jan 16 10:37 /var/tmp/
</pre><p>
Липкий бит установливается с помощью команды <strong>chmod </strong> <span class="mono"> o+t <em>directory</em></span>. Историческое происхождение “t” - сохранение возможности <em>Text access</em> (текстовый доступ) в UNIX.</p>
<ul>
<li>SUID (установка ID пользователя) и SGID (установка ID группы): представлены символом s в поле прав доступа пользователя или группы. Когда этот режим установлен на исполняемый файл, то он будет запускаться с правами пользователя и группы, имеющих разрешения на файл, а не под тем пользователем, который ввел команду, таким образом, предоставляется доступ к системным ресурсам. Мы обсудим это далее в <a href="http://younglinux.info/#">Главе 4, Процессы</a>.</li>
<li>SGID (установка ID группы) на каталог: в этом конкретном случае все файлы, созданные в данном каталоге, будут иметь туже группу-владельца, что и сам каталог (в то время как нормальным поведением является то, что новые файлы принадлежат пользователям, которые их создают). Таким образом, пользователям не нужно беспокоиться о собственности файла при совместном использовании папок:</li>
</ul>
<pre>
mimi:~> <strong>ls -ld /opt/docs</strong>
drwxrws---  4 root    users          4096 Jul 25 2001 docs/

mimi:~> <strong>ls -l /opt/docs</strong>
-rw-rw----  1 mimi    users        345672 Aug 30 2001-Council.doc
</pre><p>
Это стандартный способ совместного доступа к файлам в UNIX.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>  Имеющиеся файлы остаются без изменений!</strong><br />
Файлы, которые перемещаются в SGID-каталог, но были созданы в других местах, сохраняют их первоначальные пользователя-владельца и группу. Это может привести к путанице.</p>
  </div>
<div id="node-205" class="section-3">
  <h1 class="book-heading">Резюме</h1>
  <p>В UNIX, как и в Linux, все объекты, так или иначе, представлены в системе в виде файлов с соответствующими свойствами. Использование (предопределенных) адресных путей позволяет пользователям и системному администратору находить, читать файлы и управлять ими.</p>
<p>Мы сделали первые шаги, чтобы стать экспертом: мы обсудили реальную и "поддельную" структуру файловой системы, и мы узнали о модели файловой безопасности Linux, а также ряде других мер предосторожности, существующих на каждой системе по умолчанию.</p>
<p>Оболочка (shell) – самый важный инструмент для взаимодействия с системой. В этой главе мы познакомились с некоторыми командами, которые перечислены в таблице ниже.</p>
<p><strong>Таблица 3.10. Новые команды из Главы 3: Файлы и файловая система</strong></p>
<table class="il">
<tr>
<td width="250"><strong>Команда</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td><strong>bash </strong> <span class="mono"></span></td>
<td>Программная оболочка проекта GNU</td>
</tr>
<tr>
<td><strong>cat </strong> <span class="mono">file(s)</span></td>
<td>Отправляет содержимое файла(ов) на стандартный вывод</td>
</tr>
<tr>
<td><strong>cd </strong> <span class="mono">directory</span></td>
<td>Переход в <span class="mono">directory</span>. <strong>cd </strong> является встроенной командой <strong>bash</strong></td>
</tr>
<tr>
<td><strong>chgrp </strong> <span class="mono"><em>newgroup</em> file(s)</span></td>
<td>Изменение группы владельцев <span class="mono">file(s)</span> на <em>newgroup</em></td>
</tr>
<tr>
<td><strong>chmod </strong> <span class="mono"> <em>mode</em> file(s)</span></td>
<td>Изменение прав доступа к <span class="mono">file(s)</span></td>
</tr>
<tr>
<td align="left"><strong>chown </strong> <span class="mono"> <em>newowner</em><strong>[:[newgroup]]</strong> file(s)</span></td>
<td>Изменение собственника файла и группы владельцев</td>
</tr>
<tr>
<td><strong>cp </strong> <span class="mono">sourcefile targetfile</span></td>
<td>Копирование <span class="mono">sourcefile</span> в <span class="mono">targetfile</span></td>
</tr>
<tr>
<td><strong>df </strong> <span class="mono">file</span></td>
<td>Отчеты о использовании дискового пространства  раздела, на котором находится файл</td>
</tr>
<tr>
<td><strong>echo </strong> <span class="monoi">string</span></td>
<td>Отображение строки текста</td>
</tr>
<tr>
<td><strong>export </strong> <span class="mono"></span></td>
<td>Часть <strong>bash</strong>, которая объявляет переменные и их значения в системе</td>
</tr>
<tr>
<td><strong>file </strong> <span class="mono">filename</span></td>
<td>Определить тип файла <span class="mono">filename</span></td>
</tr>
<tr>
<td><strong>find </strong> <span class="monoi">path expression</span></td>
<td>Поиск файлов в иерархии файловой системы</td>
</tr>
<tr>
<td><strong>grep  </strong> <span class="monoi">PATTERN file</span></td>
<td>Вывод строк файла, содержащих шаблон поиска</td>
</tr>
<tr>
<td><strong> </strong> <span class="mono"></span></td>
<td></td>
</tr>
<tr>
<td><strong>head  </strong> <span class="mono">file</span></td>
<td>Отправить первую часть файла на стандартный вывод</td>
</tr>
<tr>
<td><strong>id </strong> <span class="mono"></span></td>
<td>Вывод имени пользователя и названий групп</td>
</tr>
<tr>
<td><strong>info </strong> <span class="monoi">command</span></td>
<td>Чтение документации о <strong>command</strong></td>
</tr>
<tr>
<td><strong>less </strong> <span class="mono">file</span></td>
<td>Просмотр файла с помощью специальной программы</td>
</tr>
<tr>
<td><strong>ln </strong> <span class="mono">targetfile linkname</span></td>
<td>Создание ссылки с именем <span class="mono">linkname</span> на <span class="mono">targetfile</span></td>
</tr>
<tr>
<td><strong>locate  </strong> <span class="monoi">searchstring</span></td>
<td>Вывод всех доступных файлов, соответствующих  шаблону поиска</td>
</tr>
<tr>
<td><strong>ls </strong> <span class="mono">file(s)</span></td>
<td>Вывод содержимого директории</td>
</tr>
<tr>
<td><strong>man </strong> <span class="monoi">command</span></td>
<td>Форматирует и отображает страницы системного руководства для <strong>command</strong></td>
</tr>
<tr>
<td><strong>mkdir </strong> <span class="mono">newdir</span></td>
<td>Создает новый пустой каталог</td>
</tr>
<tr>
<td><strong>mv </strong> <span class="mono">oldfile newfile</span></td>
<td>Переименовывает или перемещает <span class="mono">oldfile</span></td>
</tr>
<tr>
<td><strong>newgrp </strong> <span class="monoi">groupname</span></td>
<td>Вход в новую группу</td>
</tr>
<tr>
<td><strong>pwd </strong> <span class="mono"></span></td>
<td>Печать текущего рабочего каталога</td>
</tr>
<tr>
<td><strong>quota </strong> <span class="mono"></span></td>
<td>Показывает используемое дисковое пространство и ограничения</td>
</tr>
<tr>
<td><strong>rm </strong> <span class="mono">file</span></td>
<td>Удаление файлов и директорий</td>
</tr>
<tr>
<td><strong>rmdir </strong> <span class="mono">file</span></td>
<td>Удаление директорий</td>
</tr>
<tr>
<td><strong>tail </strong> <span class="mono">file</span></td>
<td>Вывод последней части <span class="mono">file</span></td>
</tr>
<tr>
<td><strong>umask  </strong> <span class="monoi">[value]</span></td>
<td>Отображает или изменяет режим создания новых файлов</td>
</tr>
<tr>
<td><strong>wc </strong> <span class="mono">file</span></td>
<td>Считает строки, слова и символы в <span class="mono">file</span></td>
</tr>
<tr>
<td><strong>which </strong> <span class="monoi">command</span></td>
<td>Показывает полный путь к команде</td>
</tr>
</table>
<p>Мы также подчеркнули тот факт, что вы должны ЧИТАТЬ СТРАНИЦЫ MAN. Эта документация является вашей первой помощью и содержит ответы на многие вопросы. Упомянутый выше список содержит основные команды, которые вы будете использовать ежедневно, но они могут делать гораздо больше, чем выполнение тех задач, о которых мы говорили здесь. Чтение документации предоставит вам необходимый контроль.</p>
<p>Последнее, но не менее значимое. Удобный обзор файловых разрешений:</p>
<p><strong>Таблица 3.11. Файловые разрешения</strong></p>
<table class="il">
<tr>
<td width="100"><strong>Кто\Что</strong></td>
<td width="100"><strong>r(ead)</strong></td>
<td width="100"><strong>w(rite)</strong></td>
<td width="100"><strong>(e)x(ecute)</strong></td>
</tr>
<tr>
<td>u(ser)</td>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>g(roup)</td>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>o(ther)</td>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
</table>
  </div>
<div id="node-206" class="section-3">
  <h1 class="book-heading">Упражнения</h1>
  <p>Просто войдите под вашим обычным пользовательским ID.</p>
<h2>Разделы</h2>
<ul>
<li>На каком разделе находится ваша домашняя директория?</li>
<li>Сколько разделов в вашей системе?</li>
<li>Каков общий размер вашего установленного Linux?</li>
</ul>
<h2>Пути</h2>
<ul>
<li>Отобразите ваши пути поиска программ.</li>
<li>Экспортируйте бессмысленный адрес, введя, например, <strong>export </strong> <span class="mono">PATH=<em>blah</em></span> и попытайтесь получить список содержимого каталога.</li>
<li>Каков путь к домашней директории? Как бы другой пользователь достиг вашего домашнего каталога, начиная от своего домашнего каталога и используя относительные пути?</li>
<li>Перейти в каталог <span class="mono">tmp</span>, находящийся в <span class="mono">/var</span>.</li>
<li>Теперь перейдите в каталог <span class="mono">share</span>, находящийся в <span class="mono">/usr</span>, используя только одну команду. Измените на <span class="mono">doc</span>. Каков ваш текущий рабочий каталог?</li>
</ul>
<h2>Экскурсияпо системе</h2>
<ul>
<li>Перейдите в каталог <span class="mono">/proc</span>.</li>
<li>На каком процессоре(ах) работает система?</li>
<li>Сколько на текущий момент используется оперативной памяти?</li>
<li>Каким объемом пространства подкачки вы располагаете?</li>
<li>Какие драйверы загружены?</li>
<li>Сколько часов уже работает система?</li>
<li>С какими файловыми системами «знакома» ваша операционная система?</li>
<li>Перейдите в <span class="mono">/etc/rc.d | /etc/init.d | /etc/runlevels</span> и выберите каталог соответствующий вашему запущенному режиму.</li>
<li>Какие сервисы должны быть запущены на этом уровне?</li>
<li>Какие сервисы запускаются в графическом режиме из тех, которые не запускаются  в текстовом?</li>
<li>Перейдите в <span class="mono">/etc</span>.</li>
<li>Как долго в системе хранятся лог-файл с мониторингом входов пользователя.</li>
<li>Какой релиз вы используете?</li>
<li>Есть какие-либо вопросы или сообщения дня?</li>
<li>Сколько пользователей определены в вашей системе? Не считайте их, пусть компьютер сделает это за вас!</li>
<li>Сколько групп?</li>
<li>Где хранится информация о часовом поясе?</li>
<li>В вашей системе установлены какие-нибудь HOWTO?</li>
<li>Перейдите в <span class="mono">/usr/share/doc</span>.</li>
<li>Назовите три программы, которые поставляются с пакетом GNU <em>coreutils</em>.</li>
<li>Какая версия bash установлена в данной системе?</li>
</ul>
<h2>Манипуляции над файлами</h2>
<ul>
<li>Создайте новый каталог в домашней директории.</li>
<li>Можно ли переместить эту папку на тот же уровень, что и ваш домашний каталог?</li>
<li>Скопируйте все XPM файлы из <span class="mono">/usr/share/pixmaps</span> в новый каталог. Что значит XPM?</li>
<li>Отобразите список файлов в обратном алфавитном порядке.</li>
<li>Перейдите в ваш домашний каталог. Создайте новый каталог и скопируйте в него все файлы из каталога <span class="mono">/etc</span>. Убедитесь, что вы также скопировали файлы и каталоги, которые находятся в подкаталогах <span class="mono">/etc</span>! (рекурсивное копирование)</li>
<li>Перейдите в новый каталог и создайте папку для файлов, начинающихся с большой буквы, и одну — для файлов, начинающихся с символов нижнего регистра. Переместите все файлы в предназначенные для них каталоги. Используйте как можно меньше команд, насколько это возможно.</li>
<li>Удалите остальные файлы.</li>
<li>Удалить каталог и все его содержимое с помощью одной команды.</li>
<li>Используйте <strong>grep</strong>, чтобы выяснить, какой сценарий запускает сервер шрифтов в графическом режиме.</li>
<li>Где находится программа <em>sendmail</em>?</li>
<li>Создайте символическую ссылку в вашем домашнем каталоге на /var/tmp. Убедитесь, что она действительно работает.</li>
<li>Сделайте еще символическую ссылку в вашем домашнем каталоге на эту ссылку. Также проверьте ее работоспособность. Удалите первую ссылку и отобразите содержимое каталога. Что случилось со второй ссылкой?</li>
</ul>
<h2>Разрешения файлов</h2>
<ul>
<li>Вы можете поменять права доступа к файлам в <span class="mono">/home</span>?</li>
<li>Какой у вас стандартный режим создания файлов?</li>
<li>Измените собственника <span class="mono">/etc</span> на вашего личные пользователя и группу.</li>
<li>Измените права доступа к файлу <span class="mono">~/.bashrc</span> так, чтобы только вы и ваша основная группа могли читать его.</li>
<li>Введите команду <strong>locate </strong> <span class="mono">root</span>. Вы заметили что-нибудь особенное?</li>
<li>Создайте символическую ссылку на <span class="mono">/root</span>. Можно ли ее использовать?</li>
</ul>
  </div>
</div>
    </div>
  </body>
</html>
