<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Глава 4. Процессы</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
              <div class="section-1">
          
    <div id="node-207" class="section-2">
  <h1 class="book-heading">Глава 4. Процессы</h1>
  <h4>Аннотация</h4>
<p>Наряду с файлами, процессы представляют собой наиболее важных объекты в системах UNIX/Linux. В этой главе мы присмотримся к этим процессам. Мы узнаем больше о том, что такое:</p>
<ul>
<li>Многопользовательская работа и многозадачность</li>
<li>Типы процессов</li>
<li>Контроль процессов различными сигналами</li>
<li>Свойства процессов</li>
<li>Жизненный цикл процесса</li>
<li>Системный запуск и остановка</li>
<li>SUID и SGID</li>
<li>Системная скорость и ответная реакция</li>
<li>Планирование процессов</li>
<li>Система  Vixie cron</li>
<li>Как получить максимум от вашей системы</li>
</ul>
  <div id="node-208" class="section-3">
  <h1 class="book-heading">Процессы изнутри</h1>
  <h2>Многопользовательская работа и многозадачность</h2>
<p>Теперь, когда мы уже привыкли к нашему окружению и способны немного взаимодействовать с нашей системой, самое время для более детального изучения процессов. Не все команды запускают единственный процесс. Некоторые из них начинают целый ряд процессов, например, <strong>mozilla</strong>; другие, как <strong>ls</strong>, выполняются как единственная команда.</p>
<p>Кроме того, Linux основан на UNIX, где это является обычной практикой при многочисленных пользователях, запускающих множество команд в одно и то же время в одной и той же системе. Очевидно, что были приняты меры, чтобы  процессор управлял всеми этими процессами, и обеспечивалась функциональность, когда пользователи могут переключаться между процессами. В некоторых случаях процессы должны продолжать работать, даже если пользователь, который их запустил, вышел из системы. С другой стороны, пользователи нуждаются в средствах для прерывания процессов.</p>
<p>В следующих разделах мы расскажем об устройстве процессов в Linux.</p>
<h2>Типы процессов</h2>
<h3>Интерактивные процессы</h3>
<p>Интерактивные процессы инициализируется и контролируется через терминальную сессию. Иными словами, кто-то должен быть подключен к системе, чтобы эти процессы запустились; они не запускаются автоматически, как часть функциональности системы. Эти процессы могут работать на переднем плане, занимая терминал, который запустил программу, и вы не сможете запускать другие приложения до тех пор, как этот процесс работает таким образом. Иначе они могут работать в фоновом режиме, таким образом, терминал, в котором вы запустили программу, может принимать новые команды, пока та программа тоже работает. До сих пор мы в основном уделяли внимание программам, работающим на переднем плане - продолжительность времени, необходимого для их работы, была слишком короткой, чтобы заметить - но просмотр файлов командой less - хороший пример, когда команда занимает терминал сессии. В этом случае, активная программа ожидает от вас какого-нибудь действия. Программа по-прежнему связана с терминалом, откуда она была запущена, а терминал пригоден только для ввода команд для этой программы, только их он может понять. Другие команды просто приведут к ошибкам или зависанию системы.</p>
<p>Несмотря на то, что процесс выполняется в фоновом режиме, пользователь все равно не имеет возможности делать другие вещи в терминале, в котором он запустил программу, пока программа работает.</p>
<p>Оболочка предлагает функцию управления заданиями, которая позволяет легко обрабатывать множество процессов. Этот механизм переключает процессы между передним и задним фоном. Используя эту систему, программы также могут быть запущены в фоновом режиме сразу же.</p>
<p>Запуск процесса в фоновом режиме, имеет смысл только для программ, которые не нуждаются в пользовательском контроле (через shell). Перевод задания  в фоновый режим делается, как правило, когда для его выполнения, как ожидается, потребует длительного времени. Для того, чтобы освободить выдачу терминала после ввода команды, добавляется завершающий амперсанд. В примере, используя графический режим, мы открываем дополнительное окно терминала из имеющегося:</p>
<pre>
billy:~> <strong>xterm &</strong>
[1] 26558

billy:~> <strong>jobs</strong>
[1]+  Running                 xterm &
</pre><p>
Подробное описание функции контроля заданий есть в info-страницах <strong>bash</strong>, так что здесь перечислены только наиболее часто используемые способы управления заданиями:</p>
<p><strong>Таблица 4.1. Управление процессами</strong></p>
<table class="il">
<tr>
<td width="150"><strong>Команды (часть из существующих)</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td><strong>regular_command</strong></td>
<td>Запуск данной команды на переднем плане.</td>
</tr>
<tr>
<td><strong>command &amp;</strong></td>
<td>Запуск команды в фоновом режиме (в версии терминала).</td>
</tr>
<tr>
<td><strong>jobs</strong></td>
<td>Показывает команды запущенные в фоновом режиме.</td>
</tr>
<tr>
<td><strong>Ctrl+Z</strong></td>
<td>Приостановить (остановить, но не выйти) процесс, выполняемый на переднем плане (засыпание).</td>
</tr>
<tr>
<td><strong>Ctrl+C</strong></td>
<td>Прервать (прекратить и выйти) процесс, выполняемый на переднем плане.</td>
</tr>
<tr>
<td><span class="monoi">%n</span></td>
<td>Каждый процесс, выполняемый в фоновом режиме, получает присвоенный ему номер. Используя выражение %, указание может быть отнесено к процессу путем использования его номера, например, <strong>fg </strong> <span class="mono">%2</span>.</td>
</tr>
<tr>
<td><strong>bg</strong></td>
<td>Возобновить приостановленную программу в фоновом режиме.</td>
</tr>
<tr>
<td><strong>fg</strong></td>
<td>Поместить фоновое задание на передний план.</td>
</tr>
<tr>
<td><strong>kill</strong></td>
<td>Завершение процесса (см. также Shell Builtin Commands на info-страницах <strong>bash</strong>).</td>
</tr>
</table>
<p>Подробные практические примеры можно найти в упражнениях.</p>
<p>Большинство UNIX систем, вероятно, могут быть способны запустить экран, который полезен, когда вам действительно нужна еще одна оболочка для выполнения команд. После вызова экрана, новая сессия создается с сопутствующей оболочкой и/или командами, которые указаны и которые вы можете отложить в сторону. В этой новой сессии вы можете делать все, что вы хотите. Все программы и операции будут работать независимо от выдачи оболочки. Затем вы можете отделить эту сессию, пока программы, которые вы запустили в ней, продолжат работать, даже когда вы выйдите из оболочки давшей начало, и выберите экран снова в любое удобное для вас время.</p>
<p>Эта программа берет свое начало со времени, когда виртуальные консоли еще не придумали, и все должно было быть сделано с помощью одного текстового терминала. Для увлеченных это все еще имеет значение в Linux, хотя уже почти 10 лет у нас есть виртуальные консоли.</p>
<h3>Автоматические процессы</h3>
<p> Автоматические или пакетные процессы не связаны с терминалом. Скорее, это такие задачи, которые могут быть поставлены в очередь области диспетчера печати, где они ожидают выполнения по принципу FIFO (первый вошел, первый вышел). Такие задачи могут быть выполнены с помощью одного из двух критериев:</p>
<ul>
<li>В определенную дату и время: выполнение, используя команду <strong>at</strong>, которую мы обсудим во второй части этой главы.</li>
<li>В периоды, когда общая загруженность системы достаточно низка, чтобы принять дополнительные работы: делается с помощью команды <strong>batch</strong>. По умолчанию задачи ставятся в очередь, где они ожидают выполнения в период, когда загрузка системы будет меньше, чем 0,8. В больших средах системный администратор может отдать предпочтение пакетной обработке, когда должны быть обработаны большие объемы данных или когда выполнение задач требуют много системных ресурсов в уже загруженной системе. Пакетная обработка используется также для оптимизации производительности системы.</li>
</ul>
<h3>Демоны</h3>
<p>Демоны — это серверные процессы, которые работают постоянно. В большинстве случаев они инициализируются при запуске системы, и затем ожидают в фоновом режиме до того, как их услуги потребуются. Типичным примером является сетевой демон <em>xinetd</em>, которая запускается почти при каждой процедуре загрузки. После того как система загрузится, сетевой демон просто сидит и ждет клиентскую программу, которую необходимо подключить, такую как, например, FTP-клиент.</p>
<h2>Свойства процессов</h2>
<p>Процесс имеет ряд особенностей, которые могут быть просмотрены с помощью команды <strong>ps</strong>:</p>
<ul>
<li>Идентификатор процесса или PID: уникальный идентификационный номер, используемый для обращения к процессу.</li>
<li>ID родительского процесса или PPID: номер процесса (PID), который запустил данный процесс.</li>
<li>Nice-число: степень дружелюбия этого процесса по отношению к другим процессам (не путать с приоритетом процесса, который рассчитывается на основе этого милого числа и последнего использования процессора этим процессом).</li>
<li>Терминал или TTY: терминал, к которому привязан данный процесс.</li>
<li>Имя реального и эффективного пользователя (RUID и EUID): владелец процесса. Реальным владельцем является пользователь, который ввел команду, эффективный пользователь — тот, кто определяет порядок доступа к системным ресурсам. RUID и EUID обычно это одно и то же, и процесс имеет те же права доступа, которые есть у пользователя его запустившего. Поясним это на примере: браузер <strong>mozilla</strong>, находящийся в <span class="mono">/usr/bin</span>, принадлежит пользователю <em>root</em>:</li>
</ul>
<pre>
theo:~> <strong>ls -l /usr/bin/mozilla</strong>
-rwxr-xr-x  1 root   root      4996 Nov 20 18:28 /usr/bin/mozilla*

theo:~> <strong>mozilla &</strong>
[1] 26595

theo:~> <strong>ps -af</strong>
UID     PID  PPID C STIME TTY       TIME CMD
theo  26601 26599 0 15:04 pts/5 00:00:00 /usr/lib/mozilla/mozilla-bin
theo  26613 26569 0 15:04 pts/5 00:00:00 ps -af
</pre><p>
Когда пользователь <em>theo</em> запускает эту программу, сам процесс и все процессы, запущенные им, будут принадлежать пользователю <em>theo</em>, а не системному администратору. Когда <strong>mozilla</strong> будет требовать доступ к определенным файлам, то доступ будет зависеть от разрешений <em>theo</em>, а не администратора.</p>
<ul>
<li>Реальная и эффективная группы владельца (RGID и EGID): реальной группой- владельцем процесса является основная группа пользователя, запустившего процесс. Эффективная группа-владелец - обычно то же самое, за исключением случаев, когда режим доступа SGID применяется к файлу.</li>
</ul>
<h2>Просмотр информации о процессе</h2>
<p>Команда <strong>ps</strong> является одним из инструментов для визуализации процессов. Эта команда имеет несколько опций, которые могут быть объединены для отображения различных свойств процесса.</p>
<p>При отсутствии конкретных опций <strong>ps</strong> выдает только информацию о текущей оболочке и возможных процессах:</p>
<pre>
theo:~> <strong>ps</strong>
  PID TTY          TIME CMD
 4245 pts/7    00:00:00 bash
 5314 pts/7    00:00:00 ps
</pre><p>
Поскольку это не дает достаточно информации - как правило, по меньшей мере сотня процессов запущены в вашей системе – мы обычно будем выбирать отдельные процессы из списка всех процессов, используя команду <strong>grep</strong> в конвейере , см. <a href="http://younglinux.info/#">Раздел  "Выход перенаправления с > и | "</a>, как в этой строке, в которой будут выбраны и отображены все процессы, принадлежащие определенному пользователю:</p>
<p><span class="mono">ps -ef | grep username</span></p>
<p>Этот пример показывает все процессы с процессорным именем <strong>bash</strong>, наиболее распространенной оболочкой в системах Linux:</p>
<pre>
theo:> ps auxw | grep bash
brenda   31970  0.0  0.3  6080 1556 tty2   S  Feb23   0:00 -bash
root     32043  0.0  0.3  6112 1600 tty4   S  Feb23   0:00 -bash
theo     32581  0.0  0.3  6384 1864 pts/1  S  Feb23   0:00 bash
theo     32616  0.0  0.3  6396 1896 pts/2  S  Feb23   0:00 bash
theo     32629  0.0  0.3  6380 1856 pts/3  S  Feb23   0:00 bash
theo      2214  0.0  0.3  6412 1944 pts/5  S  16:18   0:02 bash
theo      4245  0.0  0.3  6392 1888 pts/7  S  17:26   0:00 bash
theo      5427  0.0  0.1  3720  548 pts/7  S  19:22   0:00 grep bash
</pre><p>
В этих случаях команда <strong>grep</strong> находит строки, содержащие строку <em>bash</em>, которые множество раз отображаются также в системах, которые имеют много простоев. Если вы не хотите, чтобы это произошло, используйте команду <strong>pgrep</strong>.</p>
<p>Bash-оболочки представляют собой особый случай: этот процессорный список также показывает, какие из них являются оболочками входа (где вы должны ввести ваше имя пользователя и пароль, например, когда вы входите в текстовом режиме или же совершаете удаленный вход, в отличие от оболочек не требующих логина, например, нажав значок окна терминала). Такие оболочки, требующие логин, начинаются с дефиса (-).</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>|?</strong><br />
Мы расскажем об операторе | в следующей главе, см. <a href="http://younglinux.info/#">Главу 5, "Перенаправление ввода/вывода"</a>.</p>
<p>Дополнительная информация может быть найдена как обычно: <strong>ps </strong> <span class="mono"> --help</span> или <strong>man </strong> <span class="monoi">ps</span>. GNU <strong>ps</strong> поддерживает различные форматы опций; приведенные выше примеры не содержат ошибок.</p>
<p>Заметьте, что <strong>ps</strong> выдает только сиюминутное состояние активных процессов, это одномоментный срез. Программа <strong>top</strong> дает более точный обзор путем обновления результатов, определенных <strong>ps</strong> (с множеством опций), один раз в 5 секунд, создавая новый список процессов, что периодически вызывает большие нагрузки, поэтому используется подключение дополнительной информации о файле подкачки и состоянии процессора; из файла <span class="mono">proc</span> системы:</p>
<pre>
 12:40pm up 9 days, 6:00, 4 users, load average: 0.21, 0.11, 0.03
89 processes: 86 sleeping, 3 running, 0 zombie, 0 stopped
CPU states:  2.5% user,  1.7% system,  0.0% nice, 95.6% idle
Mem:   255120K av, 239412K used, 15708K free, 756K shrd, 22620K buff
Swap: 1050176K av, 76428K used, 973748K free, 82756K cached

  PID USER  PRI NI SIZE  RSS SHARE STAT %CPU %MEM TIME COMMAND
 5005 root  14  0 91572  15M 11580 R    1.9  6.0  7:53 X
19599 jeff  14  0  1024 1024   796 R    1.1  0.4  0:01 top
19100 jeff   9  0  5288 4948  3888 R    0.5  1.9  0:24 gnome-terminal
19328 jeff   9  0 37884  36M 14724 S    0.5 14.8  1:30 mozilla-bin
    1 root   8  0   516  472   464 S    0.0  0.1  0:06 init
    2 root   9  0     0    0     0 SW   0.0  0.0  0:02 keventd
    3 root   9  0     0    0     0 SW   0.0  0.0  0:00 kapm-idled
    4 root  19 19     0    0     0 SWN  0.0  0.0  0:00 ksoftirqd_CPU0
    5 root   9  0     0    0     0 SW   0.0  0.0  0:33 kswapd
    6 root   9  0     0    0     0 SW   0.0  0.0  0:00 kreclaimd
    7 root   9  0     0    0     0 SW   0.0  0.0  0:00 bdflush
    8 root   9  0     0    0     0 SW   0.0  0.0  0:05 kupdated
    9 root  -1-20     0    0     0 SW&lt;  0.0  0.0  0:00 mdrecoveryd
   13 root   9  0     0    0     0 SW   0.0  0.0  0:01 kjournald
   89 root   9  0     0    0     0 SW   0.0  0.0  0:00 khubd
  219 root   9  0     0    0     0 SW   0.0  0.0  0:00 kjournald
  220 root   9  0     0    0     0 SW   0.0  0.0  0:00 kjournald
</pre><p>
Первая строка <strong>top</strong> содержит такую же информацию, которая отображается командой <strong>uptime</strong>:</p>
<pre>
jeff:~> <strong>uptime</strong>
  3:30pm, up 12 days, 23:29, 6 users, load average: 0.01, 0.02, 0.00
</pre><p>
Данных для этих программ хранятся среди других в  <span class="mono">/var/run/utmp</span> (информация о текущих подключенных пользователях) и в виртуальной файловой системе <span class="mono">/proc</span>, например, <span class="mono">/proc/loadavg</span> (обычная загрузочная информация). Есть разные виды графических приложений для просмотра этой информации, такие как Gnome System Monitor и <em>lavaps</em>. На <noindex><a href="http://freshmeat.net/">FreshMeat</a> и <a href="http://sourceforge.net/">SourceForge</a></noindex> и вы найдете десятки приложений, которые централизируют эту информацию наряду с другими серверными данными и журналами со множества серверов на один (web) сервер, что позволяет осуществлять мониторинг всей ИТ-инфраструктуры с одной рабочей станции.</p>
<p>Отношения между процессами могут быть отображены с использованием команды <strong>pstree</strong>:</p>
<pre>
sophie:~> <strong>pstree</strong>
init-+-amd
     |-apmd
     |-2*[artsd]
     |-atd
     |-crond
     |-deskguide_apple
     |-eth0
     |-gdm---gdm-+-X
     |           `-gnome-session-+-Gnome
     |                           |-ssh-agent
     |                           `-true
     |-geyes_applet
     |-gkb_applet
     |-gnome-name-serv
     |-gnome-smproxy
     |-gnome-terminal-+-bash---vim
     |                |-bash
     |                |-bash---pstree
     |                |-bash---ssh
     |                |-bash---mozilla-bin---mozilla-bin---3*[mozilla-bin]
     |                `-gnome-pty-helper
     |-gpm
     |-gweather
     |-kapm-idled
     |-3*[kdeinit]
     |-keventd
     |-khubd
     |-5*[kjournald]
     |-klogd
     |-lockd---rpciod
     |-lpd
     |-mdrecoveryd
     |-6*[mingetty]
     |-8*[nfsd]
     |-nscd---nscd---5*[nscd]
     |-ntpd
     |-3*[oafd]
     |-panel
     |-portmap
     |-rhnsd
     |-rpc.mountd
     |-rpc.rquotad
     |-rpc.statd
     |-sawfish
     |-screenshooter_a
     |-sendmail
     |-sshd---sshd---bash---su---bash
     |-syslogd
     |-tasklist_applet
     |-vmnet-bridge
     |-xfs
     `-xinetd-ipv6
</pre><p>
Опции <span class="mono">-u</span> и <span class="mono">-a</span> дают дополнительную информацию. Для знакомства с другими опциями, а также тем, что  они делают, направляем к info-страницам.</p>
<p>В следующем разделе мы увидим, как один процесс может создавать другой.</p>
<h2>Жизнь и смерть процесса</h2>
<h3>Создание процесса</h3>
<p>Новый процесс появляется вследствие того, что существующий процесс создает точную копию самого себя. У этого дочернего процесса тоже окружение, что и у родителя, отличается только номер ID процесса. Эта процедура называется <em>forking</em> (порождение).</p>
<p>После рождения, адресное пространство дочернего процесса переписывается с новыми данными процесса. Это делается посредством вызова <em>ехес</em> в системе.</p>
<p>Таким образом, механизм <em>fork-and-exec</em> переключает старые команды на новые, пока окружение, в котором выполняется новая программа остается таким же, в том числе конфигурация устройств ввода/вывода, переменные окружения и приоритет. Этот механизм используется для создания всех процессов UNIX, также это относится и к операционной системе Linux. Даже первый процесс, <strong>init</strong>, с процессорным ID 1, порождается во время загрузки  в так называемой процедуре <em>bootstrapping</em> (начальной загрузки).</p>
<p>Эта схема иллюстрирует механизм <em>fork-and-exec</em>. ID процесса изменяется после процедуры порождения:</p>
<p><strong>Рисунок 4.1. Механизм fork-and-exec</strong></p>
<div style="text-align:center;"><img src="../../../img/linuxintro/fork-and-exec.png" width="366" height="441" alt="Происхождение процессов в Linux" /></div>
<p>Есть несколько случаев, в которых <strong>init</strong> становится родителем процесса, хотя процесс не был запущен <strong>init</strong>, как мы уже видели в примере <strong>pstree</strong>. Многие программы, например, <em>daemonize</em> - их дочерние процессы, так они могут продолжать работать, когда родитель завершается или его завершают. Оконный менеджер является типичным примером; он запускается процессом <strong>xterm</strong>, который создает оболочку (shell), принимающую команды. Затем оконный менеджер отстраняется от какой-либо дальнейшей ответственности и передает дочерний процесс <strong>init</strong>. С помощью этого механизма можно менять оконные менеджеры, не прерывая запущенных приложений.</p>
<p>Время от времени что-то идет не так даже в хороших семьях. В исключительных случаях процесс может закончиться, в то время как родитель не ждет завершения этого процесса. Такой непогребенный процесс называется зомби-процессом.</p>
<h3>Завершение процесса</h3>
<p>Когда процесс завершается нормально (его не завершили или иным способом неожиданно не прервали), программа возвращает его <em>exit status</em> (статус выхода) родителю. Этот <em>exit status</em> является числом, возвращаемым программой, предоставившей результаты своего выполнения. Система передачи информации об исполненной работе берет свое начало с языка программирования Си, на котором был написан UNIX.</p>
<p>Коды возврата могут быть интерпретированы родителем или скриптами. Значения кодов возврата специфичны для программ. Эту информацию обычно можно найти в man-страницах указанной программы, например команда <strong>grep</strong> возвращает -1, если не найдено совпадений, при этом в строке может быть выведено сообщение: "Нет найденных файлов". Другим примером является встроенная команда Bash <strong>true</strong>, которая не делает ничего, кроме возвращения статуса выхода 0, что означает успех.</p>
<h3>Сигналы</h3>
<p>Процессы заканчиваются, если они получают сигнал. Есть несколько сигналов, которые вы можете отправить процессу. Используйте команду <strong>kill</strong>, чтобы послать сигнал процессу. Команда <strong>kill </strong> <span class="mono"> -i</span> отображается список сигналов. Большинство сигналов предназначены для внутреннего использования системой или для программистов, когда они пишут код. Как пользователю вам потребуются следующие сигналы:</p>
<p><strong>Таблица 4.2. Часто используемые сигналы</strong></p>
<table class="il">
<tr>
<td width="150"><strong>Имя сигнала</strong></td>
<td width="150"><strong>Номер сигнала</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>Завершить процесс надлежащим образом.</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>Прерывание процесса. Процесс может игнорировать этот сигнал.</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>Прерывание процесса. Процесс не может игнорировать этот сигнал.</td>
</tr>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>Для демонов: перечитать конфигурационный файл.</td>
</tr>
</table>
<p>Вы можете прочитать больше о действиях по умолчанию, которые предпринимаются при передаче сигнала процессу, в <strong>man </strong> <span class="mono"> 7 <em>signal</em></span>.</p>
<h2>SUID и SGID</h2>
<p>Как и было обещано в предыдущей главе, теперь мы будем обсуждать специальные режимы SUID и SGID более подробно. Эти режимы существуют, чтобы обеспечить обычным пользователям возможность выполнять задачи, которые они, как правило, не могут осуществить из-за строгой схемы управления доступом к файлам, используемой в UNIX-системах. В идеальной ситуации специальные режимы используются так редко, насколько это возможно, так как они включают в себя риски для безопасности. Разработчики Linux, как правило, стараются также избегать их по возможности. Версия <strong>ps</strong> в Linux, например, использует информацию, хранящуюся в файловой системе <span class="mono">/proc</span>, которая доступна каждому, что позволяет избегать демонстрации важных системных данных и ресурсов для широкой общественности. До этого (и до сих пор на старых системах UNIX) программа <strong>ps</strong> нуждалась в доступе к файлам, таким как <span class="mono">/dev/mem</span> и <span class="mono">/dev/kmem</span>, что имело свои недостатки из-за разрешений и владельцев этих файлов:</p>
<pre>
rita:~> <strong>ls -l /dev/*mem</strong>
crw-r-----    1 root     kmem       1,   2 Aug 30 22:30 /dev/kmem
crw-r-----    1 root     kmem       1,   1 Aug 30 22:30 /dev/mem
</pre><p>
В более ранних версиях <strong>ps</strong> не было возможности для запуска программы под обычным пользователем без применения специальных режимов.</p>
<p>Хотя мы обычно стараемся избегать применения каких-либо специальных режимов, иногда бывает необходимо использовать SUID. Примером может служить механизм смены пароля. Очевидно, что пользователи хотят делать это самостоятельно вместо того, чтобы их пароль устанавливал системный администратор. Как мы знаем, имена пользователей и пароли перечислены в файле <span class="mono">/etc/passwd</span>, который имеет следующие права доступа и владельцев:</p>
<pre>
bea:~> <strong>ls -l /etc/passwd</strong>
-rw-r--r--    1 root     root     1267 Jan 16 14:43 /etc/passwd
</pre><p>
Тем не менее, у пользователей должна быть возможность изменять свою информацию в этом файле. Это достигается путем предоставления программой <strong>passwd</strong> специальных разрешений:</p>
<pre>
mia:~> <strong>which passwd</strong>
passwd is /usr/bin/passwd

mia:~> <strong>ls -l /usr/bin/passwd</strong>
-r-s--x--x    1 root     root    13476 Aug  7 06:03 /usr/bin/passwd*
</pre><p>
При вызове команда passwd выполняется с использованием прав доступа <em>root</em>, что позволяет обычному пользователю редактировать файл паролей, который принадлежит системному администратору.</p>
<p>SGID режимы на файл не распространяются так же часто, как SUID, потому что SGID зачастую включает в себя создание дополнительных групп. В некоторых случаях, однако, мы должны пройти через эту неприятность, с тем чтобы выполнить элегантное решение (слишком об этом не беспокойтесь - необходимые группы обычно создаются при установке). Это происходит для программ <strong>write</strong> и <strong>wall</strong>, которые используются для отправки сообщений другим пользовательским терминалами (ttys). Команда <strong>write</strong> выводит сообщение одному пользователю, а <strong>wall</strong> пишет всем подключенным пользователям.</p>
<p>Отправка текста иным пользовательским терминалам или на графический дисплей, как правило, не допускается. Для того чтобы обойти эту проблему, была создана группа, которая является владельцем всех терминальных устройств. Когда команды <strong>write</strong> и <strong>wall</strong> получают SGID разрешения, команды запустятся с помощью прав доступа, применимых к этой группе, <em>tty</em> в примере. Поскольку у этой группы есть право на запись в назначенный терминал, то пользователь, не имеющий разрешения на использование этого терминала, в любом случае может отправлять туда сообщения.</p>
<p>В приведенном ниже примере пользователь <em>joe</em> в начале узнает, с каким терминалом связан его корреспондент, для этого он использует команду <strong>who</strong>. Затем он отправляет ей сообщение с помощью команды <strong>write</strong>. Кроме того, иллюстрируются права доступа на программу <strong>write</strong> и какие терминалы занимает принимающий пользователь: очевидно, что отличные от пользователя-владельца не имеют разрешения на устройство, за исключением владельца-группы, которая может писать в него.</p>
<pre>
joe:~> <strong>which write</strong>
write is /usr/bin/write

joe:~> <strong>ls -l /usr/bin/write</strong>
-rwxr-sr-x    1 root     tty      8744 Dec  5 00:55 /usr/bin/write*

joe:~> <strong>who</strong>
jenny     tty1     Jan 23 11:41
jenny     pts/1    Jan 23 12:21 (:0)
jenny     pts/2    Jan 23 12:22 (:0)
jenny     pts/3    Jan 23 12:22 (:0)
joe       pts/0    Jan 20 10:13 (lo.callhost.org)

joe:~> <strong>ls -l /dev/tty1</strong>
crw--w----    1 jenny   tty  4,     1 Jan 23 11:41 /dev/tty1

joe:~> <strong>write jenny tty1</strong>
hey Jenny, shall we have lunch together?
^C
</pre><p>
Пользователь <em>jenny</em> получает это на ее экране:</p>
<pre>
Message from joe@lo.callhost.org on ptys/1 at 12:36 ...
hey Jenny, shall we have lunch together?
EOF
</pre><p>
После получения сообщения, терминал может быть очищен помощью комбинации клавиш <strong>Ctrl + L</strong>. Для того, чтобы не получать никакие сообщения вообще (кроме тех, что от системного администратора), используйте команду <strong>mesg</strong>. Чтобы узнать, какие подключенные пользователи принимают сообщения от других, используют <strong>who </strong> <span class="mono"> -w</span>. Все особенности полностью разъяснены на info-страницах для каждой команды.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Названия групп могут быть различными. </strong><br />
Групповая схема специфична для дистрибутива. Разные дистрибутивы могут использовать разные имена или различные решения.</p>
  </div>
<div id="node-209" class="section-3">
  <h1 class="book-heading">Процесс загрузки, инициализация и завершение работы</h1>
  <h2>Введение</h2>
<p>Одна из наиболее мощных сторон Linux связана с ее открытым методом запуска и остановки операционной системы; Linux загружает определенные программы, используя их особую конфигурацию, что позволяет вам изменять эти конфигурации для контроля процесса загрузки и останавливать работу системы элегантно и организовано.</p>
<p>Помимо задач контроля загрузки и процесса завершения работы, открытый характер Linux облегчает в большинстве случаев точное определение источников проблем, связанных с запуском и остановкой системы. Понимание основ этого является весьма полезным для всех, кто использует Linux.</p>
<p>Множество систем Linux используют <strong>lilo</strong> (LInux LOader) для загрузки операционных систем. Мы обсудим только GRUB, т. к. он проще в использовании и является более гибким. Если вам необходима информация о <strong>lilo</strong>, обратитесь к man-страницам и HOWTO. Оба загрузчика поддерживают двойные загрузки; мы ссылаемся на HOWTO по этому вопросу для практических примеров и справочной информации.</p>
<h2>Загрузочный процесс</h2>
<p>Когда загружается компьютер x86, процессор просматривает конец системной памяти на обнаружение BIOS (Basic Input/Output System) и запускает его. (Программа BIOS записывается в постоянной памяти только для чтения, и всегда доступна для использования.) BIOS обеспечивает низкоуровневый интерфейс для периферийных устройств и контролирует первый шаг процесса загрузки.</p>
<p>BIOS тестирует систему, ищет и проверяет периферию, и затем ищет устройство, чтобы использовать его для загрузки системы. Обычно BIOS проверяет устройство для дискет (или на многих современных системах дисковод CD-ROM) на наличие загрузочного диска, если их там нет, то смотрит на жестком диске. Последовательность устройств, используемых для загрузки, обычно контролируется индивидуальными для системы настройками BIOS. После того, как Linux установлен на жесткий диск, BIOS ищет главную загрузочную запись (Master Boot Record - MBR), начиная с первого сектора первого жесткого диска, загружает его содержимое в память и передает ему управление.</p>
<p>MBR содержит инструкции о том, как загрузить загрузчик GRUB (или LILO), использующий предварительно заданные операционные системы. MBR загружает загрузчик, который принимает на себя процесс (если загрузчик установлен в MBR). В стандартной конфигурации Red Hat Linux GRUB использует настройки в MBR для отображения параметров загрузки в меню. Как только GRUB получил корректные инструкции для запуска операционной системы либо из его командной строки или из файла конфигурации, он находит необходимые загрузочные файлы и удаляется от управления машиной в данной операционной системе.</p>
<h2>Особенности GRUB</h2>
<p>Этот метод загрузки называется <em>прямой загрузкой</em>, поскольку инструкции используются для непосредственной загрузки операционной системы, без какого-либо промежуточного кода между загрузчиком и основными файлами операционной системы (например, ядром). Процесс загрузки, используемый в других операционных системах, может незначительно отличаться от вышеуказанного. Например, операционные системы Microsoft (DOS и Windows) полностью переписывают MBR, когда они устанавливаются без учета какой-либо текущей конфигурации MBR. Все они стирают любую другую информацию, хранящуюся в MBR от других операционных систем, таких как Linux. Операционные системы Microsoft, также как и другие разные проприетарные  операционные системы, загружаются с помощью метода цепной загрузки. При использовании этого метода, MBR указывает на первый сектор раздела, на котором находится операционная система, где находит специальные файлы, необходимые для фактической загрузки данной операционной системы.</p>
<p>GRUB поддерживает оба загрузочных метода, что позволяет использовать его практически с любой операционной системой, наиболее популярными файловыми системами, и практически любым жестким диском, который сможет распознать ваш BIOS.</p>
<p>GRUB содержит ряд других особенностей. Из них наиболее важные:</p>
<ul>
<li>GRUB обеспечивает истинно командное, предшествующее ОС, окружение на машинах x86 для обеспечения максимальной гибкости при загрузке операционной системы с определенными параметрами или сбора информации о системе.</li>
<li>GRUB поддерживает режим логической адресации блоков (LBA), необходимый для доступа ко многим IDE и всем SCSI жестким дискам. До LBA жесткие диски могли столкнуться с 1024-цилиндровый пределом, когда BIOS  после этого места не может найти файл.</li>
<li>Конфигурационный файл GRUB читается с диска каждый раз при загрузке системы, освобождая вас от необходимости писать поверх MBR при каждом изменении параметров загрузки.</li>
</ul>
<p>Полное описание GRUB можно найти, выполнив команду <strong>info</strong> <span class="monoi">grub</span> или на <noindex><a href="http://www.gnu.org/software/grub/">сайте GRUB</a></noindex>. В Linux Documentation Project есть мини-HOWTO по мультизагрузке GRUB.</p>
<h2>Init</h2>
<p>Ядро, как только оно загружено, находит <strong>init</strong> в <span class="mono">sbin</span> и выполняет его.</p>
<p>Когда <strong>init</strong> запускается, то становится родителем и прародителем всех процессов, которые запускаются автоматически в вашей системе Linux. Первое, что делает <strong>init</strong>, читает его файл инициализации <span class="mono">/etc/inittab</span>. Он инструктирует <strong>init</strong> прочитать первоначальный сценарий конфигурации для окружения, в котором определены пути, запускается своппинг, проверяются файловые системы и так далее. В принципе, этот шаг позаботится обо всем, что ваша система должна сделать при своей инициализации: установка часов, инициализация последовательных портов и т.д.</p>
<p>Затем <strong>init</strong> продолжает читать файл <span class="mono">/etc/inittab</span>, который описывает, каким образом система должна подниматься на каждом уровне запуска и устанавливает <em>уровень выполнения</em> по умолчанию. <em>Уровень выполнения</em> определяет конфигурацию процессов. Все UNIX-подобные системы могут работать в различных конфигурациях, среди них есть однопользовательский режим, который называется уровнем выполнения 1 или S (или s). В этом режиме только системный администратор может подключиться к системе. Он используется для выполнения задач по обслуживанию без риска повреждения системы или пользовательских данных. Естественно, в такой конфигурации нам не следует предоставлять пользовательские службы, так что все они будут отключены. Другой уровень выполнения — это режим перезагрузки, или уровень 6, который завершает все запущенные службы, выполнив надлежащие процедуры, и перезагружает систему.</p>
<p>Используйте <strong>who</strong> для проверки, каким является ваш текущий уровень выполнения:</p>
<pre>
willy@ubuntu:~$ <strong>who -r</strong>
	run-level 2 2006-10-17 23:22		last=S
</pre><p>
Подробнее об уровнях выполнения в следующем разделе, см. <a href="http://younglinux.info/#">Раздел "Уровни выполнения Init"</a>.</p>
<p>После того, как для вашей системы определяется уровень выполнения по умолчанию, <strong>init</strong> запускает все фоновые процессы, необходимые для запуска системы, просматривая соответствующую для данного уровня выполнения директорию <span class="mono">rc</span>. <strong>init</strong> выполняет каждый kill-сценарий (их файловые имена начинаются с K) с параметром <span class="monoi">stop</span>. Затем он проходит все запускающие сценарии (их имена файлов начинаются с S) в соответствующем уровню выполнения каталоге, с тем, чтобы все службы и приложения запустились правильно. На самом деле вы вручную можете выполнить те же сценарии после того, как система завершит загрузку, командами подобными <strong>/etc/init.d/httpd</strong> <span class="monoi"> stop</span> или <strong>service</strong> <span class="monoi"> httpd stop</span>, войдя в систему с правами <em>root</em>; в этом случае останавливается веб-сервер.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Особый случай.</strong><br />
Обратите внимание, что при запуске операционной системы скрипты в <span class="mono">rc2.d</span> и <span class="mono">rc3.d</span>, как правило, выполняются. В этом случае, никакие службы не останавливаются (по крайней мере, не навсегда). Службы только запускаются.</p>
<p>Ни один из сценариев, которые фактически запускают и останавливают службы, не расположен в <span class="mono">/etc/rc<x>.d</x></span>. Вернее, все файлы в <span class="mono">/etc/rc<x>.d</x></span>. являются символическими ссылками, указывающими на реальные сценарии, находящихся в <span class="mono">/etc/init.d</span>. Символическая ссылка это не более чем файл, который указывает на другой файл; в данном случае они используются, т. к. их можно создавать и удалять без ущерба для фактических сценариев, завершающих или запускающих службы. Символические ссылки на различные сценарии нумеруются в определенном порядке, в таком порядке они и запускаются. Вы можете изменить порядок запуска и остановки служб, изменив названия символических ссылок, которые ссылаются на сценарий, который фактически управляют службами. Вы можете использовать один и тот же номер множество раз, если хотите, чтобы определенный сервис запускался или останавливался непосредственно перед или после другого; в примере ниже перечислено содержимое <span class="mono">/etc/rc5.d</span>, в котором у <strong>crond</strong> и <strong>xfs</strong> имя ссылки начинается с "S90". В этом случае, скрипты запускаются в алфавитном порядке.</p>
<pre>
[jean@blub /etc/rc5.d] ls
K15httpd@     K45named@    S08ipchains@  S25netfs@      S85gpm@
K16rarpd@     K46radvd@    S08iptables@  S26apmd@       S90crond@
K20nfs@       K61ldap@     S09isdn@      S28autofs@     S90xfs@
K20rstatd@    K65identd@   S10network@   S30nscd@       S95anacron@
K20rusersd@   K74ntpd@     S12syslog@    S55sshd@       S95atd@
K20rwalld@    K74ypserv@   S13portmap@   S56rawdevices@ S97rhnsd@
K20rwhod@     K74ypxfrd@   S14nfslock@   S56xinetd@     S99local@
K25squid@     K89bcm5820@  S17keytable@  S60lpd@
K34yppasswdd@  S05kudzu@    S20random@    S80sendmail@
</pre><p>
Затем <strong>init</strong> проходит через уровень выполнения, чтобы задать уровень по умолчанию,  сценарий <span class="mono">/etc/inittab</span> разветвляется процессом <strong>getty</strong> для каждой виртуальной консоли (приглашение на вход в текстовом режиме). <strong>getty</strong> открывает строки tty, устанавливает их режимы, печатает строку входа, получает имя пользователя, и затем начинает процесс входа для данного пользователя. Это позволяет пользователям представится системе и использовать ее. По умолчанию, большинство систем предлагают 6 виртуальных консолей, но, как вы можете увидеть из файла <span class="mono">inittab</span>, это можно изменить.</p>
<p><span class="mono">/etc/inittab</span> может также указать <strong>init</strong>, как тот должен обрабатывать пользовательское нажатие <strong>Ctrl + Alt + Delete</strong> в консоли. Поскольку система должна надлежащим образом выключаться и перезапускаться, а не прекращать немедленно работу, <strong>init</strong> сообщается выполнить команду <span class="mono">/sbin/shutdown -t3 -r now</span>, например, когда пользователь нажимает эти клавиши. Кроме того, <span class="mono">/etc/inittab</span> устанавливает, что <strong>init</strong> должен делать в случае отключения электропитания, если у вашей системы есть <span style="background-color:yellow;">UPS unit</span>, прикрепленный к ней.</p>
<p>В большинстве систем, основанных на RPM, графический экран для входа запускается на уровне выполнения 5, где <span class="mono">/etc/inittab</span> запускает скрипт под названием <span class="mono">/etc/X11/prefdm</span>. Скрипт <span class="mono">prefdm</span> преимущественно работает в графическом менеджере X, основываясь на содержимом каталога <span class="mono">/etc/sysconfig/desktop</span>. Это, как правило, <strong>gdm</strong>, если вы работаете на GNOME или <strong>kdm</strong>, если вы используете KDE, но они могут быть смешаны, кроме того, есть <strong>xdm</strong>, который предоставляется  при стандартной установке X.</p>
<p>Но есть и другие возможности. В Debian, например, есть initscript для каждого менеджера дисплея, и содержание <span class="mono">/etc/X11/default-display-manager</span> используется для определения того, какой из них запустить. Подробнее о графическом интерфейсе можно прочитать в <a href="http://younglinux.info/#">Разделе 7.3. "Графическая среда"</a>. В конечном счете, ваша системная документация разъяснит подробности высокоуровневых аспектов <strong>init</strong>.</p>
<p>Каталоги <span class="mono">/etc/default</span> и/или <span class="mono">/etc/sysconfig</span> содержат записи для целого ряда функций и служб, все это читается во время загрузки. Местонахождение директории, содержащей системные настройки по умолчанию, может несколько различаться в зависимости от вашего дистрибутива Linux.</p>
<p>Кроме того, графическая среда пользователя, ряд других служб могут быть запущены также. Но если все пойдет хорошо, то когда процесс загрузки завершается, вы видите приглашение для входа или графический экран для входа.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Другие процедуры. </strong><br />
Мы объяснили, как SysV <strong>init</strong> работ на базе x86. Запуск процедур может различаться на других архитектурах и дистрибутивах. Другие системы могут использовать BSD-стиль <strong>init</strong>, когда загрузочные файлы не разделяются на множество каталогов <span class="mono">/etc/rc<LEVEL>.d</level></span>. Также может оказаться, что ваша система использует <span class="mono">/etc/rc.d/init.d</span> вместо <span class="mono">/etc/init.d</span>.</p>
<h2>Уровни выполнения Init</h2>
<p>Идея функционирования различных служб на разных уровнях выполнения по существу вращается вокруг того факта, что различные системы могут быть использованы по-разному. Некоторые службы не могут быть использованы, пока система находится в определенном состоянии или режиме, таком как быть готовой к более чем одному пользователю или доступной сети.</p>
<p>Бывают периоды, в которые вы можете работать с системой в низкоуровневом режиме. Примеры: решение проблем испорченного диска на уровне выполнения 1, так чтобы у других пользователей не было возможности быть в системе, или оставить сервер на уровне выполнения 3 (без работающей X сессии). В этих случаях, функционирование сервисов, которые зависят от высокоуровневого режима системы, не имеет смысла, т. к. они не будут работать правильно в любом случае. Уже имеющимся службам назначается их запуск, когда будет достигнут определенный уровень выполнения; вы обеспечиваете последовательный запуск процессов, и вы можете быстро изменить режим машины, не беспокоясь о том, что вручную придется запускать и останавливать службы.</p>
<p>Доступные уровни выполнения, как правило, описаны в файле <span class="mono">/etc/inittab</span>, содержимое которого частично показано ниже:</p>
<pre>
#
# inittab   This file describes how the INIT process should set up
#           the system in a certain run-level.

# Default run level. The run levels are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS 
#	(The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
# 
id:5:initdefault:
&lt;--cut-->
</pre><p>
Вы можете настроить неиспользованные уровни выполнения (обычно уровень 4) как вы считаете нужным. Многие пользователи настраивают эти уровни выполнения, таким образом, который наиболее подходит для них, оставляя стандартные уровни, поскольку они существуют по умолчанию. Это позволяет им быстро входить в и выходить из их пользовательской конфигурации, не нарушая нормальной установки свойств на стандартных уровнях запуска.</p>
<p>Если ваша машина оказывается в ситуации, когда она не может загрузиться из-за испорченного <span class="mono">/etc/inittab</span> или не позволят вам войти, т.к. вы повредили файл <span class="mono">/etc/passwd</span> (или если вы просто забыли свой пароль), загрузитесь в однопользовательском режиме.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>  Без графики?</strong><br />
Когда вы работаете в текстовом режиме, т. к. не был предоставлен экран графического входа на вашей машине, обычно вы можете  переключаться на консоль 7. Если это не так, проверить текущий режим работы с помощью команды <strong>who</strong> <span class="mono"> -r</span>. Если он установлен на что-нибудь другое, чем есть оригинальные установки по умолчанию в <span class="mono">/etc/inittab</span>, то вероятно это может быть причина того, что система не запускается в графическом режиме по умолчанию. В таком случае обратитесь к системному администратору или прочитайте <strong>man</strong> <span class="mono"> init</span>. Заметим, что переключение режимов работы осуществляется преимущественно с использованием команды <strong>telinit</strong>; переключение из текстовой в графическую консоль или наоборот не подразумевает изменение режима выполнения.</p>
<p>Мы стараемся в данном руководстве обсуждать режимы выполнения, скрипты и конфигурации в общих чертах. Существует множество вариаций. Например, Gentoo Linux хранит скрипты в уровнях <span class="mono">/etc/run</span>. Другие системы могут запускаться через первый нижний режим выполнения и выполнить все сценарии в нем до прибытия конечного режима выполнения и исполнения его сценариев. Обратитесь к системной документации для получения дополнительной информации. Вы также можете прочитать скрипты, которые относятся к <span class="mono">/etc/inittab</span>, чтобы лучше понять, что происходит в вашей системе.</p>
<h3>Инструменты</h3>
<p>Если в вашей системе установлены утилиты <strong>chkconfig</strong> или <strong>update-rc.d</strong>, то они обеспечат простой инструмент командной строки для поддержания иерархии каталога <span class="mono">/etc/init.d</span>. Это освобождает системных администраторов от необходимости напрямую управлять многочисленные символическими ссылками в каталогах в <span class="mono">/etc/rc[x].d</span>.</p>
<p>Кроме того, некоторые системы предлагают инструмент <strong>ntsysv</strong>, который предоставляет текстовый интерфейс; вы можете сочти его легче в использовании, чем интерфейс командной строки <strong>chkconfig</strong>. В SuSE Linux, вы обнаружите инструменты <strong>yast</strong> и <strong>insserv</strong>. В Mandriva есть Mandriva Linux Control Center (Центр управления Mandriva Linux).</p>
<p>Большинство дистрибутивов обеспечивают графический пользовательский интерфейс для настройки процессов; обратитесь к вашей системной документации.</p>
<p>Все эти утилиты должны быть запущен под root. Системный администратор также может вручную создать соответствующие ссылки в каждом каталоге режима выполнения для того, чтобы запустить или остановить службы определенного режима.</p>
<h2>Shutdown – выключение</h2>
<p>UNIX была создана как система, которая не останавливается, но если вам это  действительно надо, используйте команду <strong>shutdown</strong>. Опция <span class="mono">-h</span> будет остановить систему, а <span class="mono">-r</span> будет перезагружать ее.</p>
<p>Команды <strong>reboot</strong> и <strong>halt</strong> теперь способны вызывать <strong>shutdown</strong>, когда система находится в режимах выполнения 1-5, и таким образом обеспечить надлежащее завершение ее работы, но это плохая привычка, поскольку не во всех версиях UNIX/Linux есть такая возможность.</p>
<p>Пока ваш компьютер сам не выключится, вы не должны выключать его, пока не увидите сообщение с указанием, что система остановилась или все процессы завершились, т. к. система должна отключить все разделы. Нетерпеливость может привести к потере данных.</p>
  </div>
<div id="node-210" class="section-3">
  <h1 class="book-heading">Управление процессами</h1>
  <h2>Работа для системного администратора</h2>
<p>Хотя управление системными ресурсами, включая процессы, является задачей местного системного администратора, но и обычному пользователю не повредит кое-что узнать об этом, особенно в той части, которая касается оптимального выполнения его или ее собственных процессов.</p>
<p>Мы немного расскажем на теоретическом уровне о производительности системы, но не будем касаться оптимизации оборудования и других продвинутых процедур. Вместо этого мы изучим насущные проблемы, с которыми сталкивается обычный пользователь, и действия, которые пользователь может предпринять для обеспечения оптимального использования имеющихся ресурсов. Как мы узнаем в следующем разделе, следует поразмыслить, прежде чем действовать.</p>
<p><strong>Рисунок 4.2. Ты не мог бы идти побыстрее?</strong></p>
<div style="text-align:center;"><img src="../../../img/linuxintro/trappen.png" width="497" height="526" alt="Пользователь хочет, чтобы процессы выполнялись быстрее." /></div>
<h2>Сколько времени это займет?</h2>
<p>Bash предоставляет встроенную команду <strong>time</strong>, которая отображает, сколько времени занимает выполнение команды. Она рассчитывает время с высокой точностью и может быть использована с любой командой. В примере ниже,  проходит около полторы минуты <span style="background-color:yellow;">to make this book</span>:</p>
<pre>
tilly:~/xml/src> <strong>time make</strong>
Output written on abook.pdf (222 pages, 1619861 bytes).
Transcript written on abook.log.

real	1m41.056s
user	1m31.190s
sys	0m1.880s
</pre><p>
Команда GNU <strong>time</strong> в <span class="mono">/usr/bin</span> (в отличие от версии, встроенной в shell) отображает больше информации, которая может быть отформатирована различными способами. Она также показывает статус завершения команды и общее истекшее время. Такая же команда, как выше, использующая независимый <strong>time</strong>, дает следующий вывод:</p>
<pre>
tilly:~/xml/src> <strong>/usr/bin/time make</strong>
Output written on abook.pdf (222 pages, 1595027 bytes).
Transcript written on abook.log.

Command exited with non-zero status 2
88.87user 1.74system 1:36.21elapsed 94%CPU 
				(0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (2192major+30002minor)pagefaults 0swaps
</pre><p>
Для получения полной информации снова обратитесь к info-страницам.</p>
<h2>Исполнение</h2>
<p>Для пользователей эффективность означает быстрое выполнение команд. Для системного администратора, с другой стороны, это означает гораздо больше: администратор оптимизирует производительность всей системы, включая пользователей, все программы и демоны. Производительность системы может зависеть от тысячи незначительных вещей, которые не учитываются командой <strong>time</strong>:</p>
<ul>
<li>выполняющаяся программа плохо написана или использует компьютер надлежащим образом</li>
<li>доступ к дискам, контроллерам, дисплею и всем другим видам интерфейсов</li>
<li>достижимость удаленных систем (производительность сети)</li>
<li>количество пользователей в системе, количество пользователей, одновременно работающих на самом деле.</li>
<li>время дня</li>
<li>...</li>
</ul>
<h2>Нагрузка</h2>
<p>Короче говоря, нагрузка зависит от того, что является нормальным для вашей системы. На моем старом P133 работает брандмауэр, SSH сервер, файловый сервер, служба маршрутизации, sendmail сервер, прокси сервер и некоторые другие службы, все они не жалуются на семь подключенных пользователей; нагрузка по-прежнему 0 или в пределах нормы. Некоторые (многопроцессорные) системы, которые я видела, были вполне счастливы с нагрузкой в 67. Существует только один способ узнать, что нагрузка нормальна, - это проверять ее регулярно. Если так не делать, вы только сможете оценить загрузку системы по времени отклика в командной строке, что является очень грубым измерением, поскольку эта скорость зависит от сотни других причин.</p>
<p>Имейте в виду, что разные системы будут вести себя по-разному с одной и той же средней нагрузкой. Например, системе с видеокартой, поддерживающей аппаратное ускорение, не будет иметь никаких проблем при прорисовке 3D изображений, в то же время в такой же системе с VGA видеокартой будет чрезвычайно замедленное время рендеринга. Мой старый P133 будет довольно неудобен, когда я запущу Х-сервер, но на современной системе вы вряд ли заметите разницу в нагрузке на систему.</p>
<h2>Я могу что-нибудь сделать как пользователь?</h2>
<p>Большое окружение замедляет работу. Если у вас установлено множество переменных окружения (вместо переменных оболочки), длинных путей поиска, которые не оптимизированы (ошибки в настройках переменной окружения PATH), и присутствует много настроек, которые обычно делаются "на лету", системе будет требоваться больше времени на поиск и чтение данных.</p>
<p>В X, оконные менеджеры и среды рабочего стола могут действительно «съедать» процессор. На самом деле приходится расплачиваться за фантастический рабочий стол, даже если вы можете скачать его бесплатно, поскольку большинство десктопов снабжаются дополнениями до бесконечности. Скромность окажется  добродетелью, если вы не покупаете новый компьютер каждый год.</p>
<h3>Приоритет</h3>
<p>Приоритет или важность работы определяется ее числом <em>nice</em>. Программа с большим nice-числом дружественна к другим программам, другим пользователям и системе; т.е. эта программа - не важное дело. Низкое nice-число обозначает более важное задание, которое потребует больше ресурсов, не делясь ими.</p>
<p>Улучшение выполнения задания за счет увеличения его nice-числа полезно только для процессов, которые используют много процессорного времени (компиляторы, математические приложения и т.п.). Процессы, которые постоянно обращаются к вводу/выводу имеют более высокий приоритет (низкое nice-число), например,  ввод с клавиатуры всегда получает наивысший приоритет в системе.</p>
<p>Определение приоритетов программ осуществляется с помощью команды <strong>nice</strong>.</p>
<p>Большинство систем также предоставляют команду BSD <strong>renice</strong>, которая позволяет изменять дружелюбность выполняющейся команды. Опять же, читайте man-страницы для получения системно-специфичной информации.</p>
<p class="note"><img src="../../../img/linuxintro/caution.gif" alt="" /><strong> Интерактивные программы.</strong><br />
Плохая идея, выполнять nice или renice по отношению к интерактивной программе или заданию, работающему на переднем плане.</p>
<p>Использование этих команд, как правило, является задачей системного администратора. Читайте man-страницы для дополнительной информации о дополнительной функциональности, доступной для системного администратора.</p>
<h3>Ресурсы процессора</h3>
<p>На каждой системе Linux множество программ одновременно нуждаются в ресурсах процессора(ов), даже в том случае, если вы являетесь единственным пользователем в системе. Каждая программа для работы нуждается в определенном количестве циклов центрального процессора. Бывают случаи, когда циклов процессора недостаточно, поскольку он слишком занят. Команда <strong>uptime</strong>  чрезвычайно неточна (отображает только средние, вы должны знать, что это нормально), но далеко не бесполезна. Есть некоторые действия, которые можно предпринять, если вы думаете, что ваш процессор является причиной зависания вашей системы:</p>
<ul>
<li>Выполняйте тяжелые программы, когда нагрузка невелика. Это можно делать в вашей системе в ночное время. См. следующий раздел про планирование.</li>
<li>Предотвращайте систему от выполнения ненужной работы: остановите демонов и программы, которые вы не используете, используйте <strong>locate</strong> вместо тяжелой <strong>find</strong>, ...</li>
<li>Выполняйте больше заданий с низким приоритетом.</li>
<li></li>
</ul>
<p>Если ни одно из этих решений не вариант в вашей конкретной ситуации, вы можете обновить процессор. На машине UNIX это работа для системного администратора.</p>
<h3>Ресурсы памяти</h3>
<p>Когда текущие работающие процессы ожидают больше памяти, чем доступно физически в системе, Linux не разрушится; она начнет подкачку или своппинг, смысл в том, что процесс использует память на диске или из пространства подкачки, перемещая содержимое физической памяти (части работающих программ или целых программ в случае своппинга) на диск, тем самым давая физической памяти обрабатывать несколько процессов. Это в достаточной степени замедляет работу системы, поскольку доступ к диску намного медленнее, чем доступ к памяти. Команда <strong>top</strong> может быть использована для отображения того,  насколько память и подкачка используются. Системы, использующие glibc, предлагают команды <strong>memusage</strong> и <strong>memusagestat</strong> для визуализации использования памяти.</p>
<p>Если вы обнаружите, что используется много памяти и пространства подкачки, вы можете попробовать:</p>
<ul>
<li>Прерывание, остановку или переопределение nice для тех программ, которые используют большую часть памяти.</li>
<li>Добавление дополнительной памяти (а в некоторых случаях больше пространства подкачки) системе.</li>
<li>Настройка производительности системы, что выходит за рамки этого документа. См. список в <a href="http://younglinux.info/#">Приложении А, «Куда идти дальше?»</a> за дополнением.</li>
</ul>
<h3>Ресурсы I/O (ввода/вывода)</h3>
<p>Хотя ограничения ввода-вывода являются основной причиной стресса системных администраторов, системы Linux предлагает довольно бедные утилиты для измерения I/O производительности. Инструменты <strong>ps</strong>, <strong>vmstat</strong> и <strong>top</strong> дают некоторое представление о том, сколько программ ждут ввода-вывода; <strong>netstat</strong> отображает интерфейс сетевой статистики, но в сущности нет инструментов нормального измерения I/O отклика при загрузке системы, а команда <strong>iostat</strong> дает краткий обзор общего I/O использования. Существуют различные графические приложения для отображения вывода этих команд в понятном виде.</p>
<p>Каждое устройство имеет свои собственные проблемы, но пропускная способность сетевых интерфейсов и пропускная способность дисков два основных узких места в производительности ввода-вывода.</p>
<p>Сетевые I/O проблемы:</p>
<ul>
<li>Сетевые перегрузки:</li>
</ul>
<p>Количество данных, передаваемых по сети больше возможностей сети, в результате медленное выполнение каждой связанной с сетью задачи для всех пользователей. Это может быть решено путем очистки сети (которая в основном заключается в отключении протоколов и услуг, которые вам не нужны), либо путем реконфигурации сети (например, использование подсетей, замена узлов с переключателями, модернизация интерфейсов и оборудования).</p>
<ul>
<li>Проблемы сетевой целостности:</li>
</ul>
<p>Случается, когда данные передаются неправильно. Решение такого рода проблем может быть выполнено только путем изоляции неисправного элемента и его заменой.</p>
<p>Дисковые I/O проблемы:</p>
<ul>
<li>для каждого процесса скорость передачи слишком низкая:</li>
</ul>
<p>Скорость чтения и записи для определенного процесса не является достаточной.</p>
<ul>
<li>совокупная скорость передачи слишком низкая:</li>
</ul>
<p>Максимум общей пропускной способности, которые система может обеспечить для всех выполняющихся программ, недостаточна.</p>
<p>Обнаружить такого рода проблемы сложнее, и обычно это требует дополнительное оборудование для того, чтобы разделить потоки данных по шинам, контроллерам и дискам, если причина проблемы — это перегрузка оборудования. Одним из решений этого является оптимизированная конфигурация RAID-массива для действий ввода-вывода. Так у вас появляется возможность остаться при том же оборудовании. Перед обновлением пропускной способности шин, контроллеров и дисков всегда можно попробовать другие варианты.</p>
<p>Если перегрузка не является причиной, может быть, ваше оборудование постепенно портится, или неправильно подключено к системе. Проверьте контакты, соединители и разъемы для начала.</p>
<h3>Пользователи</h3>
<p>Пользователи могут быть разделены на несколько классов в зависимости от их отношения к использованию ресурсов:</p>
<ul>
<li>Пользователи, которые запускают большое число маленьких заданий: вы, начинающий пользователь Linux, например.</li>
<li>Пользователи, которые запускают относительно немного, но больших заданий: пользователи, работающие с моделированием, расчетами, эмуляторами или другими программами, которые съедают много памяти, и обычно этих пользователей сопровождает большой объем файлов данных.</li>
<li>Пользователи, которые запускают немного заданий, но используют много процессорного времени (разработчики и т.п.).</li>
</ul>
<p>Вы можете видеть, что системные требования могут отличаться для каждого класса пользователей, и поэтому сложно удовлетворить каждого. Если вы работаете на многопользовательской системе, полезно (и приятно) узнать привычки других пользователей системы, с тем чтобы получить максимальную отдачу от ее для выполнения ваших конкретных задач.</p>
<h3>Графические инструменты</h3>
<p>Для графической среды доступен целый букет инструментов мониторинга. Ниже приведен снимок экрана Системного Монитора Gnome, который способен отображать и искать информацию о процессах и контролировать системные ресурсы:</p>
<p><strong>Рисунок 4.3. Системный Монитор Gnome</strong><br />
<img src="../../../img/linuxintro/system-monitor.png" width="465" height="527" alt="Системный монитор Gnome" /></p>
<p>Также существует несколько полезных иконок, которые вы можете установить на панели задач, таких как мониторы диска, памяти и загруженности. <strong>Xload</strong> - это другое небольшое приложение X для мониторинга загрузки системы. Определитесь сами со своими предпочтениями.</p>
<h3>Прерывание ваших процессов</h3>
<p>Как непривилегированный пользователь, вы можете влиять только на собственные процессы. Мы уже видели, как вы можете отображать процессы и отфильтровывать процессы, относящиеся к конкретному пользователю, а также знаете, какие могут  произойти возможные ограничения. Когда вы видите, что один из ваших процессов потребляет слишком много системных ресурсов, есть две вещи, которые вы можете сделать:</p>
<ul>
<li>Заставить процесс использовать меньше ресурсов, не прерывая его;</li>
<li>Остановить процесс вообще.</li>
</ul>
<p>В случае, если вы хотите, чтобы процесс продолжил работу, но также хотите дать шанс другим процессам в системе, вы можете переопределить <em>nice</em> процесса. Наряду с использованием команд <strong>nice</strong> или <strong>renice</strong>, <strong>top</strong> является простым способом обнаружения процесса(ов), причиняющего беспокойство, и снижения приоритета.</p>
<p>Узнайте процесс в столбце "NI", у него, скорее всего, будет отрицательный приоритет. Наберите r и введите ID процесса, для которого вы хотите переопределить число <em>nice</em>. Затем введите значение nice, например, "20". Это означает, что отныне этот процесс будет занимать самое большое 1/5 циклов процессора.</p>
<p>Примеры процессов, которые вы захотите сохранить в рабочем состоянии, — это эмуляторы, виртуальные машины, компиляторы и т.д.</p>
<p>Если вы хотите остановить процесс, потому что он висит или собирается полностью вывести из рабочего состояния ввод-вывод, создание файла или использование других ресурсов системы, используйте команду <strong>kill</strong>. Если у вас есть возможность, попробуйте сначала завершить процесс "по тихому", отправив ему сигнал SIGTERM. Это указание к прекращению любой активности в соответствии с процедурами, описанными в коде программы:</p>
<pre>
joe:~> <strong>ps -ef | grep <em>mozilla</em></strong>
joe    25822	1  0 Mar11 ?	00:34:04 /usr/lib/mozilla-1.4.1/mozilla-

joe:~> <strong>kill -15 <em>25822</em></strong>
</pre><p>
В приведенном выше примере, пользователь <em>joe</em> остановил его браузер Mozilla, поскольку он подвис.</p>
<p>От некоторых процессов избавиться немного труднее. Если у вас есть время, вы можете отправить им сигнал SIGINT, прервав их. Если этот трюк не сработает, используйте самый сильный сигнал SIGKILL. В приведенном ниже примере <em>joe</em> останавливается Mozilla, которая повисла окончательно:</p>
<pre>
joe:~> <strong>ps -ef | grep <em>mozilla</em></strong>
joe    25915	1  0 Mar11 ?	00:15:06 /usr/lib/mozilla-1.4.1/mozilla-

joe:~> <strong>kill -9 <em>25915</em></strong>

joe:~> <strong>ps -ef | grep <em>25915</em></strong>
joe	2634 32273 0 18:09 pts/4   00:00:00 grep 25915
</pre><p>
В таких случаях вы можете захотеть проверить, что этот процесс действительно прерван, используя фильтр <strong>grep</strong> опять же по PID. Если это возвращает только процесс <strong>grep</strong>, вы можете быть уверены, что вам удалось остановить тот процесс.</p>
<p>Среди процессов есть те, которые сложно прервать в вашей оболочке. И это хорошо: если бы их можно было легко прервать, то вы бы теряли вашу оболочку каждый раз при случайном вводе <strong>Ctrl-C</strong> в командной строке, т.к. это равносильно отправке SIGINT.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> UNIX без конвейеров почти немыслим.</strong><br />
Использование вертикальной черты (|) при использовании выводов одной команды в качестве входных данных другой объясняется в следующей главе, <a href="http://younglinux.info/#">Глава 5, "Перенаправление ввода-вывода"</a>.</p>
<p>В графической среде, программа <strong>xkill</strong> очень проста в использовании. Просто введите имя команды, затем нажмите Enter и выберите в окне приложение, которое вы хотите остановить. Это довольно опасно, потому что программа отправляет  SIGKILL по умолчанию, поэтому используйте ее, только когда приложение зависает.</p>
  </div>
<div id="node-211" class="section-3">
  <h1 class="book-heading">Планирование процессов</h1>
  <h2>Используйте незанятое время!</h2>
<p>Система Linux может выдерживать сильную нагрузку, но обычно перегружается только в рабочее время. Будь это офис, серверная комната или  дом, большинство систем Linux тратят попусту время утром, вечером, ночью и в выходные. Использование этого незанятого времени может быть намного дешевле, чем покупка компьютеров, которые вам точно потребуются, если вы захотите все делать в одно и то же время.</p>
<p>Существует три типа для задержки выполнения работ:</p>
<ul>
<li>Небольшое ожидание, а затем возобновление выполнения задания, это делается командой <strong>sleep</strong>. Время запуска задания зависит от системного времени в момент подачи команды.</li>
<li>Выполнение команды в определенное время, используя команду <strong>at</strong>. Выполнение задания(ий) зависит от системного времени, а не от времени подачи команды.</li>
<li>Регулярный запуск команд по месяцам, неделям, дням или часам основано на  использовании возможностей <strong>cron</strong>.</li>
</ul>
<p>В следующих разделах описывается каждая возможность.</p>
<h2>Команда sleep</h2>
<p>Info-страница о сне, вероятно, одна из самых коротких. Все, что <strong>sleep</strong> делает, это ждет. По умолчанию время ожидания выражается в секундах.</p>
<p>Так зачем же она нужна? Некоторые практические примеры:</p>
<p>Кто-то звонит вам по телефону, вы говорите "Да, мы встретимся через полчаса", но вы тонете в работе и забываете про свой ланч:</p>
<p><span class="mono">(sleep <em>1800</em>; echo <em>"Lunch time.."</em>) &amp;</span></p>
<p>Если вы не можете по какой-то причине использовать команду <strong>at</strong>, 5:00 часов, и вы хотите идти домой, но еще есть работа, которую предстоит сделать, а сейчас кто-то использует системные ресурсы:</p>
<p><span class="mono">(sleep <em>10000</em>; myprogram) &amp;</span></p>
<p>Убедитесь, что в вашей системе есть авто-выход, и что вы выходите из системы или блокируется ваш рабочий стол при подаче такого рода задания, или запустите ее в сессии.</p>
<p>Когда вы запускаете на распечатку ряд больших файлов, но вы хотите, чтобы другие пользователи имели возможность печати между ними:</p>
<p><span class="mono">lp lotoftext; sleep <em>900</em>; lp hugefile; sleep <em>900</em>; lp anotherlargefile</span></p>
<p>Печать файлов обсуждается в <a href="http://younglinux.info/#">Главе 8, Принтеры и печать</a>.</p>
<p>Программисты часто используют команду <strong>sleep</strong> для остановки выполнения скрипта или программы на определенное время.</p>
<h2>Команда at</h2>
<p>Команда <strong>at</strong> выполняет команды в данный момент времени, используя вашу оболочку по умолчанию, если вы не укажете команде иное (см. man-страницу).</p>
<p>Опции <strong>at</strong> достаточно понятны, что продемонстрировано в примере ниже:</p>
<pre>
steven@home:~> <strong>at tomorrow + 2 days</strong>
warning: commands will be executed using (in order) a) $SHELL
        b) login shell c) /bin/sh
at>  <strong>cat reports | mail myboss@mycompany</strong>
at> <EOT>
job 1 at 2001-06-16 12:36
</eot></pre><p>
Нажатие <strong>Ctrl + D</strong> завершает работу утилиты <strong>at</strong> и создает сообщение "EOT".</p>
<p>Пользователь <em>steven</em> делает здесь странные вещи, объединяя две команды; мы будем изучать подобную практику в <a href="http://younglinux.info/#">Главе 5, Перенаправление ввода-вывода</a>.</p>
<pre>
steven@home:~> <strong>at 0237</strong>
warning: commands will be executed using (in order) a) $SHELL
        b) login shell c) /bin/sh
at>  <strong>cd new-programs</strong>
at>  <strong>./configure; make</strong>
at> <EOT>
job 2 at 2001-06-14 02:00
</eot></pre><p>
Опция <span class="mono">-m</span> отправляет сообщение пользователю, когда задание выполнено, или разъяснение, когда работа не может быть сделана. Команда <strong>atq</strong> создает список заданий; выполните эту команду перед отправкой заданий в целях предотвращения их от запуска одновременно с другими. Командой <strong>atrm</strong> можно удалить запланированные задания, если вы изменили свою точку зрения.</p>
<p>Хорошая идея выбрать необычное время выполнения, потому что системные задания часто работают "круглые" часы, как вы можете увидеть в <a href="http://younglinux.info/#">Разделе "Cron и crontab"</a> далее. Например, задания часто запускаются ровно в 1:00 утра (например, системы, индексирующие обновление стандартной локальной базы данных), поэтому ввод времени 0100 легко может замедлить работу системы, а не увеличить ее. Чтобы предотвратить задания от запуска всех в одно и то же время, вы можете также использовать команду <strong>batch</strong>, которая ставит процессы в очередь и задает работу системе сбалансированным образом, предотвращая чрезмерные очереди использования системных ресурсов. Смотрите info-страницы для получения дополнительной информации.</p>
<h2>Cron и crontab</h2>
<p>Система <strong>cron</strong> находится под управлением демона cron. Он получает информацию из записей crontab системы и пользователей о том, какие программы и когда должны работать. Только пользователь root имеет доступ к системным crontab, в то время как у каждого пользователя должен быть доступ только к собственным crontab. На некоторых системах у (некоторых) пользователей отсутствует доступ к объекту cron.</p>
<p>При запуске системы демон cron ищет <span class="mono">/var/spool/cron/</span> на наличие записей crontab, названных в честь аккаунтов в <span class="mono">/etc/passwd</span>, он ищет <span class="mono">/etc/cron.d/</span> и <span class="mono">/etc/crontab</span>, а затем ежеминутно использует эту информацию для проверки, есть ли что-то что нужно сделать. Он выполняет команды от пользователя, который является собственником файла crontab и отправляет владельцу на mail все выданные команды.</p>
<p>В системах, использующих хрон Vixie, задания, которые выполняются ежечасно, ежедневно, еженедельно и ежемесячно хранятся в отдельной директории в <span class="mono">/etc</span> чтобы было легче просматривать. Это отличается от стандартной функции хрон UNIX, где все задачи вводятся в один большой файл.</p>
<p>Пример файла crontab Vixie:</p>
<pre>
[root@blob /etc]# <strong>more crontab</strong>
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
HOME=/

# run-parts
# commands to execute every hour
01 * * * * root run-parts /etc/cron.hourly
# commands to execute every day
02 4 * * * root run-parts /etc/cron.daily
# commands to execute every week
22 4 * * 0 root run-parts /etc/cron.weekly
commands to execute every month
42 4 1 * * root run-parts /etc/cron.monthly
</pre><p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>  Альтернатива. </strong><br />
Вы можете также использовать команду <strong>crontab -l</strong> для отображения всех файлов crontab.</p>
<p>После установки некоторых переменных, появляется текущее расписание, по одной строке на задание, начинающиеся с 5-ти полей даты и времени. Первое поле содержит минут (от 0 до 59), второе - определяет час исполнения (0-23), третее - день месяца (1-31), и, наконец, номер месяца (1-12) , последнее - день недели (0-7, где 0 и 7 - это воскресенье). Звездочка в этих полях обозначает общий предел для поля. Списки допускаются; для выполнения заданий с понедельника по пятницу введите 1-5 в последнем поле, чтобы выполнить работу в понедельник, среду и пятницу введите 1,3,5.</p>
<p>Затем указывается пользователь, который должен выполнить процессы, которые перечислены в последнем столбце. Пример выше из конфигурации хрона Vixie, где root запускает программу <strong>run-parts</strong> на регулярной основе с соответствующими каталогами в качестве опций. В этих каталогах фактические задания для выполнения в назначенное время хранятся в виде скриптов, как этот маленький скрипт, который выполняется ежедневно, чтобы обновить базу данных, используемую командой  <strong>locate</strong>:</p>
<pre>
billy@ahost cron.daily]$ <strong>cat slocate.cron</strong>
#!/bin/sh
renice +19 -p $$ >/dev/null 2>&1
/usr/bin/updatedb -f "nfs,smbfs,ncpfs,proc,devpts" -e \
"/tmp,/var/tmp, /usr/tmp,/afs,/net"
</pre><p>
Пользователи должны отредактировать для своих crontab безопасный способ использования команды <strong>crontab -e</strong>. Это позволит предотвратить пользователя от случайного открытия более чем одной копии его/ее файла crontab. По умолчанию предоставлен редактор <strong>vi</strong> (см. <a href="http://younglinux.info/#">Главу 6, Текстовые редакторы</a>), но вы можете использовать любой текстовый редактор, такой как <strong>gvim</strong> или <strong>gedit</strong>, если вам более комфортно с редактором GUI.</p>
<p>При выходе система сообщит вам, что установлен новый crontab.</p>
<p>Эта запись crontab напоминает <em>billy</em> пойти в его спортивный клуб каждый вечер четверга:</p>
<pre>
billy:~> <strong>crontab -l</strong>
# DO NOT EDIT THIS FILE - edit the master and reinstall.
# (/tmp/crontab.20264 installed on Sun Jul 20 22:35:14 2003)
# (Cron version -- $Id: chap4.xml,v 1.28 2007/09/19 12:22:26 tille Exp $)
38 16 * * 3 mail -s "sports evening" billy
</pre><p>
После добавления нового запланированного задания, система сообщит вам, что новый crontab установлен. Вам не нужно перезапустить демон <strong>cron</strong>, чтобы изменения вступили в силу. В примере <em>billy</em> добавил новую строку, указывающую на сценарий резервного копирования:</p>
<pre>
billy:~> <strong>crontab -e</strong>
45 15 * * 3 mail -s "sports evening" billy
4 4 * * 4,7 /home/billy/bin/backup.sh

&lt;--write and quit-->

crontab: installing new crontab

billy:~>
</pre><p>
Скрипт <span class="mono">backup.sh</span> запускается каждые четверг и воскресенье. См. <a href="http://younglinux.info/#">Раздел "Сценарии оболочки"</a> для введения в написание скриптов для оболочки. Имейте в виду, что вывод команд, если таковые имеются, отправляются по почте владельцу файла crontab. Если почтовая служба не настроена, можно найти вывод ваших команд в вашем локальном почтовом ящике, <span class="mono">/var/spool/mail/<your_username></your_username></span>, в виде обычного текстового файла.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>  Кто запускает мои команды?</strong><br />
Вы не можете устанавливать пользователей, которые должны выполнять команды. Они выполняются с полномочиями пользователя по умолчанию.</p>
  </div>
<div id="node-212" class="section-3">
  <h1 class="book-heading">Резюме</h1>
  <p>Linux является многопользовательской и многозадачной операционной системой с UNIX-подобным способом управления процессами. Скорость выполнения команд может зависеть от тысячи незначительных факторов. Среди прочего мы узнали много новых команд для отображения процессов и их управления. Вот список:</p>
<table class="il">
<tr>
<td width="200"><strong>Команда</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td><strong>at</strong></td>
<td>Очередь заданий для последующего выполнения.</td>
</tr>
<tr>
<td><strong>atq</strong></td>
<td>Списки ожидающих заданий пользователей.</td>
</tr>
<tr>
<td><strong>atrm</strong></td>
<td>Удаление заданий, определяется их номера.</td>
</tr>
<tr>
<td><strong>batch</strong></td>
<td>Выполнение команд, когда позволяет уровень загруженности системы</td>
</tr>
<tr>
<td><strong>crontab</strong></td>
<td>Сохранение crontab'ов для индивидуальных пользователей</td>
</tr>
<tr>
<td><strong>halt</strong></td>
<td>Остановка системы</td>
</tr>
<tr>
<td><strong>init <span class="mono">run level</span></strong></td>
<td>Контроль процесса инициализации</td>
</tr>
<tr>
<td><strong>jobs</strong></td>
<td>Списки текущих выполняющихся работ</td>
</tr>
<tr>
<td><strong>kill</strong></td>
<td>Завершение процесса</td>
</tr>
<tr>
<td><strong>mesg</strong></td>
<td>Управление доступом на запись в вашем терминале.</td>
</tr>
<tr>
<td><strong>netstat</strong></td>
<td>Отображение сетевых подключений, таблиц маршрутизации, статистики интерфейсов и др.</td>
</tr>
<tr>
<td><strong>nice</strong></td>
<td>Запуск программы с измененным приоритетом.</td>
</tr>
<tr>
<td><strong>pgrep</strong></td>
<td>Отображение процессов</td>
</tr>
<tr>
<td><strong>ps</strong></td>
<td>Отчет о статусе процесса</td>
</tr>
<tr>
<td><strong>pstree</strong></td>
<td>Отображение дерева процессов</td>
</tr>
<tr>
<td><strong>reboot</strong></td>
<td>Остановка системы</td>
</tr>
<tr>
<td><strong>renice</strong></td>
<td>Изменение приоритета запущенных процессов</td>
</tr>
<tr>
<td><strong>shutdown</strong></td>
<td>Отключение системы</td>
</tr>
<tr>
<td><strong>sleep</strong></td>
<td>Задержка в течение определенного времени.</td>
</tr>
<tr>
<td><strong>time</strong></td>
<td>Команда времени или отчет использования ресурсов</td>
</tr>
<tr>
<td><strong>top</strong></td>
<td>Отображение процессов главного центрального процессора</td>
</tr>
<tr>
<td><strong>uptime</strong></td>
<td>Отображает, как долго система работает</td>
</tr>
<tr>
<td><strong>vmstat</strong></td>
<td>Отчет статистики виртуальной памяти</td>
</tr>
<tr>
<td><strong>w</strong></td>
<td>Показывает, кто вошел в систему, и что они делают.</td>
</tr>
<tr>
<td><strong>wall</strong></td>
<td>Отправка сообщения всем терминалам</td>
</tr>
<tr>
<td><strong>who</strong></td>
<td>Показывает, кто вошел в систему</td>
</tr>
<tr>
<td><strong>write</strong></td>
<td>Отправка сообщения другому пользователю</td>
</tr>
</table>
  </div>
<div id="node-213" class="section-3">
  <h1 class="book-heading">Упражнения</h1>
  <h2>Основное</h2>
<p>Вот некоторые упражнения, которые помогут вам ощутить процессы, запущенные в вашей системе.</p>
<ul>
<li>Выполните <strong>top</strong> в одном терминале, пока вы делаете упражнения в другом.</li>
<li>Выполнить команду <strong>ps</strong>.</li>
<li>Прочитайте man-страницы, чтобы узнать, как отобразить все ваши процессы.</li>
<li>Выполните команду <strong>find /</strong>. Какой эффект это окажет на загруженность системы? Остановите эту команду.</li>
<li>В графическом режиме запустите программу <strong>xclock</strong> на переднем плане. Затем отправьте ее работать в фоновый режим. Остановите программу, используя команду <strong>kill</strong>.</li>
<li>Выполните <strong>xcalc</strong> сразу в фоновом режиме для того, чтобы приглашение терминала было доступно снова.</li>
<li>Что делает <strong>kill -9 -1</strong>?</li>
<li>Откройте два терминала или терминальных окна снова и используйте write для отправки сообщения с одного на другой.</li>
<li>Выдайте команду <strong>dmesg</strong>. Что она сообщает?</li>
<li>Сколько времени занимает выполнение <strong>ls</strong> в текущем каталоге?</li>
<li>На основе записей процессов в <span class="mono">/proc</span>, принадлежащих вашей UID, чтобы вы сделали с целью узнать, какие из этих процессов действительно представлены?</li>
<li>Как долго ваша система была запущена?</li>
<li>Какой ваш текущий TTY?</li>
<li>Название 3-х процессов, которые не могут иметь <strong>init</strong> в качестве первоначального родителя.</li>
<li>Название 3-х команд, которые используют режим SUID. Объясните, почему это так.</li>
<li>Название команд, которые, как правило, приводят к самой высокой загруженности вашей системы.</li>
</ul>
<h2>Загрузка, инициализация и т.д.</h2>
<ul>
<li>Вы можете перезагрузить систему как обычный пользователь? Почему это так?</li>
<li>В соответствии с вашим текущим уровнем выполнения перечислите шаги завершения работы.</li>
<li>Как вы измените системный уровень выполнения? Перейдите с вашего уровня выполнения по умолчанию на уровень 1 и обратно.</li>
<li>Составьте список всех служб и демонов, которые запущены, когда ваша система загрузилась.</li>
<li>Какое ядро в текущий момент загружается при старте?</li>
<li>Предположим, что вы должны запустить некие экзотические службы во время загрузки. До этого вы заходили в систему после ее загрузки и запускали эти службы вручную, используя сценарий под названием <span class="mono">deliver_pizza</span> в вашем домашнем каталоге. Что вы сделаете для того, чтобы запустить службы автоматически на уровне выполнения 4, который вы определили только для этой цели?</li>
</ul>
<h2>Планирование</h2>
<ul>
<li>Используйте <strong>sleep</strong> для создания напоминания, что ваша паста готова через 10 минут.</li>
<li>Задайте <strong>at</strong> задание, которое копирует все файлы в домашней директории в <span class="mono">/var/tmp</span> в течение получаса. Вы можете создать подкаталог в <span class="mono">/var/tmp</span>.</li>
<li>Создайте cronjob, который решает эту задачу с понедельника по пятницу в обед.</li>
<li>Убедитесь, что он работает.</li>
<li>Сделать ошибку в записи crontab как выдача несуществующей команды <strong>coppy</strong> вместо <strong>cp</strong>. Что произойдет при выполнении задачи?</li>
</ul>
  </div>
</div>
    </div>
  </body>
</html>
