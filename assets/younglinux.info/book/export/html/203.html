<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Управление файлами</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
              <div class="section-1">
                <div class="section-2">
          
    <div id="node-203" class="section-3">
  <h1 class="book-heading">Управление файлами</h1>
  <h2>Просмотр свойств файла</h2>
<h3>Дополнительная информация о ls</h3>
<p>Помимо имени файла команда <strong>ls</strong> может дать много другой информации, например, тип файла (это мы уже обсуждали). Она может также показать права доступа к файлу, его размер, номер индексного дескриптора, дату и время создания, владельцев и количество ссылок на файл. Также использование <strong>ls</strong> вместе с опцией <span class="mono">-a</span> может отобразить файлы, обычно скрытые от глаз. Имена таких файлов начинается с точки. Типичный пример — это конфигурационные файлы в вашем домашнем каталоге. Когда вы проработаете в определенной системе некоторое время, то заметите, что были созданы десятки файлов и каталогов, <span style="background-color:yellow;">that are not automatically listed in a directory index</span>. Наряду с этим, каждый каталог содержит файл, именуемый просто точкой (.) и один с двумя точками (..), которые используются в сочетании с номером их индексного дескриптора для определения расположения каталога в древовидной структуре файловой системы.</p>
<p>Вам действительно следует прочитать страницы info о команде <strong>ls</strong>, так как это часто используемая команда с большим количеством полезных опций. Опции могут быть скомбинированы, как и в случае с большинством команд UNIX и их параметрами. Часто используемая комбинация <strong>ls</strong> <span class="mono"> -al</span>; она отображает длинный список файлов и их свойств, а также пути, на которые указывают символические ссылки. <strong>ls </strong> <span class="mono"> -latr</span> отображает те же файлы, только теперь в обратном порядке по признаку последнего изменения, так что файл, измененный в самое последнее время, находится в нижней части списка. Вот несколько примеров:</p>
<pre>
krissie:~/mp3> <strong>ls</strong>
Albums/  Radio/  Singles/  gene/  index.html

krissie:~/mp3> <strong>ls -a</strong>
./   .thumbs  Radio     gene/
../  Albums/  Singles/  index.html

krissie:~/mp3> <strong>ls -l Radio/</strong>
total 8
drwxr-xr-x    2 krissie krissie  4096 Oct 30  1999 Carolina/
drwxr-xr-x    2 krissie krissie  4096 Sep 24  1999 Slashdot/

krissie:~/mp3> <strong>ls -ld Radio/</strong>
drwxr-xr-x    4 krissie krissie  4096 Oct 30  1999 Radio/

krissie:~/mp3> <strong>ls -ltr</strong>
total 20
drwxr-xr-x    4 krissie krissie  4096 Oct 30  1999 Radio/
-rw-r--r--    1 krissie krissie   453 Jan  7  2001 index.html
drwxrwxr-x   30 krissie krissie  4096 Oct 20 17:32 Singles/
drwxr-xr-x    2 krissie krissie  4096 Dec  4 23:22 gene/
drwxrwxr-x   13 krissie krissie  4096 Dec 21 11:40 Albums/
</pre><p>
В большинстве версий Linux <strong>ls</strong> является псевдонимом «цветного <strong>ls</strong>» по умолчанию. Это свойство позволяет увидеть тип файла без использования какой-либо опции <strong>ls</strong>. Для достижения этого каждому типу файла присваивается свой собственный цвет. Стандартная схема находится в <span class="mono">/etc/DIR_COLORS</span>:</p>
<p><strong>Таблица 3.5. Цветовая схема color-ls по умолчанию</strong></p>
<table class="il">
<tr>
<td width="100"><strong>Цвет</strong></td>
<td><strong>Тип файла</strong></td>
</tr>
<tr>
<td>Голубой</td>
<td>каталоги</td>
</tr>
<tr>
<td>Красный</td>
<td>сжатые архивы</td>
</tr>
<tr>
<td>Белый</td>
<td>текстовые файлы</td>
</tr>
<tr>
<td>Розовый</td>
<td>изображения</td>
</tr>
<tr>
<td>Голубой</td>
<td>ссылки</td>
</tr>
<tr>
<td>Желтый</td>
<td>устройства</td>
</tr>
<tr>
<td>Зеленый</td>
<td>исполняемые файлы</td>
</tr>
<tr>
<td>Мигающий красный</td>
<td>неисправные ссылки</td>
</tr>
</table>
<p>Больше информации найдется на man-странице. В прежние дни та же информация отображалась с помощью суффиксов для каждого имени нестандартного файла. При использовании моно-цвета (например, печати списка содержимого каталога) и для общей очевидности эта схема используется до сих пор:</p>
<p><strong>Таблица 3.6. Схема суффиксов по умолчанию для команды ls </strong></p>
<table class="il">
<tr>
<td width="100"><strong>Символ</strong></td>
<td><strong>Тип файла</strong></td>
</tr>
<tr>
<td>Ничего</td>
<td>Обычный файл</td>
</tr>
<tr>
<td>/</td>
<td>Каталог</td>
</tr>
<tr>
<td>*</td>
<td>Исполняемый файл</td>
</tr>
<tr>
<td>@</td>
<td>Ссылка</td>
</tr>
<tr>
<td>=</td>
<td>Сокет</td>
</tr>
<tr>
<td>|</td>
<td>Именованный канал</td>
</tr>
</table>
<p>Полное описание функциональности и особенностей команды <strong>ls</strong> можно узнать с помощью <strong>info </strong> <span class="monoi"> coreutils ls</span>.</p>
<h3>Дополнительные инструменты</h3>
<p>Чтобы узнать больше о типе данных, с которыми имеем дело, мы используем команду <strong>file</strong>. Применяя определенные тесты, которые проверяют свойства файла в файловой системе, «магические числа» и делают «лингвистические пробы», <strong>file</strong> пытается догадаться о формате файла. Вот некоторые примеры:</p>
<pre>
mike:~> <strong>file Documents/</strong>
Documents/: directory

mike:~> <strong>file high-tech-stats.pdf</strong>
high-tech-stats.pdf: PDF document, version 1.2

mike:~> <strong>file Nari-288.rm</strong>
Nari-288.rm: RealMedia file

mike:~> <strong>file bijlage10.sdw</strong>
bijlage10.sdw: Microsoft Office Document

mike:~> <strong>file logo.xcf</strong>
logo.xcf: GIMP XCF image data, version 0, 150 x 38, RGB Color

mike:~> <strong>file cv.txt</strong>
cv.txt: ISO-8859 text

mike:~> <strong>file image.png</strong>
image.png: PNG image data, 616 x 862, 8-bit grayscale, non-interlaced

mike:~> <strong>file figure</strong>
figure: ASCII text

mike:~> <strong>file me+tux.jpg</strong>
me+tux.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI),
            "28 Jun 1999", 144 x 144

mike:~> <strong>file 42.zip.gz</strong>
42.zip.gz: gzip compressed data, deflated, original filename,
         `42.zip', last modified: Thu Nov  1 23:45:39 2001, os: Unix

mike:~> <strong>file vi.gif</strong>
vi.gif: GIF image data, version 89a, 88 x 31

mike:~> <strong>file slide1</strong>
slide1: HTML document text

mike:~> <strong>file template.xls</strong>
template.xls: Microsoft Office Document

mike:~> <strong>file abook.ps</strong>
abook.ps: PostScript document text conforming at level 2.0

mike:~> <strong>file /dev/log</strong>
/dev/log: socket

mike:~> <strong>file /dev/hda</strong>
/dev/hda: block special (3/0)
</pre><p>
Команда <strong>file</strong> имеет ряд опций, в частности <span class="mono">-z</span>, которая просматривает сжатые файлы. Чтобы получить более детальное описание, посмотрите <strong>info </strong> <span class="monoi"> file</span>. Имейте в виду, что результаты выполнения команды <strong>file</strong> не являются абсолютно достоверными, это только предположение. Другими словами, <strong>file</strong> может ошибиться.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Зачем весь этот шум о типах файлов и форматах?</strong><br />
В ближайшее время мы обсудим пару инструментов командной строки для просмотра текстовых файлов. Эти инструменты не будут работать при использовании «неправильного» типа файла. В худшем случае, они создадут аварийную ситуацию в вашем терминале и/или приведут к возникновению множества звуковых сигналов. Если у вас это случится, просто закройте сеанс терминала и начните новый. Но постарайтесь избегать этого, т.к. обычно это нервирует других людей.</p>
<h2>Создание и удаление файлов и каталогов</h2>
<h3>Создание беспорядка...</h3>
<p>... к этому легко придти. На сегодняшний день практически каждая система работает в сети, поэтому естественно файлы копируются с одного компьютера на другой. Особенно это происходит при работе в графической среде, где создание новых файлов часто происходит без согласия пользователя. Для иллюстрации этой проблемы здесь полное содержимое каталога нового пользователя, созданного на стандартной системе RedHat:</p>
<pre>
[newuser@blob user]$ <strong>ls -al</strong>
total 32
drwx------   3 user 	user        4096 Jan 16 13:32 .
drwxr-xr-x   6 root     root        4096 Jan 16 13:32 ..
-rw-r--r--   1 user 	user      24 Jan 16 13:32 .bash_logout
-rw-r--r--   1 user 	user     191 Jan 16 13:32 .bash_profile
-rw-r--r--   1 user 	user     124 Jan 16 13:32 .bashrc
drwxr-xr-x   3 user 	user    4096 Jan 16 13:32 .kde
-rw-r--r--   1 user 	user    3511 Jan 16 13:32 .screenrc
-rw-------   1 user 	user      61 Jan 16 13:32 .xauthDqztLr
</pre><p>
Также на первый взгляд содержание "используемого" домашнего каталога не выглядит так плохо:</p>
<pre>
olduser:~> <strong>ls</strong>
app-defaults/ crossover/   Fvwm@     mp3/      OpenOffice.org638/
articles/     Desktop/     GNUstep/  Nautilus/ staroffice6.0/
bin/          Desktop1/    images/   nqc/      training/
brol/         desktoptest/ Machines@ ns_imap/  webstart/
C/            Documents/   mail/     nsmail/   xml/
closed/       Emacs@       Mail/     office52/ Xrootenv.0
</pre><p>
Но если учесть все каталоги и файлы, начинающиеся с точки, то в данном каталоге уже обнаруживается 185 объектов. Причина этого в том, что у большинства приложений есть их собственные каталоги и/или файлы в домашнем каталоге этого пользователя, содержащие пользовательские настройки. Как правило, эти файлы создаются при первом запуске приложения. В некоторых случаях вы будете уведомлены, когда несуществующая директория должна быть создана, но по большей части все будет делаться автоматически.</p>
<p>К тому же новые файлы создаются, по-видимому, беспрерывно, потому что пользователи хотят сохранять файлы, хранить различные версии своих работ, использовать интернет-приложения, а также загружать файлы и сопутствующие материалы на их локальный компьютер. Это не остановить. Ясно одно, безусловно потребуются инструменты для сохранения порядка.</p>
<p>В следующем разделе мы обсудим имеющиеся средства для поддержания порядка. Мы только обсуждаем текстовые инструменты доступные в shell, поскольку графические инструменты интуитивны, выглядят и ощущаются также как известный метод «указать-и-щелкнуть» файлового менеджера MS Windows, в том числе графические функции помощи и другие свойства, которые вы ожидаете от такого рода приложений. Ниже приведен обзор наиболее популярных файловых менеджеров для GNU/Linux. Большинство файловых менеджеров могут быть запущены из меню вашей графической среды, щелчком по иконке домашнего каталога или из командной строки с помощью приведенных команд:</p>
<p><noindex></noindex></p>
<ul>
<li><strong>nautilus</strong>. Файловый менеджер Gnome (графической среды GNU) по умолчанию. Отличную документацию о работе с этим инструментом можно найти на http://www.gnome.org.</li>
<li><strong>konqueror</strong>. Файловый менеджер, обычно используемый в графической среде KDE. Пособие есть на http://docs.kde.org.</li>
<li><strong>mc</strong>. Midnight Commander, файловый менеджер Unix по образу Norton Commander. Вся документация доступна на http://gnu.org/directory/  или через зеркало, такое как http://www.ibiblio.org.</li>
</ul>
<p></p>
<p>Несомненно эти приложения стоит попробовать, и они обычно впечатляют новичков Linux даже тем, что существует такой широкий выбор: это только самые популярные инструменты для управления каталогами и файлами, также многие другие проекты находятся в разработке. Теперь давайте выясним, что за всем этим стоит, и посмотрим, как эти графические инструменты используют стандартные команды UNIX.</p>
<h3>Инструменты</h3>
<h4>Создание каталогов</h4>
<p>Способ хранения объектов на своих местах - это помещение определенных файлов в специально для них созданные каталоги и подкаталоги (или, если хотите, папки и подпапки). Это делается с помощью команды <strong>mkdir</strong>:</p>
<pre>
richard:~> <strong>mkdir archive</strong>

richard:~> <strong>ls -ld archive</strong>
drwxrwxrwx  2 richard richard           4096 Jan 13 14:09 archive/
</pre><p>
Создание каталогов и подкаталогов за один шаг делается с помощью опции <span class="mono">-p</span>:</p>
<pre>
richard:~> <strong>cd archive</strong>

richard:~/archive> <strong>mkdir 1999 2000 2001</strong>

richard:~/archive> <strong>ls</strong>
1999/  2000/  2001/

richard:~/archive> <strong>mkdir 2001/reports/Restaurants-Michelin/</strong>
mkdir: cannot create directory `2001/reports/Restaurants-Michelin/':
No such file or directory

richard:~/archive> <strong>mkdir -p 2001/reports/Restaurants-Michelin/</strong>

richard:~/archive> <strong>ls 2001/reports/</strong>
Restaurants-Michelin/
</pre><p>
Если у нового файла должны быть другие права, чем те, что присваиваются по умолчанию при его создании, то новые права доступа могут быть установлены одним движением,  также используя команду <strong>mkdir</strong>, см. страницы info для дополнительной информации. Мы собираемся обсудить режимы доступа в следующем разделе, посвященном безопасности файлов.</p>
<p>Имя каталога должно соответствовать тем же нормам, которые применяются для имен обычных файлов. Одним из наиболее важных ограничений является то, что у вас не может быть двух файлов с одинаковым названием в одном каталоге (но имейте в виду, операционная система Linux, как и UNIX, чувствительна к регистру). В сущности нет никаких ограничений на длину имени файла, но обычно оно содержит меньше, чем 80 символов, т. е. может поместиться в одной строке терминала. Вы можете использовать в имени файла любой символ, который вам захочется, хотя рекомендуется исключить символы, которые имеют специальное значение для оболочки. При сомнении сверьтесь с <a href="http://younglinux.info/#">Приложением C, Особенности Shell.</a></p>
<h4>Перемещение файлов</h4>
<p>Теперь, когда мы должным образом создали структуру в нашем домашнем каталоге, настало время уборки «несекретных» файлов с использованием команды <strong>mv</strong>:</p>
<pre>
richard:~/archive> <strong>mv ../report[1-4].doc reports/Restaurants-Michelin/</strong>
</pre><p>
Эта же команда используется для переименования файлов:</p>
<pre>
richard:~> <strong>ls To_Do</strong>
-rw-rw-r--    1 richard richard      2534 Jan 15 12:39 To_Do

richard:~> <strong>mv To_Do done</strong>

richard:~> <strong>ls -l done</strong>
-rw-rw-r--    1 richard richard      2534 Jan 15 12:39 done
</pre><p>
Очевидно, что изменяется только имя файла. Все остальные свойства остаются неизменными.</p>
<p>Подробные сведения о синтаксисе и особенностях команды <strong>mv</strong> можно найти в man или info-страницах. Использование данной документации должно всегда быть вашим первым рефлексом при столкновении с проблемой. Вероятно ответ на ваш вопрос найдется в системной документации. Даже опытные пользователи читают man-страницы каждый день, поэтому начинающим пользователям следует читать их все время. Через некоторое время, вы узнаете, наиболее распространенные опции к часто используемым командам, но вам все равно будет нужна документация как основной источник информации. Обратите внимание, что информация, содержащаяся в HOWTO, FAQ, man-страницах и других источниках постепенно сливается на страницах info, которые на сегодняшний день являются наиболее современными источниками online-документации (также как и легко доступным в системе).</p>
<h4>Копирование файлов</h4>
<p>Копирование файлов и каталогов осуществляется с помощью команды <strong>cp</strong>. Есть полезная опция рекурсивного копирования (копирования всех файлов и подкаталогов), используйте опцию <span class="mono">-R</span> команды <strong>ср</strong>. Общий синтаксис</p>
<p><span class="mono">cp [-R] fromfile tofile </span></p>
<p>В качестве примера рассмотрим случай пользователя <em>newguy</em>, который захотелось иметь такие же настройки рабочего стола Gnome, какие есть у пользователя <em>oldguy</em>. Одним из способов решения проблемы является копирование настроек <em>oldguy</em> в домашний каталог <em>newguy</em>:</p>
<pre>
victor:~> <strong>cp -R ../oldguy/.gnome/ .</strong>
</pre><p>
Это выдает некоторые ошибки, связанные с разрешением на файлы, но все эти ошибки связаны с личными файлами, в которых <em>newguy</em> в любом случае не нуждается. В следующем разделе мы обсудим, как изменить эти разрешения, если это действительно является проблемой.</p>
<h4>Удаление файлов</h4>
<p>Используйте команду rm для удаления отдельных файлов, <strong>rmdir</strong> для удаления пустых каталогов. (Используйте <strong>ls </strong> <span class="mono"> -a</span> для проверки пуст каталог или нет). Команда <strong>rm</strong> также имеет опции для удаления непустых каталогов со всеми их подкаталогами, но об этих опасных опциях читайте, пожалуй, info-страницы.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Как пустота может быть каталогом? </strong><br />
Это нормально, что каталоги . (точка) и .. (точка-точка) не могут быть удалены, т.к. они также являются необходимыми в пустой директории для определения расположения каталогов в иерархии файловой системы.</p>
<p>В Linux, как и в UNIX, нет мусорных ящиков, по крайней мере, для shell, хотя есть множество решений для графического использования. Так однажды удаленный, файл действительно исчезает, и, как правило, уже нет возможности вернуть его обратно, кроме случаев, когда у вас есть резервные копии, или вы очень быстры и у вас действительно хороший системный администратор. Чтобы защитить начинающих пользователей от этой напасти, интерактивное поведение команд <strong>rm, cp</strong> и <strong>mv</strong> может быть запущено с помощью опции <span class="mono">-i</span>. В этом случае система не будет сразу действовать после запроса. Вместо этого, появится запрос на подтверждение, что потребует дополнительного нажатия клавиши Enter для причинения вреда:</p>
<pre>
mary:~> <strong>rm -ri archive/</strong>
rm: descend into directory `archive'? y
rm: descend into directory `archive/reports'? y
rm: remove directory `archive/reports'? y
rm: descend into directory `archive/backup'? y
rm: remove `archive/backup/sysbup200112.tar'? y
rm: remove directory `archive/backup'? y
rm: remove directory `archive'? Y
</pre><p>
Мы обсудим, как сделать это опцией по умолчанию в <a href="http://younglinux.info/#">Главе 7, «Дом сладкий /home»</a>, в которой обсуждается настройка окружения вашей оболочки.</p>
<h2>Поиск файлов</h2>
<h3>Использование возможностей shell</h3>
<p>В приведенном ранее примере перемещения файлов мы уже видели, как shell может манипулировать сразу несколькими файлами. В том примере оболочка автоматически понимает, что пользователь имел ввиду требованием между квадратными скобками "[" и "]". Оболочка может заменить диапазоны номеров, а также прописных или строчных буквы. Она также заменяет звездочку на любое количество символов и знак вопроса на любой один.</p>
<p>Все виды замещения могут быть использованы одновременно; оболочка очень последовательна в этом. Оболочка Bash, например, не имеет никаких проблем с такими выражениями как <strong>ls </strong> <span class="monoi"> dirname/*/*/*[2-3]</span>.</p>
<p>В других оболочках, звездочка обычно используется, чтобы свести к минимуму усилия ввода: можно ввести <strong>cd</strong> <span class="monoi"> dir*</span> вместо <strong>cd</strong> <span class="monoi"> directory</span>. В Bash однако, это не является необходимым, поскольку у оболочки GNU есть свойство, называемое автозавершением имени файла. Это означает, что вы можете набрать первые несколько символов команды или файла (в текущем каталоге), и если никакой путаницы не может быть, оболочка поймет, что вы имеете в виду. Например, в каталоге, содержащем много файлов, вы можете проверить, если ли какие-нибудь файлы, начинающиеся с буквы A просто набрав <strong>ls</strong> <span class="mono">A</span> и нажать клавишу <strong>Tab</strong> дважды, вместо нажатия <strong>Enter</strong>. Если только один файл начинается с "А", то этот файл немедленно отобразится в качестве аргумента <strong>ls</strong> (или любой другой команды оболочки, если на то пошло).</p>
<h3>Which</h3>
<p>Самый простой способ просматривать файлы — это использование команды <strong>which</strong> для посмотра в каталогах, перечисленных в пути поиска пользователя на требуемый файл. Конечно, путь поиска содержит только пути к каталогам, содержащим исполняемые программы, которые не работают для обычных файлов. Команда <strong>which</strong> полезна при выяснении причины возникновения проблемы "Команда не найдена" ("Command not Found"). В приведенном ниже примере пользователь <em>tina</em> не может использовать программу <strong>acroread</strong>, а ее коллега не испытывает никаких проблем на той же системе. Эта проблема аналогична проблеме <span class="mono">PATH</span> из предыдущей части: коллега <em>tina</em> сказал ей, что он может увидеть нужную программу в <span class="mono">/opt/acroread/bin</span>, но этого каталога нет в ее path:</p>
<pre>
tina:~> <strong>which acroread</strong>
/usr/bin/which: no acroread in (/bin:/usr/bin:/usr/bin/X11
</pre><p>
Проблема может быть решена путем предоставления полного пути к команде запуска, или нужно заново экспортировать содержание переменной PATH:</p>
<pre>
tina:~> <strong>export PATH=$PATH:/opt/acroread/bin</strong>

tina:~> <strong>echo $PATH</strong>
/bin:/usr/bin:/usr/bin/X11:/opt/acroread/bin
</pre><p>
Используя команду <strong>which</strong> также можно проверить, является ли команда  псевдонимом другой команды:</p>
<pre>
gerrit:~> <strong>which -a ls</strong>
ls is aliased to `ls -F --color=auto'
ls is /bin/ls
</pre><p>
Если это не сработает в вашей системе, используйте псевдоним команды:</p>
<pre>
tille@www:~/mail$ <strong>alias ls</strong>
alias ls='ls —color'
</pre><h3>Find и locate </h3>
<p>Кроме перечисления в path, есть инструменты, специально предназначенные для поиска. Есть очень мощный инструмент <strong>find</strong>, известный из UNIX, который можно расценить, как имеющий достаточно трудный синтаксис. GNU <strong>find</strong>, однако, имеет дело с синтаксическими проблемами. Эта команда позволяет не только вести поиск имен файлов, она также может принимать размер файла, дату последнего изменения и другие свойства файла в качестве критериев для поиска. Наиболее часто используется поиск файлов по именам:<br />
<div class="geshifilter"><pre class="python geshifilter-python" style="font-family:monospace;">find <span style="color: #66cc66;">&lt;</span>path<span style="color: #66cc66;">&gt;</span> -name <span style="color: #66cc66;">&lt;</span>searchstring<span style="color: #66cc66;">&gt;</span></pre></div></p>
<p>Это может быть истолковано как "Просмотреть все файлы и подкаталоги, содержащихся в заданном пути, и выдать имена файлов, содержащих строку поиска в их имени" (но не в содержании).</p>
<p>Другое применение <strong>find</strong> поиск файлов по определенному размеру, как и в примере ниже, где пользователь <em>peter</em> хочет найти все файлы в текущей директории или одном из ее подкаталогов, которые больше 5 MB:</p>
<pre>
peter:~> <strong>find . -size +5000k</strong>
psychotic_chaos.mp3
</pre><p>
Если вы покопаетесь в man-страницах, то увидите, что <strong>find</strong> также может совершать действия над найденными файлами. Типичным примером является удаление файлов. Лучше всего первый тест совершить без опции <span class="mono">-exec</span>, когда нужные файлы отобраны, после чего команда может быть повторно запущена для удаления выбранных файлов. Ниже, мы ищем файлы с расширением <span class="mono">.tmp</span>:</p>
<pre>
peter:~> <strong>find . -name "*.tmp" -exec rm {} \;</strong>

peter:~>
</pre><p class="note"><img src="../../../img/linuxintro/tip.gif" alt="" /><strong>  Оптимизация!</strong><br />
Эта команда будет вызывать <strong>rm</strong> так много раз, сколько подходящих к требованию файлов найдется. В худшем случае, это может быть тысячи или миллионы раз. Это довольно сильно загрузит вашу систему.<br />
Более реалистичным подходом к работе будет использование канала (|) и инструмента <strong>xargs</strong> с командой <strong>rm</strong> в качестве аргумента. Таким образом, команда <strong>rm</strong> вызывается только, когда командная строка заполнена, а не для каждого файла. См. <a href="http://younglinux.info/#">Главу 5, «Перенаправление ввода/вывода (I/O)»</a> для дополнительной информации об использовании I/O перенаправления для облегчения повседневных задач.</p>
<p>Позднее (в 1999 году в след за man-страницами, после 20 лет существования <strong>find</strong>), была разработана <strong>locate</strong>. Эта программа проще в использовании, но более ограничена, чем <strong>find</strong>, т.к. ее выдача основана на базе данных файловых индексов, который обновляется только раз в день. С другой стороны, поиск в базе данных <strong>locate</strong> использует меньше ресурсов, чем <strong>find</strong> и, следовательно, показывает результаты практически мгновенно.</p>
<p>В наши дни большинство дистрибутивов Linux используют <strong>slocate</strong> (поиск снабженный безопасностью), современная версия <strong>locate</strong> позволяет пользователям получать выдачу, которую они не имеют права читать. Так, например, файлы из домашнего каталога root, обычно не доступны для публичного просмотра. Пользователь, который хочет найти того, кто знает об оболочке C, может задать команду <strong>locate </strong> <span class="mono"> .cshrc</span>, для просмотра всех пользователей, у которых конфигурационный файл настроен на оболочку C. Если предположить, что пользователи <em>root</em> и <em>jenny</em> находятся под управлением оболочки C, то только файл <span class="mono"> /home/jenny/.cshrc</span> будет отображен, и не один из домашней директории <em>root</em>. На большинстве систем, <strong>locate</strong> является символической ссылкой на программу <strong>slocate</strong>:</p>
<pre>
billy:~> <strong>ls -l /usr/bin/locate</strong>
lrwxrwxrwx 1 root slocate  7 Oct 28 14:18 /usr/bin/locate -> slocate*
</pre><p>
Пользователь <em>tina</em> могла бы использоваться <strong>locate</strong>, чтобы найти необходимое приложение:</p>
<pre>
tina:~> <strong>locate acroread</strong>
/usr/share/icons/hicolor/16x16/apps/acroread.png
/usr/share/icons/hicolor/32x32/apps/acroread.png
/usr/share/icons/locolor/16x16/apps/acroread.png
/usr/share/icons/locolor/32x32/apps/acroread.png
/usr/local/bin/acroread
/usr/local/Acrobat4/Reader/intellinux/bin/acroread
/usr/local/Acrobat4/bin/acroread
</pre><p>
Каталоги, которые не содержат имя <span class="mono">bin</span><br />
, не могут содержать программы - они не содержат исполняемые файлы. Есть три возможности. Файл в <span class="mono">/usr/local/bin </span><br />
и есть то, что хотела бы <em>tina</em>: это ссылка на shell-скрипт, который  запускает настоящую программу:</p>
<pre>
tina:~> <strong>file /usr/local/bin/acroread</strong>
/usr/local/bin/acroread: symbolic link to ../Acrobat4/bin/acroread

tina:~> <strong>file /usr/local/Acrobat4/bin/acroread</strong>
/usr/local/Acrobat4/bin/acroread: Bourne shell script text executable

tina:~> <strong>file /usr/local/Acrobat4/Reader/intellinux/bin/acroread</strong>
/usr/local/Acrobat4/Reader/intellinux/bin/acroread: ELF 32-bit LSB 
executable, Intel 80386, version 1, dynamically linked (uses 
shared libs), not stripped
</pre><p>
Для того, чтобы сохранить путь как можно короче, и системе не приходилось искать слишком долго каждый раз, когда пользователь хочет выполнить команду, мы добавляем <span class="mono">/usr/local/bin</span><br />
 к пути, а не другие каталоги, которые содержат только двоичные файлы одной конкретной программы, также <span class="mono">/usr/local/bin</span> содержит другие полезные программы.</p>
<p>Опять же, полное описание возможностей <strong>find</strong> и <strong>locate</strong> можно найти на страницах info.</p>
<h3>Команда grep</h3>
<h4>Общая строка фильтрации</h4>
<p>Простая, но мощная программа <strong>grep</strong> используется для фильтрации входных строк и выдачи подходящих к образцу на вывод. Существуют буквально тысячи применений для  программы <strong>grep</strong>. В приведенном ниже примере, <em>jerry</em> использует <strong>grep</strong>, чтобы посмотреть, что он делал с <strong>find</strong>:</p>
<pre>
jerry:~> <strong>grep -a find .bash_history</strong>
find . -name userinfo
man find
find ../ -name common.cfg
</pre><p class="note"><img src="../../../img/linuxintro/tip.gif" alt="" /><strong>  История поиска.</strong><br />
Также полезна в этих случаях функция поиска в <strong>bash</strong>, которая сразу же запускается нажатием <strong>Ctrl + R</strong>, как в примере, где мы хотим проверить  еще раз, что мы делали в прошлом с командой <strong>find</strong>:</p>
<pre>
thomas ~> <strong>^R</strong> 
(reverse-i-search)`find': find `/home/thomas` -name *.xml
</pre><p>
Введите строку поиска для начала поиска. Чем больше символов вы вводите, тем более ограниченный поиск получаете. Здесь читается история команды для этой сессии оболочки (которая записывается в <span class="mono">.bash_history</span> в вашем домашнем каталоге при выходе из той сессии). Показывается самый последний случай строки вашего поиска. Если вы хотите увидеть предыдущие команды, содержащие ту же строку, нажмите <strong>Ctrl + R</strong> опять.</p>
<p>Чтобы узнать больше, изучайте info-страницы в <strong>bash</strong>.</p>
<p>Все ОС Unix имеют он-лайн словарь. Так же и Linux. Словарь представляет собой список известных слов в файле под названием <span class="mono">words</span>, расположенный в <span class="mono">/usr/share/dict</span>. Чтобы быстро проверить правильность написания слова, не графическое приложение, необходимо:</p>
<pre>
william:~> <strong>grep pinguin /usr/share/dict/words</strong>

william:~> <strong>grep penguin /usr/share/dict/words</strong>
penguin
penguins
</pre><p class="note"><img src="../../../img/linuxintro/tip.gif" alt="" /><strong>   Словарь против списка слов.</strong><br />
Некоторые дистрибутивы предлагают команду <strong>dict</strong>, которая предоставляет больше функций, чем просто поиск слов в списке.</p>
<p>Кто является владельцем того домашнего каталога рядом со мной? Эй, есть его номер телефона!</p>
<pre>
lisa:~> <strong>grep gdbruyne /etc/passwd</strong>
gdbruyne:x:981:981:Guy Debruyne, tel 203234:/home/gdbruyne:/bin/bash
</pre><p>
И какой был адрес электронной почты Arno также?</p>
<pre>
serge:~/mail> <strong>grep -i arno *</strong>
sent-mail: To: <Arno.Hintjens@celeb.com>
sent-mail: On Mon, 24 Dec 2001, Arno.Hintjens@celeb.com wrote:
</arno.hintjens@celeb.com></pre><p>
<strong>find</strong> и <strong>locate</strong> часто используются в сочетании с grep для решения некоторых  важных задач. Для получения дополнительной информации см. <a href="http://younglinux.info/#">Главу 5, «Перенаправление ввода/вывода (I/O)»</a>.</p>
<h4>Специальные символы</h4>
<p>Символы, имеющие специальное значение для оболочки должны быть <em>экранированы</em>. Символом экранирования в Bash является обратная косая черта, как и в большинстве оболочек; она придает специальное значение последующему символу. Оболочка знает о многих специальных символов, к числу наиболее распространенных относятся /,.,? и *. Полный список можно найти на info-страницах и документации к вашей оболочке.<br />
Так, например, чтобы сказать, что вы хотите отобразить файл «*» вместо всех файлов в каталоге, вам придется использовать</p>
<p><span class="mono">less \*</span></p>
<p>То же самое касается имен файлов, содержащих пробел:</p>
<p><span class="mono">cat This\ File</span></p>
<h2>Другие способы просмотра содержимого файла</h2>
<h3>Общее</h3>
<p>Кроме <strong>cat</strong>, который действительно не делать больше, чем передача файлов на стандартный вывод, есть другие инструменты для просмотра содержимого файла.</p>
<p>Самый простой способ, конечно, будет заключаться в использовании графических инструментов вместо инструментов командной строки. Во введении мы уже мельком видели офисное приложение OpenOffice.org. Другие примеры GIMP (запускается командой <strong>gimp</strong> из командной строки), GNU программа обработки изображений; <strong>xpdf</strong> для просмотра файлов формата Portable Document (PDF); GhostView (<strong>gv</strong>) для просмотра файлов PostScript; браузер Mozilla/FireFox, Konqueror, Opera и многое другое для веб-контента; XMMS, CDplay и других для мультимедийных файлов, AbiWord, Gnumeric, KOffice и т.д. для всех видов офисных приложениях и т.д. Есть тысячи приложений Linux; перечисление их всех заняло бы дни.</p>
<p>Вместо этого мы продолжим сосредотачиваться на приложениях текстового режима, которые создают основу для всех других приложений. Эти команды работают лучше всего в текстовом окружении для файлов, содержащих текст. В случае сомнений, сначала проверьте с помощью команды <strong>file</strong>.</p>
<p>Итак, давайте посмотрим, какие текстовые инструменты у нас есть, которые полезны, для просмотра содержимого файлов.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Проблемы шрифта.</strong><br />
Инструменты для простого (плоского) текста, такие как те, что мы сейчас будем обсуждать, часто имеют проблемы с "плоскими" текстовыми файлами из-за кодировок шрифта, используемых в этих файлах. Специальные символы, такие как "акцентированные" буквы алфавита, китайские иероглифы и другие символы языков, использующих различные наборы символов, а не по умолчанию en_US кодировку и так далее, будут отображаться неправильно или будут заменены нечитаемым мусором. Эти проблемы обсуждаются в <a href="http://younglinux.info/#">Разделе 7.4. "Региональные специфические настройки"</a>.</p>
<h3>Меньше (less) значит больше</h3>
<p>Несомненно рано или поздно вы услышите как кто-то скажет эту фразу при работе в среде UNIX. Немного истории UNIX объяснит это:</p>
<ul>
<li>Сначала была <strong>cat</strong>. Поток вывода был неконтролируемым.</li>
<li>Потом была <strong>pg</strong>, которую все еще можно обнаружить на старых версиях Unix. Эта команда выдает текст на вывод по одной странице за раз.</li>
<li>Программа <strong>more</strong> подправленный вариант <strong>pg</strong>. Эта команда по-прежнему есть в каждой системе Linux.</li>
<li><strong>less</strong> GNU версия <strong>more</strong> и включает дополнительные функции, позволяющие подсвечивать строки поиска, прокрутку назад  и т.д. Синтаксис очень прост:</li>
</ul>
<p><span class="mono">less name_of_file</span></p>
<p>Более подробная информация находится на info-страницах.</p>
<p>К настоящему времени вы уже знаете о пейджерах, поскольку они используются для просмотра man-страниц.</p>
<h3>Команды head и tail</h3>
<p>Эти две команды отображают соответственно n первых/последних строк файла. Чтобы посмотреть последние десять команд ввели следующее:</p>
<pre>
tony:~> <strong>tail -10 .bash_history</strong> 
locate configure | grep bin
man bash
cd
xawtv &
grep usable /usr/share/dict/words 
grep advisable /usr/share/dict/words 
info quota
man quota
echo $PATH
frm
</pre><p>
<strong>head</strong> работает аналогично. У команды <strong>tail</strong> есть удобная функция, постоянно показывающая последние n строк файла, которые меняются все время. Это опция <span class="mono">-f</span>, которая часто используется системными администраторами для проверки файлов журналов. Более подробная информация находится в файлах системной документации.</p>
<h2>Связывание файлов</h2>
<h3>Типы ссылок</h3>
<p>Поскольку мы уже знаем достаточно о файлах и их представлении в файловой системе, понимание ссылок (или ярлыков) добавит составляющую в общую картину. Ссылка — это не более чем способ сопоставления двух или более имен файлов с одним и тем же  набором данных. Есть два пути достижения этой цели:</p>
<ul>
<li>Жесткая ссылка: Связывает два или более имени файла с одним и тем же индексным дескриптором. Жесткие ссылки определяют одни и те же блоки данных на жестком диске, в то время они продолжают вести себя как независимые файлы.</li>
</ul>
<p>Существует очевидное неудобство: жесткие ссылки не могут распространяться на разделы, т.к. номера индексных дескрипторов уникальны только в пределах данного раздела.</p>
<ul>
<li>Мягкая или символическая (символьная) ссылка (или для краткости: symlink - симлинк): маленький файл, который является указателем на другой файл. Символическая ссылка содержит путь к целевому файлу, а не указание на физическое расположение данных на жестком диске. Поскольку в данном механизме не задействованы индексные дескрипторы, мягкие ссылки могут существовать между разными разделами.</li>
</ul>
<p>Поведение этих двух типов ссылок похожее, но не одинаковое, что проиллюстрировано на схеме ниже:</p>
<p><strong>Рисунок 3.2. Механизм жестких и мягких ссылок</strong></p>
<div style="text-align:center;"><img src="../../../img/linuxintro/links.png" width="295" height="401" alt="Механизм жестких и мягких ссылок в Linux" /></div>
<p>Обратите внимание, что удаление целевого файла для символьной ссылки делает ссылку бесполезной.</p>
<p>Каждый обычный файл, в принципе, - жесткая ссылка. Жесткие ссылки файла не простираются на все разделы, так как они отсылают к индексным дескрипторам, а номера ID уникальны только в пределах данного раздела.</p>
<p>Можно утверждать, что существует третий вид ссылок, <em>user-space</em> ссылки, которые похожи на ярлык в MS Windows. Это файлы, содержащие метаданные, которые могут быть интерпретированы только графическим файловым менеджером. Для ядра и оболочки это просто обычные файлы. У них может быть в конце суффикс  <em>.desktop</em> или <em>.lnk</em>; например, можно найти <span class="mono">~/.gnome-desktop</span>:</p>
<pre>
[dupont@boulot .gnome-desktop]$ <strong>cat La\ Maison\ Dupont</strong>
[Desktop Entry]
Encoding=Legacy-Mixed
Name=La Maison Dupont
Type=X-nautilus-home
X-Nautilus-Icon=temp-home
URL=file:///home/dupont
</pre><p>Этот пример взят из графической среды KDE:</p>
<pre>
[lena@venus Desktop]$ <strong>cat camera</strong>
[Desktop Entry]
Dev=/dev/sda1
FSType=auto
Icon=memory
MountPoint=/mnt/camera
Type=FSDevice
X-KDE-Dynamic-Device=true
</pre><p>
Создать такого рода ссылку достаточно легко путем использования особенностей вашей графической среды. Если вам нужна помощь, то системная документация должна быть вашим первым источником.</p>
<p>В следующем разделе мы рассмотрим создание символических ссылок в UNIX-стиле с помощью командной строки.</p>
<h3>Создание символических ссылок</h3>
<p>Символическая ссылка представляет особый интерес для начинающих пользователей: они достаточно очевидны для понимания и вам не нужно беспокоиться о разделах.</p>
<p>Команды для создания ссылок является <strong>ln</strong>. Для того чтобы создать символические ссылки, следует использовать опцию <span class="mono">-s</span>:</p>
<p><span class="mono">ln -s targetfile linkname</span></p>
<p>В приведенном ниже примере пользователь <em>freddy</em> создает ссылку в подкаталоге своей домашней папки на каталог другой части системы:</p>
<pre>
freddy:~/music> <strong>ln -s /opt/mp3/Queen/ Queen</strong>

freddy:~/music> <strong>ls -l</strong>
lrwxrwxrwx  1 freddy  freddy  17 Jan 22 11:07 Queen -> /opt/mp3/Queen
</pre><p>
Символические ссылки всегда очень маленькие файлы, в то время как жесткие ссылки имеют те же размеры, что и исходный файл.</p>
<p>Применение символических ссылок имеет широкое распространение. Они часто используются для экономии дискового пространства за счет создания «копии» файла для удовлетворения требований при установке новой программы, которая ожидает наличие файла в другом месте; они используются для исправления сценариев, которые внезапно запускаются в новых окружениях, в общем могут предотвратить большие затраты. Системный администратор может принять решение перенести домашние каталоги пользователей на новое место, <span class="mono">disk2</span> например, но если он хочет, чтобы все работало, как раньше, в том числе файл <span class="mono">/etc/passwd</span>, с минимумом усилий он создаст символическую ссылку из <span class="mono">/home</span> на новое место <span class="mono">/disk2/home</span>.</p>
  </div>
    </div></div>
  </body>
</html>
