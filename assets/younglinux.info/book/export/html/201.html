<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Ориентация в файловой системе</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
              <div class="section-1">
                <div class="section-2">
          
    <div id="node-201" class="section-3">
  <h1 class="book-heading">Ориентация в файловой системе</h1>
  <p>Когда вы хотите, чтобы система выполнила команду, вам почти никогда не надо давать полный путь к этой команде. Например, мы знаем, что команда <strong>ls</strong> находится в каталоге <span class="mono"> /bin</span> (проверьте командой <strong>which </strong> <span class="mono"> -a ls</span>), тем не менее, мы не обязаны вводить команду <strong><strong><strong>/bin/ls</strong></strong></strong> в компьютер, чтобы получить список содержимого текущей директории.</p>
<p>Дело в том, что об этом заботится переменная окружения <span class="mono">PATH</span>. В ней перечисляются те каталоги системы, где могут быть найдены исполняемые файлы, что освобождает пользователя от излишнего ввода символов  и запоминания местонахождения команд. Естественно <span class="mono">PATH</span> (путь) содержит множество каталогов, обычно содержащих где-то в своих именах <span class="mono">bin</span>, что показано ниже. Команда <strong>echo</strong> используется для отображения содержимого ("$") переменной <span class="mono">PATH</span>:</p>
<pre>
rogier:> <strong>echo $PATH</strong>
/opt/local/bin:/usr/X11R6/bin:/usr/bin:/usr/sbin/:/bin
</pre><p>В этом примере, каталоги <span class="mono">/opt/local/bin, /usr/X11R6/bin, /usr/bin, /usr/sbin</span> и <span class="mono">/bin</span> являются местами последовательного поиска нужной программы. Как только она найдена, поиск останавливается, даже если еще не каждый каталог в path проверен. Это может привести к странным ситуациям. В первом примере ниже пользователь знает, что есть программа под названием <strong>sendsms</strong> для отправления SMS сообщений, и другой пользователь в той же самой системе может ей пользоваться, но не первый пользователь. Разница заключается в конфигурации переменной <span class="mono">PATH</span>:</p>
<pre>
[jenny@blob jenny]$ <strong>sendsms</strong>
bash: sendsms: command not found
[jenny@blob jenny]$ echo $PATH
/bin:/usr/bin:/usr/bin/X11:/usr/X11R6/bin:/home/jenny/bin
[jenny@blob jenny]$ su - tony
Password:
tony:~>which sendsms
sendsms is /usr/local/bin/sendsms

tony:~>echo $PATH
/home/tony/bin.Linux:/home/tony/bin:/usr/local/bin:/usr/local/sbin:\
/usr/X11R6/bin:/usr/bin:/usr/sbin:/bin:/sbin
</pre><p>
Обратите внимание на использование средства <strong>su</strong> (переключение пользователей), которое позволяет запускать shell в среде другого пользователя, конечно при условии, что вы знаете пароль этого пользователя.</p>
<p>Обратная косая черта обозначает продолжение данной строки на другую и игнорирует разделение с помощью клавиши <strong>Enter</strong>.</p>
<p>В следующем примере, пользователь хочет вызвать команду <strong>wc</strong> (количество слов), чтобы проверить количество строк в файле, но ничего не происходит, и он вынужден прервать ее работу, используя комбинацию <strong>Ctrl + C</strong>:</p>
<pre>
jumper:~> <strong>wc -l test</strong>

(Ctrl-C)
jumper:~> <strong>which wc</strong>
wc is hashed (/home/jumper/bin/wc)

jumper:~> <strong>echo $PATH</strong>
/home/jumper/bin:/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin:\
/usr/bin:/usr/sbin:/bin:/sbin
</pre><p>
Использование команды <strong>which</strong> показывает нам, что у этого пользователя есть <span class="mono">bin</span>-каталог в его домашней директории, содержащей программу также под названием <strong>wc</strong>. Поскольку программа в домашнем каталоге находится первой при просмотре путей при вызове <strong>wc</strong>, выполняется эта «самодельная» программа, которая, вероятно, не понимает ввод, поэтому потребовалось ее завершить. Для решения проблем подобного рода есть несколько способов (вообще в UNIX/Linux всегда есть несколько вариантов решения проблем): одно решение — это переименовать  программу <strong>wc</strong> пользователя, или пользователь может вводить полный путь к требуемой ему команде, который можно определить, используя опцию <span class="mono">-a</span> команды <strong>which</strong>.</p>
<p>Однако, если пользователь чаще использует программы из других каталогов, то может изменить последовательность просмотра каталогов на свой собственный вариант:</p>
<pre>
jumper:~> <strong>export PATH=/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin:\
/usr/bin:/usr/sbin:/bin:/sbin:/home/jumper/bin</strong>
</pre><p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>  Изменения не постоянны!</strong><br />
Обратите внимание, что при использовании в командной строке команды <strong>export</strong>, изменения носят временный характер и действуют только в данной сессии (до выхода). Открытие новой сессии (даже если текущая первая по прежнему работает) не приводи к наличию в ней новых путей. Мы увидим в <a href="http://younglinux.info/#">Разделе "Ваше текстовое окружение"</a>, как можно сделать такого рода изменения окружения постоянными, путем добавления этих строк в конфигурационные файлы оболочки.</p>
<h2>Абсолютные и относительные пути</h2>
<p>Путь, по которым вы должны следовать в древовидной структуре, чтобы получить заданный файл, может быть описан, начиная от ствола дерева (/ или корневого каталога). В этом случае путь начинается со слэша и называется абсолютным путем, поскольку не может быть никакого заблуждения: только один файл в системе может подойти под него.</p>
<p>В другом случае, путь не начинается со слэша и возможна путаница по сравнению с предыдущим вариантом между <span class="mono">~/bin/wc</span> (в домашнем каталоге пользователя) и <span class="mono">bin/wc</span> в <span class="mono">/usr</span>. Пути, которые не начинаются со слэша всегда относительные.</p>
<p>В относительных путях мы также используем . и .., указывающие на текущий и родительский каталоги. Пара практических примеров:</p>
<ul>
<li>Если вы хотите компилировать исходный код, документация к установке часто инструктирует вас выполнить команду <strong>./configure</strong>, которая запускает программу <em>configure</em>, расположенную в текущем каталоге (и которая поставляется с новым кодом), а ни где-то в  другом месте системы.</li>
<li>В файлах HTML, относительных пути часто используются, чтобы сделать ряд страниц, легко переносимыми в другое место:</li>
</ul>
<p><div class="geshifilter"><pre class="python geshifilter-python" style="font-family:monospace;"><span style="color: #66cc66;">&lt;</span>img alt=<span style="color: #483d8b;">&quot;Garden with trees&quot;</span> src=<span style="color: #483d8b;">&quot;../images/garden.jpg&quot;</span><span style="color: #66cc66;">&gt;</span></pre></div></p>
<ul>
<li>Обратите внимание на различие еще раз:</li>
</ul>
<pre>
theo:~> <strong>ls /mp3</strong>
ls: /mp3: No such file or directory
theo:~> <strong>ls mp3/</strong>
oriental/  pop/  sixties/
</pre><h2>Наиболее важные файлы и каталоги</h2>
<h3>Ядро</h3>
<p>Ядро является сердцем системы. Оно управляет связью между основной аппаратурой и периферией. Ядро также гарантирует, что процессы и демоны (серверные процессы) начинаются и останавливаются строго в требуемое время. У ядра много других важных задач, так много, что специальная рассылка по разработки ядра существуют только по тому вопросу, где огромные объемы информации являются общими. Мы бы зашли слишком далеко, обсуждая ядро в деталях. Сейчас достаточно знать, что ядро – это самый важный файл в системе.</p>
<h3>Оболочка (Shell)</h3>
<h4>Что такое shell?</h4>
<p>Когда я смотрела соответствующее разъяснение по концепции оболочки, это дало мне больше хлопот, чем я ожидала. Все доступные определения, от простого сравнения, что "оболочка - это руль автомобиля", к расплывчатому определению в руководстве Bash, где говорится, что "bash является sh-совместимым интерпретатором командного языка", до еще более неясного выражения "оболочка управляет взаимодействием между системой и ее пользователями". Shell гораздо больше, чем все это.</p>
<p>Самым лучшим сравнением для оболочки может быть представление о способе общения с компьютером, сравнение оболочки с языком. Большинство пользователей знают другой «язык», это язык «укажи-и-щелкни» графического рабочего стола. Но на этом языке компьютер задает беседу, а пользователю отведена пассивная роль выбора задач их тех, что представлены. Для программиста очень трудно включить в GUI-формат все опции и способы применения команд. Поэтому графические интерфейсы почти всегда менее способные, чем команды, стоящие за ним.</p>
<p>Оболочка, с другой стороны, это расширенный способ общения с системой, поскольку она позволяет вести двустороннюю беседу и проявлять инициативу. Оба партнера в сообщении равны, так что могут быть проверены новые идеи. Оболочка позволяет пользователю очень гибко управлять системой. Дополнительным преимуществом является то, что оболочка позволяет автоматизировать задачи.</p>
<h4>Типы оболочек</h4>
<p>Так же как люди знают различных языки и диалекты, компьютеру известны различные типы оболочек:</p>
<ul>
<li><strong>sh</strong> или Bourne Shell: первая оболочка, которая до сих пор используются в системах UNIX. Это базовая оболочка, представляющая собой небольшую программу с незначительным числом функций. В POSIX-совместимом режиме bash будет эмулировать эту оболочку.</li>
<li><strong>bash</strong> или Bourne Again Shell: стандартная оболочка GNU, интуитивно понятная и гибкая. Наиболее предпочтительная для начинающих пользователей, и в то же время являющаяся мощным инструментом для опытных и профессиональных пользователей. На Linux <strong>bash</strong> – это стандартная оболочка обычных пользователей. Эта оболочка является так называемой расширенной Bourne shell, с множеством дополнений и плагинов. Это означает, что Bourne Again SHell совместима с Bourne shell: команды, которые работают в <strong>sh</strong>, также работают в <strong>bash</strong>. Однако, обратное не всегда соответствует действительности. Все примеры и упражнения в этой книге приведены с использованием <strong>bash</strong>.</li>
<li><strong>csh</strong> или C Shell: синтаксис этой оболочки напоминает синтаксис языка программирования Си. Иногда используется программистами.</li>
<li><strong>tcsh</strong> или Turbo C Shell: расширенный вариант обычной C Shell, обеспечивает большее удобство и скорость.</li>
<li><strong>ksh</strong> или оболочка Корна: иногда ценится людьми с опытом работы в UNIX. Расширение оболочки Борна; в стандартной конфигурации – кошмар для начинающих пользователей.</li>
</ul>
<p>Файл <span class="mono">/etc/shells</span> дает обзор известных системе Linux оболочек:</p>
<pre>
mia:~> <strong>cat /etc/shells</strong>
/bin/bash
/bin/sh
/bin/tcsh
/bin/csh
</pre><p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Хитрость оболочки Борна.</strong><br />
Обратите внимание, что <span class="mono">/bin/sh</span>, как правило, ссылка на Bash, которая будет при вызове по этому пути выполнять в оболочке Борна совместимый режим.</p>
<p>Ваша оболочка, которая используется по умолчанию, описывается в файле <span class="mono">/etc/passwd</span>, подобно этой строке для пользователя <em>mia</em>:</p>
<pre>
mia:L2NOfqdlPrHwE:504:504:Mia Maya:/home/mia:/bin/bash
</pre><p>
Чтобы перейти из одной оболочки в другую, просто введите название новой оболочки в активном терминале. Система находит каталог, где встречается это имя  с помощью установок PATH, и поскольку оболочка является исполняемым файлом (программой), текущая оболочка активирует ее, после чего она запустится. Обычно это отражает новое приглашение, т.к. у каждой оболочки оно имеет типичный внешний вид:</p>
<pre>
mia:~> <strong>tcsh</strong>
[mia@post21 ~]$
</pre><h4>Какую оболочку я использую?</h4>
<p>Если вы не знаете, какую оболочку используете, либо проверьте строку для вашей учетной записи в <span class="mono">/etc/passwd</span>, либо введите команду<br />
<span class="mono">echo $SHELL</span></p>
<h3>Ваш домашний каталог</h3>
<p>Ваш каталог является вашим местонахождением по умолчанию при подключении к системе. В большинстве случаев это подкаталог <span class="mono">/home</span>, хотя это можно изменить. Ваш домашний каталог может находиться на жестком диске удаленного файлового сервера, в этом случае домашнюю директорию можно найти в <span class="mono">/nethome/your_user_name</span>. В другом случае системный администратор может сделать выбор в пользу менее понятной схемы и ваша домашняя директория может оказаться на <span class="mono">/disk6/HU/07/jgillard</span>.</p>
<p>Каким бы ни был путь к вашей домашней директории, вы не должны слишком беспокоиться об этом. Правильный путь к вашей домашней директории хранится в переменной окружения <span class="mono">HOME</span> на случай, если какой-нибудь программе это потребуется. С помощью команды echo вы можете вывести на экран содержимое этой переменной:</p>
<pre>
orlando:~> <strong>echo $HOME</strong>
/nethome/orlando
</pre><p>
В вашем домашнем каталоге вы можете делать все, что вам нравится. Вы можете поместить любое количество файлов в такое количество каталогов, как вам захочется, хотя, естественно, общий объем данных и файлов ограничивается размерами разделов и иногда тем, что системный администратор применил квоты для системы. Ограничение использования дискового пространства было обычной практикой, когда память на жестком диске оставалась дорогой. В наши дни такие ограничения встречаются почти исключительно в больших средах. Вы можете выяснить для себя,  устанавливается ли ограничение с помощью команды <strong>quota</strong>:</p>
<pre>
pierre@lamaison:/> <strong>quota -v</strong>
Diskquotas for user pierre (uid 501): none
</pre><p>
В случае, если квоты были установлены, вы получите список разделов, на которые распространяются ограничения, и размер последних. Превышение пределов может быть допущено во время льготного периода с меньшими ограничениями или их отсутствием. Детальную информацию можно получить с помощью команд <strong>info </strong> <span class="monoi"> quota</span> или <strong>man </strong> <span class="monoi"> quota</span>.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Нет Quota?</strong><br />
Если ваша система не может найти quota, то никаких ограничений в отношении использования файловой системы не применяется.</p>
<p>Ваш домашний каталог обозначается символом тильды (~), это сокращение для <span class="mono">/path_to_home/user_name</span> (домашнего каталога пользователя). Этот же путь хранится в переменной <span class="mono">HOME</span>, так что вам не нужно набирать лишнее для перехода в домашний каталог. Простое применение: переход из <span class="mono">/var/music/albums/arno/2001</span> в <span class="mono">images</span> в вашем домашнем каталоге с помощью одной элегантной команды:</p>
<pre>
rom:/var/music/albums/arno/2001> <strong>cd ~/images</strong>

rom:~/images> pwd
/home/rom/images
</pre><p>
Далее в этой главе мы поговорим о командах для управления файлами и каталогами, все это поможет сохранить порядок в вашем домашнем каталоге.</p>
<h2>Наиболее важные конфигурационные файлы</h2>
<p>Как мы уже отмечали ранее, подавляющее большинство конфигурационных файлов хранятся в директории <span class="mono">/etc</span>. Содержание файлов может быть просмотрено с помощью команды <span class="mono">cat</span>, которая отправляет текст файлов на стандартный вывод (обычно ваш монитор). Синтаксис прямо вперед вами:</p>
<p><span class="mono">cat file1 file2 ... fileN  </span></p>
<p>В этом разделе мы постараемся дать обзор наиболее распространенных конфигурационных файлов. Это, конечно, не полный список. Добавление дополнительных пакетов может также привести к добавлению дополнительных файлов конфигурации в <span class="mono">/etc</span>. При чтении конфигурационных файлов, вы увидите, что они, как правило, очень хорошо прокомментированы и не требуют пояснений. У некоторых файлов также имеются man-страницы, которые содержат дополнительную документацию, например <strong>man</strong> <span class="monoi">group</span>.</p>
<p><strong>Таблица 3.3. Большинство распространенных конфигурационных файлов</strong></p>
<table>
<tr>
<td width="150"><strong>Файл</strong></td>
<td><strong>Информация/служба</strong></td>
</tr>
<tr>
<td>aliases</td>
<td>Файл почтовых псевдонимов для использования с почтовыми серверами Sendmail и Postfix. Запуск почтового сервера на каждой системе давно стал обычным делом в мире UNIX, и почти каждый дистрибутив Linux по-прежнему поставляется с пакетом Sendmail. В этом файле локальные имена пользователей сопоставляются с реальными именами, которые имеют место в E-mail адресах или других локальных адресах.</td>
</tr>
<tr>
<td>apache</td>
<td>Config-файлы для веб-сервера Apache.</td>
</tr>
<tr>
<td>bashrc</td>
<td>Общесистемный конфигурационный файл для Bourne Again Shell. Определяет возможности и псевдонимы для всех пользователей. У других оболочек могут быть свои собственные общесистемные конфигурационные файлы, к примеру <span class="mono">cshrc</span>.</td>
</tr>
<tr>
<td>Каталоги crontab  и cron.* </td>
<td>Настройка задач, которые должны периодически выполняться - резервное копирование, обновления баз данных системы, очистка системы, изменяющиеся журналы и т.д</td>
</tr>
<tr>
<td>default</td>
<td>Параметры по умолчанию для некоторых команд, таких как <strong>useradd</strong>.</td>
</tr>
<tr>
<td>filesystems</td>
<td>Известные файловые системы: ext3, vfat, iso9660 и т.д.</td>
</tr>
<tr>
<td>fstab</td>
<td>Список разделов и их точек монтирования.</td>
</tr>
<tr>
<td>ftp*</td>
<td>Настройка FTP-сервера: кто может подключаться, какие части системы доступны и т.д.</td>
</tr>
<tr>
<td>group</td>
<td>Файл конфигурации для пользовательских групп. Используйте теневые утилиты <strong>groupadd, groupmod</strong> и <strong>groupdel</strong> для редактирования этого файла. Редактируйте вручную, только если точно знаете, что делаете.</td>
</tr>
<tr>
<td>hosts</td>
<td>Список машин, с которыми можно связаться по сети, но без использования службы доменных имен. Это не имеет ничего общего с сетевой конфигурацией системы, которая настраивается в <span class="mono">/etc/sysconfig</span>.</td>
</tr>
<tr>
<td>inittab</td>
<td>Информация для загрузки: режим, количество текстовых консолей и т.д.</td>
</tr>
<tr>
<td>issue</td>
<td>Информация о дистрибутиве (версия и/или информация о ядре).</td>
</tr>
<tr>
<td>ld.so.conf</td>
<td>Места файлов библиотек.</td>
</tr>
<tr>
<td>lilo.conf, silo.conf, aboot.conf и т.д.</td>
<td>Загрузочная информации для LInux LOader, системы для загрузки, которую в настоящее время постепенно вытесняет GRUB.</td>
</tr>
<tr>
<td>logrotate.*</td>
<td>Ротация журналов, система предотвращения накопления огромного количества лог-файлов.</td>
</tr>
<tr>
<td>mail</td>
<td>Каталог, содержащий инструкции для деятельности почтового сервера.</td>
</tr>
<tr>
<td>modules.conf</td>
<td>Конфигурация модулей, которые включают специальные функции (драйвера).</td>
</tr>
<tr>
<td>motd</td>
<td>Сообщение дня. Показывается каждому, кто подключается к системе (в текстовом режиме), может быть использована системным администратором для объявления о техническом обслуживании системы и т.д.</td>
</tr>
<tr>
<td>mtab</td>
<td>Смонтированные в данный момент файловые системы. Рекомендуется никогда не редактировать этот файл.</td>
</tr>
<tr>
<td>nsswitch.conf</td>
<td><span style="background-color:yellow;">Order in which to contact the name resolvers when a process demands resolving of a host name</span>.</td>
</tr>
<tr>
<td>pam.d</td>
<td>Конфигурация модулей аутентификации.</td>
</tr>
<tr>
<td>passwd</td>
<td>Список локальных пользователей. Используйте теневые утилиты  <strong>useradd, usermod</strong> и <strong>userdel</strong> для редактирования этого файла. Правьте вручную только, когда действительно знаете что делаете.</td>
</tr>
<tr>
<td>printcap</td>
<td>Устаревший, но по-прежнему часто используемый файл конфигурации принтера. Не изменяйте его вручную, если точно не знаете, что  делаете.</td>
</tr>
<tr>
<td>profile</td>
<td>Система расширенной конфигурации среды shell: переменные, свойства по умолчанию новых файлов, ограничение ресурсов и т.д.</td>
</tr>
<tr>
<td>rc*</td>
<td>Каталоги, определяющие активные службы для каждой запущенной ступени.</td>
</tr>
<tr>
<td>resolv.conf</td>
<td>Последовательность, в которой связываются с DNS-серверами (только серверы доменных имен).</td>
</tr>
<tr>
<td>sendmail.cf</td>
<td>Главный конфигурационный файл сервера Sendmail.</td>
</tr>
<tr>
<td>services</td>
<td>Соединения, принятые на этой машине (открытые порты).</td>
</tr>
<tr>
<td>sndconfig или sound</td>
<td>Настройка звуковой карты и звуковых событий.</td>
</tr>
<tr>
<td>ssh</td>
<td>Каталог, содержащий конфигурационные файлы для защиты оболочки клиента или сервера.</td>
</tr>
<tr>
<td>sysconfig</td>
<td>Каталог, содержащий системные конфигурационные файлы: мышь, клавиатура, сеть, рабочий стол, системные часы, управление питанием т.д. (характерно для RedHat).</td>
</tr>
<tr>
<td>X11</td>
<td>Параметры графического сервера, X. RedHat использует XFree, что находит отражение в имени основного конфигурационного файла, XFree86Config. Также содержит общие каталоги оконных менеджеров, имеющихся в системе, например, <strong>gdm, fvwm, twm</strong> и т.д</td>
</tr>
<tr>
<td>xinetd.* или inetd.conf</td>
<td>Конфигурационные файлы для Интернет-сервисов, <span style="background-color:yellow;">that are run from the system's (extended) Internet services daemon (servers that don't run an independent daemon)</span>.</td>
</tr>
</table>
<p>В данном руководстве мы узнаем больше об этих файлах и изучим в деталях некоторые из них.</p>
<h2>Наиболее распространенные устройства</h2>
<p>Устройства, под которыми обычно понимается все, что принадлежит периферии ПК, что не является самим процессором, представлены в системе как запись в каталоге <span class="mono">/dev</span>. Одним из преимуществ этого UNIX-способа управления устройствами является то, что ни пользователю, ни системе не нужно  беспокоиться о спецификации устройств.</p>
<p>Пользователи, которые не знакомы с Linux или UNIX в целом, часто перегруженные количеством новых имен и понятий, должны учиться. Поэтому приведем список обычных устройств, описанных в этом введении.</p>
<p><strong>Таблица 3.4. Основные устройства</strong></p>
<table width="150">
<tr>
<td><strong>Имя</strong></td>
<td><strong>Устройство</strong></td>
</tr>
<tr>
<td>cdrom</td>
<td>CD привод</td>
</tr>
<tr>
<td>console</td>
<td>Специальный вход для используемой в настоящее время консоли.</td>
</tr>
<tr>
<td>cua*</td>
<td>Последовательные порты</td>
</tr>
<tr>
<td>dsp*</td>
<td>Устройства для оцифровки и записи</td>
</tr>
<tr>
<td>fd*</td>
<td>Записи для большинства видов гибких дисков, по умолчанию это <span class="mono">/dev/fd0</span>, дисковод для дискет по 1,44 Мбайт.</td>
</tr>
<tr>
<td>hd[a-t][1-16]</td>
<td>Стандартная поддержка дисков IDE с максимальным количеством разделов для каждого.</td>
</tr>
<tr>
<td>ir*</td>
<td>Инфракрасные устройства</td>
</tr>
<tr>
<td>isdn*</td>
<td>Управление соединением ISDN</td>
</tr>
<tr>
<td>js*</td>
<td>Джойстики</td>
</tr>
<tr>
<td>lp*</td>
<td>Принтеры</td>
</tr>
<tr>
<td>mem</td>
<td>Память</td>
</tr>
<tr>
<td>midi*</td>
<td>MIDI-плеер</td>
</tr>
<tr>
<td>mixer* и music</td>
<td>Идеализированная модель миксера (смешивает или добавляет сигналы)</td>
</tr>
<tr>
<td>modem</td>
<td>Модем</td>
</tr>
<tr>
<td>mouse (также msmouse, logimouse, psmouse, input/mice, psaux)</td>
<td>Все виды мышей</td>
</tr>
<tr>
<td>null</td>
<td>Бездонный ящик для мусора</td>
</tr>
<tr>
<td>par*</td>
<td>Записи для поддержки параллельных портов</td>
</tr>
<tr>
<td>pty*</td>
<td>Псевдотерминалы</td>
</tr>
<tr>
<td>radio*</td>
<td>Для радиолюбителей (HAM).</td>
</tr>
<tr>
<td>ram*</td>
<td>Загрузочное устройство</td>
</tr>
<tr>
<td>sd*</td>
<td>SCSI диски с их разделами</td>
</tr>
<tr>
<td>sequencer</td>
<td>Для аудио приложений, использующих особенности синтезатора звуковой карты (контроллер MIDI-устройства).</td>
</tr>
<tr>
<td>tty*</td>
<td>Виртуальные консоли моделирования терминалов vt100.</td>
</tr>
<tr>
<td>usb*</td>
<td>USB карта и сканер.</td>
</tr>
<tr>
<td>video*</td>
<td>Для использования с графической картой, поддерживающей видео.</td>
</tr>
</table>
<h2>Наиболее распространенные временные файлы</h2>
<p>В каталоге <span class="mono">/var</span>  мы находим множество каталогов, предназначенных для хранения особых непостоянных данных (в отличие от конфигурационных файлов системы, которые меняют сравнительно редко или никогда вообще). Все файлы, которые часто изменяются, например, лог-файлы, почтовые ящики, заблокированные файлы, очередь печати и т.д., хранятся в подкаталоге <span class="mono">/var</span>.</p>
<p>В качестве меры безопасности эти файлы обычно хранят отдельно от основных системных файлов, поэтому мы можем закрыть на них глаза, а где нужно устанавливать более строгие разрешения. Многие из этих файлов также требуют больше прав, чем обычно, как <span class="mono">/var/tmp</span>, который должен быть доступен для записи для всех. Основную массу пользовательской активности можно обнаружить именно здесь, которая даже может генерироваться анонимными интернет-пользователями, подключенными к вашей системе. Это одна из причин, почему каталог <span class="mono">/var</span>, включая все его подкаталоги, обычно делают на отдельном разделе. Таким образом, например, пытаются избежать риска, ведь может случиться почтовая бомба, заполняющая свободную часть файловой системы, содержащей более важные данные, такие как ваши программы и файлы конфигурации.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>  /var/tmp и /tmp</strong><br />
Файлы в <span class="mono">/tmp</span> могут быть удалены без уведомления в процессе выполнения очередных задач системы или в результате перезагрузки. В некоторых (индивидуально настроенных) системах <span class="mono">/var/tmp</span> может вести себя непредсказуемо. Тем не менее, поскольку это не так по умолчанию, мы рекомендуем использовать директорию <span class="mono">/var/tmp</span> для сохранения временных файлов. Если есть сомнения, обратитесь к системному администратору. Если вы управляете вашей системой сами, то можете быть уверены в безопасности этого места, если целенаправленно не изменяли настройки для <span class="mono">/var/tmp</span> (с правами администратора, обычный пользователь этого сделать не может).<br />
Что бы вы не делали, старайтесь придерживаться привилегий, предоставленных обычному пользователю - не сохраняйте файлы непосредственно в корневой каталог (/) файловой системы, не помещайте их в каталог <span class="mono">/usr</span> или или его подкаталог или в другое непредназначенное место. Это в значительной степени ограничивает ваш доступ к безопасной файловых систем.</p>
<p>Одной из основных систем безопасности в UNIX, и конечно в каждом дистрибутиве Linux, является журнал учета объектов, который записывает все действия пользователя, процессы, системные события и т.д. Файл конфигурации так называемого syslogdaemon определяет, какая и как долго вошедшая информация будет храниться. По умолчанию все журналы находятся в каталоге <span class="mono">/var/log</span>, содержащем различные файлы журналов доступа, серверов, системных сообщений и т.д. </p>
<p>В <span class="mono">/var</span> мы обычно находим серверные данные, которые сохраняются здесь с целью отделить их от критически важных данных, таких как сама программа-сервер и ее конфигурационные файлы. Типичным примером в системах Linux является <span class="mono">/var/www</span>, который содержит настоящие страницы HTML, скрипты и изображения, которые передал веб-сервер. FTP-дерево сервера FTP (данные, которые могут быть загружены удаленным клиентом) также лучше хранить в одном из подкаталогов <span class="mono">/var</span>. Эти данные общедоступны и часто изменяемы анонимными пользователями, поэтому безопаснее их держать здесь, подальше от разделов или каталогов с конфиденциальными данными.</p>
<p>На большинстве установленных рабочих станций <span class="mono">/var/spool</span> как минимум будет содержать <span class="mono">at</span> и каталог <span class="mono">cron</span>, содержащий запланированные задания. В офисных окружениях этот каталог также обычно содержит <span class="mono">lpd</span>, который хранит очередь(и) печати и далее файлы конфигурации принтера, а также log-файлы принтера. </p>
<p>На серверных системах мы будем обычно находить <span class="mono">/var/spool/mail</span>, содержащий входящую почту для локальных пользователей, отсортированную в один файл для каждого пользователя, "почтовый ящик пользователя". Связанный каталог <span class="mono">mqueue</span>, диспетчер очереди для неотправленных почтовых сообщений. Эти компоненты системы могут быть сильно задействованы на почтовых серверах с большим количеством пользователей. Новости серверов также используют пространство <span class="mono">/var/spool</span> из-за огромного количества сообщений, которые они должны обработать. </p>
<p>Каталог <span class="mono">/var/lib/rpm</span> специфичен для базирующихся на RPM (RedHat Package Manager) дистрибутивов; это те, в которых информация сохраняется в RPM-пакетах. Другие менеджеры пакетов обычно также сохраняют их данные где-то в <span class="mono">/var</span>.</p>
  </div>
    </div></div>
  </body>
</html>
