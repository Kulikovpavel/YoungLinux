<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Уроки по Blender Game Engine (игровому движку программы Blender)</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
        
    <div id="node-97" class="section-1">
  <h1 class="book-heading">Уроки по Blender Game Engine (игровому движку программы Blender)</h1>
  <p>Десять уроков для начинающих по игровому движку Blender (Blender Game Engine, он же BGE, он же gameBlender). Затрагиваются элементы физики движения и игровой логики. В курсе предусмотрены практические задания.</p>
  <div id="node-98" class="section-2">
  <h1 class="book-heading">Введение в Blender Game Engine (BGE). Урок 1</h1>
  <h2>1. Что такое BGE</h2>
<p>Уникальной особенностью Blender является встроенный в него так называемый "игровой движок" (англ. game engine). Это программный компонент, который позволяет создавать небольшие игры, не выходя из среды трехмерного моделирования Blender.</p>
<p>Game engine:</p>
<ol>
<li>придает объектам "физические" свойства; объекты начинают вести себя так, как в реальном мире: падают под действием силы тяжести, сталкиваются и т.д. (возможно следует отметить, что в этом смысле движок еще "сыроват");</li>
<li>позволяет наблюдать поведение объектов в реальном времени и воздействовать на них; </li>
<li>записывает происходящее в режиме игры в анимацию;</li>
<li>позволяет визуально настраивать (программировать) поведение и взаимодействие объектов;</li>
<li>а также встраивать скрипты на языке программирования Python.</li>
</ol>
<p>Режим игры – это режим действия игрового движка. Он запускается при нажатии клавиши P на клавиатуре. Выход из него – клавиша Esc. Лучше перед запуском игры переключиться в режим отображения текстур (Alt+Z).</p>
<p><strong>Задание.</strong> <em>Расположите на сцене плоскость и любой другой меш-объект над ней. Включите режим отображения текстур, затем режим игры. После выйдите из режима игры.</em></p>
<p>Для настройки поведения объектов для режима игры предназначена панель кнопок Logic (F4). На этом уроке мы рассмотрим ее левую часть – настойки объекта.</p>
<h2>2. Типы объектов</h2>
<p>В реальном мире объекты сделаны из различных материалов и, естественно, обладают различными свойствами.<br />
Игровой движок (BGE), конечно, не позволяет симулировать такое разнообразие, но кое-что может. К тому же, BGE позволяет манипулировать и "нефизическими объектами", т.е. теми для которых как бы нет влияющего окружающего мира (в реальном мире таких объектов не существует).</p>
<p>Тип выбранного объекта (например, куба) задается с помощью меню Object Type.</p>
<div style="text-align:center;"><img src="../../../img/bge/typeob.gif" alt="Типы объектов в Blender Game Engine" title="Типы объектов в Blender Game Engine" style="width:350px; height:218px;" /></div>
<p><strong>Occluder</strong> (occlude – закрывать, преграждать). В определенных условиях увеличивает производительность путем исключения объектов, расположенных за объектом-«окклюдером». Уместно использовать в сложных сценах.</p>
<p><strong>No collision</strong> (collision - столкновение). Отключает у объекта возможность столкновения с другими объектами. Т.е. если dynamic-объект встретит на своем пути no_collision-объект, то пройдет сквозь него, как будто его нет. Рекомендуется использовать для объектов, которые никогда ни с чем не столкнуться: выбор этого типа объекта увеличивает производительность игры.</p>
<p><strong>Sensor</strong> (датчик). Предназначен для более сложного управления столкновениями.</p>
<p><strong>Static</strong> (статический, неподвижный). Такой тип объекта может участвовать во взаимодействиях с физическими объектами (играть роль препятствий), хотя на него не влияют никакие виртуальные физические силы. В режиме игры он может быть перемещен за счет изменения своего положения, но не под влиянием сил. Два static-объекта при пересечении их путей не сталкиваются, а проходят сквозь друг друга.</p>
<p><strong>Dynamic</strong> (динамический). Объект, на который "действуют" законы физики: сила тяжести, масса, воздействие внешних сил, ускорение и др.</p>
<p><strong>Rigid body</strong> (твердое тело). Более реально ведущий себя по сравнению с Dynamic "физический" объект.</p>
<p><strong>Soft body</strong> (мягкое тело). "Физический" объект, который ведет себя подобно резиновому мячу или мягкой игрушке, т.е деформируется (изменяет свою форму) при столкновениях с другими объектами.</p>
<p>Опыт 1. <strong>Типы объектов</strong><br />
Для того, чтобы сразу протестировать как ведут себя некоторые типы объектов в режиме игры, расположим несколько сфер над плоскостью и нажмем P. Вот что мы увидим по прошествии нескольких секунд:</p>
<div style="text-align:center;"><img src="../../../img/bge/sphere.gif" alt="Поведение объектов в Blender в режиме игры (P)" title="Поведение объектов в Blender в режиме игры (P)" style="width:800px; height:164px;" /></div>
<p>Видно, что с объектов типа Static ничего не произошло, Dynamic, Rigid Body и Soft Body упали под действием виртуальной силы тяжести. Причем Soft Body упал и слегка «размазался», как и положено мягкому телу, но почему-то меш-объект остался прежнего размера (это недоработка Blender или как-нибудь настраивается отдельно? Примечание: если при создании сферы сразу указать небольшой размер, то она будет мелкой при создании из нее мягкого тела).</p>
<p>Опыт 2. <strong>Dynamic и Rigid body</strong><br />
Чтобы заметить разницу между Rigid body и Dynamic, развернем плоскость на 50 по оси Y или X. Теперь можно наблюдать, что при падении Rigid Body продолжает свое движение как естественный объект (также ведет себя и Soft Body), а Dynamic остается спокойно лежать на плоскости. Конечно, если наклон плоскости сделать больше, то вниз покатится и динамический объект.</p>
<div style="text-align:center;"><img src="../../../img/bge/rigidbody.gif" alt="Отличие между объектами Dynamic и Rigid Body в Blender" title="Отличие между объектами Dynamic и Rigid Body в Blender" style="width:500px; height:263px;" /></div>
<h2>3. Настройки</h2>
<p>В предыдущем опыте можно заметить, что при смене типа объектов меняются кнопки настоек ниже. Здесь основная часть настроек свойств объекта. Рассмотрим некоторые.</p>
<div style="text-align:center;"><img src="../../../img/bge/properties.gif" alt="Настройки объектов Rigid Body и Soft Body в Blender" title="Настройки объектов Rigid Body и Soft Body в Blender" style="width:800px; height:198px;" /></div>
<h4>Общие:</h4>
<p><strong>Actor</strong> (актер). Для версии 2.49 осталось непонятным, на что влияет данных параметр.<br />
<strong>Ghost</strong> (призрак). Объект будет проходить сквозь другие объекты при столкновении с ними, при этом никак на них не влияя.<br />
<strong>Invisible</strong> (невидимый). Объект становится невидимым, но присутствует на сцене. Объект-невидимка может взаимодействовать с другими объектами.<br />
<strong>Mass</strong> (масса). Виртуальная масса объекта. Настройка данного параметра имеет большое значение для "физических" объектов при воздействии на них той или иной силы. Чем больше масса, тем больше нужно приложить силы для ее перемещения.</p>
<h4>Rigid body:</h4>
<p><strong>Radius</strong> (радиус). Влияет на площадь взаимодействия с объектом. Радиус виден как розовая пунктирная окружность в 3D окне. Если не виден, то увеличьте значение. Фактически границы окружности и определяют размер взаимодействующей области (объекта).<br />
<strong>No sleeping</strong> (не спящий). При включении-отключении данной опции в версии 2.49 изменений в поведении объекта при применении к нему силы замечено не было.<br />
Остальные настройки пока опустим, т.к. они достаточно специфичны и требуют начальных знаний физики.</p>
<h4>Soft body:</h4>
<p><strong>Shape Match</strong> (shape – форма, match – выравнивать, противостоять и др.). Если кнопка будет выключена, то объект не сохранит свою форму, а сложится как тряпка (при достаточном количестве вершин).<br />
<strong>Bending Const</strong> (bending – сгибание, constraints – ограничения). Если отключить данную кнопку, то объект при столкновении будет сильнее изменять свою форму.<br />
<strong>kMT</strong>. Влияет на упругость объекта, связана с Shape Match. Увеличив данное значение, например, у сферы, вы получите объект поведением похожий на мяч.</p>
<h2>4. Практическая работа</h2>
<ol>
<li>Разместите на сцене плоскость, увеличьте ее. Над плоскостью друг над другом расположите три одинаковых куба, каждый куб должен быть<br />
объектом Rigid body. Запустив режим игры, отметьте, как упали кубики. </li>
<li>У среднего куба увеличьте Radius до значения 1.5. Снова запустите игру и отметьте изменения. </li>
<li>Включите для среднего куба кнопку Invisible и снова запустите режим игры. Участвует ли невидимый куб во взаимодействии объектов?</li>
<li>Удалите со сцены все три куба. Добавьте сферу с 16-тью сегментами и кольцами (уменьшение частей меш-объектов влияет на производительность),<br />
расположив ее над плоскостью. Сделайте ее объектом Soft body и продублируйте по оси X четыре раза (все пять объектов должны быть над плоскостью,<br />
увеличьте плоскость при необходимости). Желательно развернуть камеру таким образом, чтобы она "смотрела" прямо на ось X.</li>
<li>Для первого объекта Soft body оставьте значения настроек по умолчанию. У второго – увеличьте значение kMT почти до единицы.<br />
У третьего – отключите Shape Match, у четвертого – Bending Const, а у пятого – обе кнопки.</li>
<li>Запустите режим игры. Отметьте изменения каждой из сфер. Если разница между первой и четвертой сферой? В чем она заключается?</li>
</ol>
  </div>
<div id="node-101" class="section-2">
  <h1 class="book-heading">Сенсоры, контроллеры и активаторы. Урок 2</h1>
  <div style="text-align:center;">
<h4>Уроки по Blender Game Engine</h4>
</div>
<p>Панель Logic (F4) можно условно разбить на четыре части настроек: свойства объекта (рассмотренные на прошлом уроке), сенсоры, контроллеры и активаторы. <strong>Сенсоры</strong> объекта позволяют ему воспринимать различные внешние «раздражители», такие как нажатие клавиши, движение мыши, касание другого объекта и др. <strong>Контроллеры</strong> в основном предназначены для связывания определенным образом сенсоров и активаторов. <strong>Активаторы</strong> могут выполнять различные действия над данным объектом или другими. Некоторые настройки активаторов могут различаться у разных типов объектов.<br />
Для того чтобы добавить очередной сенсор, контроллер и активатор нужно нажать на кнопку <strong>ADD</strong>. Связь между ними обозначается линиями, которые создаются, если зажав ЛК мыши потянуть ей от одного узелка к другому (линию можно удалить, если навести мышь и нажать клавишу Del). У объекта может быть множество групп сенсоров, контроллеров и активаторов.</p>
<div style="text-align:center;"><img src="../../../img/bge/blocks.gif" width="830" height="308" alt="Сенсоры, контроллеры и активаторы в BGE" /></div>
<p>На этом уроке будет описано, как управлять объектом <strong>Static</strong> с помощью клавиатуры. Роль объекта сыграет стрелка, поворачивающаяся по двум осям и двигающаяся указателем вперед.</p>
<h2>1. Создание объекта</h2>
<p>Сначала создадим объект. Можно  использовать любой меш-объект, но желательно, чтобы он был ассиметричен, т.к. в этом случае легче будет наблюдать его повороты. </p>
<div style="text-align:center;"><img src="../../../img/bge/arrow.gif" width="340" height="191" alt="Модель стрелки в Blender" /></div>
<p>Такую стрелку можно получить множеством способов. Ниже описан один из них:</p>
<ol>
<li>Вид сверху.</li>
<li>Добавить плоскость.</li>
<li>Перейти в режим редактирования. Удалить нижнюю правую вершину. Выделить три оставшиеся, нажать F (получиться треугольная плоскость). Далее, не снимая выделения, повернуть плоскость по оси Z на 450, таким образом, чтобы будущий указатель «смотрел» вверх (вдоль оси Y).</li>
<li>Не выходя из режима редактирования, добавить еще одну плоскость ниже. Сжать ее по оси X, переместить под указатель; – это ножка стрелки.</li>
<li>Вид из камеры.</li>
<li>Выбрать режим выделения граней и выдавить (экструдировать), тем самым придав стрелке объем. </li>
<li>Выйти из режима редактирования.</li>
</ol>
<h2>2. Движение вперед</h2>
<p>Заставим нашу стрелку двигаться указателем вперед при нажатии на клавишу <em>Пробел</em>.<br />
Выделив стрелку (которая должна быть static-объектом), добавьте сенсор, контроллер и активатор и соедините их между собой.</p>
<div style="text-align:center;"><img src="../../../img/bge/move.gif" width="769" height="148" alt="Добавление сенсора, контроллера и активатора в Blender" /></div>
<p>По умолчанию в качестве сенсора выступает <strong>Always</strong> (всегда). Такой сенсор будет действовать постоянно. Нам это не подходит. В выпадающем списке выбираем <strong>Keyboard</strong> (клавиатура). Нажимаем в поле <strong>Key</strong> мышью, затем нажимаем клавишу <em>Пробел</em> (Space).</p>
<div style="text-align:center;"><img src="../../../img/bge/sensor.gif" width="322" height="228" alt="Сенсор Keyboard" /></div>
<p>Теперь настроим активатор. Активаторы бывают разные (это на будущее). По умолчанию стоит <strong>Motion</strong> (движение). В нижней части есть две строки: <strong>Loc</strong> (location – положение) и <strong>Rot</strong> (rotation – вращение). В каждой строке по три поля: в них задаются величины изменений по оси X, Y или Z при воздействии.</p>
<div style="text-align:center;"><img src="../../../img/bge/axis.gif" width="464" height="216" alt="Активатор Motion" /></div>
<p>Поскольку наша стрелка должна двигаться вперед и для нее это ось Y, то следует изменить значение в первой строке во втором столбце. Щелкните по нулям там и пропишите значение в 0.05.<br />
Теперь при запуске режима игры (P) и нажатии на клавишу пробел стрелка будет двигаться вперед.</p>
<h2>3. Повороты</h2>
<p>Для того, чтобы стрелка при движении могла оказаться в любой точке трехмерного пространства достаточно настроить ее поворот только по двум осям: X (повороты вверх и вниз) и Z (налево и направо). Поворачиваться стрелка будет при нажатии на стрелки на клавиатуре. Требуется добавить еще четыре группы сенсоров, контроллеров и активаторов.</p>
<div style="text-align:center;"><img src="../../../img/bge/rotation.gif" width="971" height="663" alt="Управление объектом Static в Blender Game Engine" /></div>
<p>Теперь, запустив режим игры, можно передвинуть стрелку в любое место 3D-окна, предварительно повернув ее с помощью стрелок  на клавиатуре.</p>
<h2>4. Локальные и глобальные оси</h2>
<p>В конце строк настроек <strong>Loc</strong> и <strong>Rot</strong> есть переключатели <strong>L</strong>. По умолчанию эти кнопки нажаты и обозначают локальную привязку осей. Это означает, что оси X, Y и Z как бы находятся внутри объекта и при его повороте поворачиваются вместе с ним. Поэтому-то у нас стрелка все время двигается указателем вперед, как ее не поверни.<br />
Если выключить кнопку <strong>L</strong> напротив <strong>Loc</strong> в блоке, отвечающем за движение по оси Y, то стрелка будет двигаться только в одном направлении (по глобальной оси Y) не зависимо от поворота своего указателя. Глобальные оси в 3D-окне обозначаются красной (X), зеленой (Y) и синей (Z) линиями. </p>
<h2>5. Практическая работа</h2>
<ol>
<li>Создайте модель стрелки и задайте ей возможность движения и поворота с помощью Blender Game Engine так, как описано в уроке. </li>
<li>Исследуйте влияние на движение стрелки включенной и отключенной Local Transformation (кнопка <strong>L</strong>).</li>
<li>Добавьте на сцену плоскость и пару других меш-объектов, расположив их над плоскостью. Исключая плоскость и стрелку, задайте для объектов тип <strong>Rigid body</strong>. Запустите режим игры и попробуйте столкнуть объекты с плоскости с помощью стрелки.</li>
</ol>
<div style="text-align:center;"><img src="../../../img/bge/scene.gif" width="492" height="337" alt="Управление объектом Static в Blender Game Engine" /></div>
  </div>
<div id="node-102" class="section-2">
  <h1 class="book-heading">Сила (force) и физические объекты в Blender Game Engine. Урок 3  </h1>
  <h2>1. Физика в Blender</h2>
<p>	Когда к объекту в Blender применяется тип <strong>Dynamic</strong>, <strong>Rigid</strong> или <strong>Soft body</strong>, то в режиме игры их поведение становится похожим на поведение реальных объектов в области притяжения Земли (эти настройки можно изменить: например, эмулировать невесомость). В реальном мире плотные объекты не висят в воздухе, а падают на поверхности; при столкновении объекты могут отскакивать; для перемещения объекта с большей массой требуется приложить больше силы и т.д.</p>
<h2>2. Активатор Motion</h2>
<p>	Для физических объектов у активатора <strong>Motion</strong> появляются дополнительные строки настроек (помимо <strong>Loc</strong> и <strong>Rot</strong>, которые также есть у статических объектов и отвечают за перемещение и поворот объекта).</p>
<div style="text-align:center;"><img src="../../../img/bge/motion3.gif" width="574" height="259" alt="Сравнение активатора Motion для статических и динамических объектов" /></div>
<p><strong>Force (сила)</strong>. Воздействие на объект с заданной силой и направлением. В отличие от <strong>Loc</strong>, объект не перемещается самостоятельно, а на него как бы действует сторонняя сила.<br />
<strong>Torque (вращающий момент)</strong>. Сила действует таким образом, что заставляет объект вращаться, а не перемещаться.</p>
<h2>3.Force</h2>
<p>	Разместим на сцене плоскость и куб на ней. Добавив сенсор, контроллер и активатор и связав их между собой, увеличим значение <strong>Force</strong> по оси Х или Y.</p>
<div style="text-align:center;"><img src="../../../img/bge/force.gif" width="778" height="210" alt="Активатор Motion, изменение Force" /></div>
<p>	В режиме игры объект будет двигаться, как и при влиянии <strong>Loc</strong>, однако он будет двигаться с ускорением, т.к. сила действует постоянно и постепенно разгоняет объект. После прекращения воздействия, объект останавливается не сразу, а постепенно (в отличие от <strong>Loc</strong>). </p>
<h2>4. Local transformation и Rigid body</h2>
<p>	На объекты <strong>Rigid body</strong> сильное влияние оказывает привязка осей (X, Y, Z) к самому объекту или к 3D-миру. Если не выключить кнопку <strong>L</strong>, то объект не будет двигаться по направлениям пространства, а будет покачиваться на одном месте. Это связано с тем, что ось объекта при его повороте меняет свое направление, и тогда сила действует с другой стороны с точки зрения 3D-мира.</p>
<h2>5. Влияние массы объекта</h2>
<p>	Обратите внимание на значение в строке <strong>Force</strong>. Заметные влияния на объект здесь возникают при изменении значения на единицы, а не на дробные значения как в случае <strong>Loc</strong>. Применение одной и той же силы к объектам разной массы оказывает различное влияние на них. Так если объект <strong>Dynamic</strong> с установленной виртуальной массой в 2 единицы попытаться сдвинуть с помощью 2 «виртуальных ньютонов», то ничего не получится. Объект же массой в 0.5 единиц будет передвигаться. Примечание: объекты <strong>Rigid body</strong> и <strong>Soft body</strong> ведут себя немного по-другому.</p>
<div style="text-align:center;"><img src="../../../img/bge/mass3.gif" width="681" height="359" alt="Различное значение mass при одинаковом force в BGE" /></div>
<h2>6. Ось Z</h2>
<p>	Для того, чтобы придать объекту движение с помощью Force по осям X и Y достаточно значения сопоставимого с массой объекта или немного больше ее. Однако движение по оси Z в положительном направлении (вверх) требует применения силы большего значения. Вспомним, что находясь в поле Земли объекты притягиваются к ней с ускорением свободного падения равным примерно 9.8 м/с<sup>2</sup>. Чтобы преодолеть силу притяжения Земли и подбросить объект вверх, требуется сообщить ему большее ускорение, чем 9.8. Примечание: значение Force по оси Z не обязательно должно быть больше 9.8; объекты массой меньше единицы поднимаются вверх и при меньших значениях силы.</p>
<h2>7. Роль центра объекта при движении</h2>
<p>У любого меш-объекта в Blender есть центральная точка (в BGE она играет роль центра тяжести объекта). Объект всегда вращается вокруг нее и именно на нее действует сила. Для того, чтобы увидеть как от смены центра тяжести изменяется поведение объекта можно проделать следующий опыт. Расположим на сцене два одинаковых сплюснутых  цилиндра. Оба – Dynamic, при нажатии на клавишу <em>Space</em> (пробел) на них воздействует Torque (вращающий момент по оси Z) в 2-3 единицы. Центральная точка одного из цилиндров смещена к его границе.</p>
<div style="text-align:center;"><img src="../../../img/bge/center.gif" width="668" height="419" alt="Влияние расположения центра объекта на его движение в Blender" /></div>
<p>В режиме игры при нажатии на клавишу <em>Пробел</em> один цилиндр будет крутиться на месте, а второй совершать круговые движения, описывая окружность.</p>
<h2>8. Практическая работа</h2>
<ol>
<li>Расположите на сцене три объекта Dynamic или Rigid body (для Rigid обязательно отключите <strong>L</strong>), установите им различную между собой массу на панели <strong>Logic</strong>. Добавьте сенсор, контроллер и активатор каждому объекту. В качестве сенсора установите Keyboard (в качестве Key пусть будет клавиша <em>Пробел</em>). Для всех объектов примените одинаковую силу по оси X или Y. Найдите такое значение силы, при которой объект, обладающий большей массой, почти не перемещается при воздействии силы, остальные – двигаются. Оцените взаимосвязь массы и силы.</li>
<li>Расположите два Dynamic-шара. Одному из них задайте постоянную силу воздействия вниз. Падает ли он быстрее, чем другой шар? Расположите шар виртуальной массой в 5 единиц на плоскости. Найдите значение минимальной силы способной при постоянном воздействии оторвать шар от плоскости.</li>
<li>Добавьте на сцену два вытянутых по оси Z Rigid-цилиндра. Сместите одному центральную точку к верхней части, а другому – к нижней. Задав силу воздействия по оси X или Y, оцените поведение объектов. Примечание: для цилиндров измените границу с <strong>Box</strong> на <strong>Convex Hull</strong> (выпуклая оболочка); для этого предварительно следует нажать кнопку <strong>Bounds</strong> (границы).</li>
</ol>
<div style="text-align:center;"><img src="../../../img/bge/bounds3.gif" width="305" height="178" alt="Настройка границ объекта в Blender Game Engine" /></div>
  </div>
<div id="node-104" class="section-2">
  <h1 class="book-heading">Взаимодействие объектов в Blender Game Engine. Урок 4  </h1>
  <div style="text-align:center;"><img src="../../../img/bge/wall.gif" width="400" height="452" alt="модель в Blender Game Engine" /></div>
<p>Игровой движок Blender’а позволяет виртуальным объектам вести себя подобно объектам реального мира. Следовательно, результат взаимодействия объектов Dynamic, Rigid и Soft body в Blender Game Engine должен зависеть от настроек их массы, а также сил, влияющих на них. Рассмотрим это на примере.<br />
	У нас будет стена из кирпичей и шар, разбивающий ее. По отношению к шару можно будет прикладывать разную силу. В зависимости от приложенной силы шар может разрушать стену или нет.</p>
<p>Стена состоит из кирпичей, каждый из которых представляет собой измененный куб типа Rigid body. При взаимодействии объектов важно настроить свойство <strong>Bounds</strong> (границы). В данном случае лучше использовать тип <strong>Convex hull</strong> (выпуклая оболочка).</p>
<div style="text-align:center;"><img src="../../../img/bge/bounds3.gif" width="305" height="178" alt="Настройка границ объектов для игрового режима Blender" /></div>
<p>С помощью дублирования (Shift + D) создаем стену из кирпичей. Здесь важно плотно подогнать один к другому. В режиме игры стена должна оставаться целой, а не разваливаться. Последнее может случиться, если неправильно настроены границы объектов или кирпичи неправильно расположены  относительно друг друга.</p>
<div style="text-align:center;"><img src="../../../img/bge/cub.gif" width="400" height="242" alt="Стена из блоков в Blender" /></div>
<p>Добавляем на сцену сферу, устанавливаем для нее также тип Rigid body и располагаем на некотором расстоянии от стены. При нажатии на клавишу с цифрой 1 на клавиатуре шар должен двигаться в направлении стены в результате приложения к нему силы. Следует выключить кнопку <strong>L</strong>.</p>
<div style="text-align:center;"><img src="../../../img/bge/force4_1.gif" width="600" height="162" alt="Настройка сенсора, контроллера и активатора" /></div>
<p>Сила при нажатии на клавишу с единицей постоянно воздействует на шар. Чем дольше мы жмем, тем больше сила воздействия. На самом деле трудно определить, сколько силы было передано шару. Так может оказаться, что при воздействии меньшей силы, но на протяжении большего времени, шару суммарно было сообщено больше воздействия, чем при моментальном воздействии большей силы. Чтобы избежать недоразумений, в Blender Game Engine можно сделать так, что шару будет сообщаться сила только тогда, когда он находится в определенном месте или в течение строго определенного временного интервала.<br />
Наша сфера будет испытывать воздействие силы лишь тогда, когда касается красной маленькой плоскости. Для этого нужно добавить к сфере сенсор <strong>Touch</strong> (касание) и связать его с уже существующим контроллером. В поле <strong>MA</strong> следует прописать материал, при касании которого будет срабатывать сенсор <strong>Touch</strong>. Имя материала можно найти на панели кнопок <strong>Shading</strong> (F5).</p>
<div style="text-align:center;"><img src="../../../img/bge/touch.gif" width="670" height="390" alt="Настройка сенсора touch" /></div>
<p>	Два сенсора связаны с одним контроллером типа <strong>AND</strong>. Это означает, что активатор сработает лишь в том случае, если сигнал будет поступать от обоих сенсоров. В данном случае, должна быть зажата клавиша с единицей и объект должен касаться материала start. Если зажата единица, но нет касания start (или, наоборот, есть касание, но нет сигнала с клавиатуры), то активатор не будет запускаться.<br />
	Шар должен находиться над красной плоскостью. В режиме игры к шару будет прикладываться сила лишь в момент его нахождения на плоскости, а не на протяжении всего пути (при зажатой клавише 1). В дальнейшем это позволит трезво оценить, как влияет размер приложенной к шару силы на его способность разрушать стену.<br />
	Добавим также еще два комплекта сенсоров, контроллеров и активаторов. Настроим их также как и первый, за исключением величины прикладываемой силы и клавиш-сенсоров. Может быть один сенсор Touch, связанный с несколькими контроллерами. Также неплохо было бы добавить возможность перезагрузки без выхода из режима игры: активатор <strong>Scene –> Restart</strong>.</p>
<div style="text-align:center;"><img src="../../../img/bge/break_wall.gif" width="779" height="571" alt="Настройка сенсора touch" /></div>
<p>	Требуется установить такие величины силы, чтобы в первом случае стена почти не разрушалась, а во втором – разрушалась меньше, чем в третьем.<br />
	На примере этой модели видно, что скорость шара (и как следствие его разрушающая способность) зависит от величин приложенной к нему силы. Эта зависимость есть в реальном мире, к которому мы привыкли, она эмулируется и в Blender Game Engine.</p>
<h2>Практическая работа</h2>
<ol>
<li>Создайте модель, описанную в уроке. </li>
<li>Определите с помощью BGE, как влияет расстояние между шаром и стеной на разрушение последней. С чем это связано?</li>
<li>Создайте модель известной физической закономерности: рычаг уравновешен, когда произведение массы на длину одного плеча равно произведению массы на длину другого плеча. В модели должна быть возможность передвигать виртуальные массы (например, кубики) по бревну, добиваясь равновесия.</li>
</ol>
  </div>
<div id="node-105" class="section-2">
  <h1 class="book-heading">Сенсор Mouse. Урок 5</h1>
  <div style="text-align:center;">
<h4>Уроки по Blender Game Engine</h4>
</div>
<div style="text-align:center;"><img src="../../../img/bge/mouse.gif" width="574" height="304" alt="Сенсор Mouse в Blender Game Engine" /></div>
<h2>Отображение курсора мыши в режиме игры</h2>
<p>Среди множества сенсоров в BGE есть и сенсор <strong>Mouse</strong> (мышь), улавливающий различные манипуляции мыши (щелчки кнопками мыши, движение, прокручивание колеса и др.). Однако, при запуске режима игры (P) мы не видим курсор мыши. Чтобы отобразить курсор нужно прописать небольшой скрипт. Для этого разделите 3D-окно на две части, одну из них поменяйте на окно <strong>Text Editor</strong>. Далее раскройте меню <strong>Text</strong> и выберите пункт <strong>New</strong>. По умолчанию первый скрипт будет называться <strong>Text.001</strong>, лучше ему дать более осмысленное имя (например, <strong>mouse</strong>). Затем в окне следует ввести следующие строки:<br />
<div class="geshifilter"><pre class="python geshifilter-python" style="font-family:monospace;"><span style="color: #ff7700;font-weight:bold;">import</span> Rasterizer 
Rasterizer.<span style="color: black;">showMouse</span><span style="color: black;">&#40;</span><span style="color: #ff4500;">1</span><span style="color: black;">&#41;</span></pre></div></p>
<p>В первой строке импортируется модуль, а во второй – вызывается функция showMouse, позволяющая отобразить курсор мыши в режиме игры.</p>
<div style="text-align:center;"><img src="../../../img/bge/text_editor.gif" width="546" height="353" alt="Скрипт для отображения курсора мыши в режиме игры в BGE" /></div>
<p>	Однако, это еще не все. Нужно привязать данный скрипт к какому-либо объекту на сцене (допустим камере). Для того, чтобы курсор отображался всегда, следует добавить активатор <strong>Always</strong> и связанный с ним контроллер <strong>Python</strong>, где в качестве <strong>Script</strong> указывается имя того скрипта, который был создан ранее (в нашем случае, это <strong>mouse</strong>). Активатор в данном случае не требуется. После этого в режиме игры курсор будет виден. </p>
<div style="text-align:center;"><img src="../../../img/bge/camerascript.gif" width="549" height="139" alt="Отображение курсора мыши в режиме игры в BGE: панель Logic" /></div>
<h2>Управление 3D-объектами с помощью мыши в Blender Game Engine</h2>
<div style="text-align:center;"><img src="../../../img/bge/mousesphere.gif" width="811" height="548" alt="Движение 3D-объекта с помощью мыши в BGE: панель Logic" /></div>
<p>	Пусть на сцене будет плоскость и Rigid-сфера на ней. Сфера будет управляться с помощью мыши следующим образом:</p>
<ol>
<li>Если сфера находится на плоскости (а не в «воздухе»), то щелчок левой кнопкой мыши по ней должен «сообщать» силу, приводящую ее в движение вверх.</li>
<li>Прокрутка колеса мыши вверх и вниз должна «сообщать» сфере вращающий момент (Torque) по оси Z по часовой и против часовой стрелки.</li>
</ol>
<p>Разберем, как это сделать. Добавив сенсор <strong>Mouse->Left button</strong> и связав его с активатором <strong>Motion</strong>, мы заставим сферу лететь вверх при нажатии левой кнопкой мыши в любом месте 3D-окна (в режиме игры). Тут две проблемы: во-первых, сфера взлетает от щелчка в любом месте экрана, а во-вторых, она летит даже тогда, когда уже находится не на плоскости. Проблемы решаются с помощью добавления еще двух сенсоров к уже существующим контроллеру и активатору. Один должен быть <strong>Mouse -> Mouse over</strong>, второй – <strong>Touch</strong>.<br />
За прокрутку колеса отвечают сенсоры <strong>Mouse -> Wheel up </strong>(вверх) и <strong>Mouse -> Wheel down</strong> (вниз). Каждому следует добавить свой контроллер и активатор. </p>
<h2>Практическая работа</h2>
<ol>
<li>Расположите на сцене три любых объекта на плоскости. Установите для них тип Rigid body. При щелчке левой кнопкой мыши по каждому отдельному объекту он должен отскакивать в какую-нибудь сторону, а при щелчке правой кнопкой мыши в любом месте 3D-окна все объекты должны взлетать вверх.</li>
<li>На новой сцене расположите сферу (Rigid body) и плоскость под ней. Пусть любое движение мыши (Movement) заставляет объект крутиться по оси X или Y, а щелчок левой кнопкой мыши «сообщает» силу движения вперед в выбранном направлении. Отметьте, есть ли разница в скорости между двумя случаями: 1) сначала сфера крутится, а затем получает толчок вперед, 2) сфера сразу толкается вперед. </li>
</ol>
  </div>
<div id="node-106" class="section-2">
  <h1 class="book-heading">Управление камерой в Blender Game Engine. Урок 6</h1>
  <p>Далеко не редкими бывают ситуации, когда сцена слишком большая для полноценного ее обзора с помощью неподвижной камеры. Поэтому необходимо, чтобы камера двигалась, следя за объектами, или на сцене присутствовали несколько камер, между которыми можно было бы переключаться. Допустим, мы придумали игру, в которой шар должен преодолеть препятствия, перепрыгивая их, не толкая при этом (иначе перегородки упадут). Путь,  который шар должен пройти очень длинный. Если камера все время остается на месте, то стоит шару немного продвинуться вперед, как станет трудно или невозможно им управлять.</p>
<div style="text-align:center;"><img src="../../../img/bge/camera1.gif" width="500" height="323" alt="Blender Game Engine: вид из камеры" /></div>
<p><strong>1. Связь родитель-потомок (Ctrl+P)</strong></p>
<p>Данная связь широко используется в Blender для того, чтобы изменения объекта-«родителя» сразу приводили к изменениям объектов-«детей» (но не наоборот). Если «предок» меняет свое положение, размер, поворот, то следом за ним эти свойства изменяются и у «потомка». Для примера описанного выше, это означает, что если установить шар в качестве родителя, а камеру в качестве потомка, то любое перемещение шара, в том числе и в режиме игры, заставит камеру двигаться за ним.</p>
<p>Связь устанавливается так:</p>
<ol>
<li>Сначала выделяется потомок (в данном случае, камера).</li>
<li>Затем (с зажатой клавишей Shift) выделяется предок (в данном случае, шар).</li>
<li>Для установки связи родитель-потомок следует нажать комбинацию клавиш <strong>Ctrl+P</strong> (если в дальнейшем потребуется снять связь, то следует выделить оба предмета и нажать <strong>Alt+P</strong>).</li>
</ol>
<p>Однако запустив режим игры можно столкнуться с проблемой: шар не только двигается, но и поворачивается. Следом за ним будет вертеться и камера, вид из камеры при этом будет варьировать от странного до еще более странного. Чтобы камера не вертелась, ее можно привязать не к целому объекту, а к его любой вершине. Вершина – это точка. Точки не вертятся. Тогда последовательность действий будет такой:</p>
<ol>
<li>Выделить камеру.</li>
<li>Выделить шар-родитель (с зажатым Shift).</li>
<li>Переключиться в режим редактирования.</li>
<li>Выделить любую вершину шара.</li>
<li>Нажать <strong>Ctrl+P</strong>. Выбрать <strong>Make vertex parent</strong> (сделать вершину родителем).</li>
<li>Выйти из режима редактирования. </li>
</ol>
<p><strong>2. Активатор Camera</strong></p>
<p>	Есть еще один способ постоянно следить за выбранным объектом: использовать активатор Camera. Сделать это можно следующим образом. Для камеры добавить связанные между собой сенсор <strong>Always</strong>, контроллер и активатор <strong>Camera</strong>. В поле <strong>OB</strong> активатора прописать имя того объекта, за которым планируется следить.</p>
<div style="text-align:center;"><img src="../../../img/bge/camera2.gif" width="700" height="74" alt="Активатор Camera" /></div>
<p>	Изначально настройки <strong>Height</strong> (высота камеры над объектом), <strong>Min</strong> и <strong>Max</strong> (минимальное и максимальное расстояния от камеры до объекта) равны нулю. Однако лучше их изменить. Если требуется, чтобы камера смотрела на объект больше сбоку, чем сверху, то Height не должна иметь большое значение. </p>
<p>Активатор Camera обеспечивает более плавное слежение за объектом, чем связь родитель-потомок. При резких движениях объекта камера двигается более мягко; если объект неподвижен, камера все равно продолжает немного двигаться и поворачиваться (по оси X или Y). Недостатком этого способа слежения является то, что если объект вертится, то камера иногда прокручивается так, что управлять объектом становится неудобно.</p>
<p><strong>3. Слежение за разными объектами</strong></p>
<p>	Бывает, что на 3D-сцене сначала необходимо следить за одним объектом, а затем за другим. Чтобы реализовать такую возможность, можно создать для камеры не одну группу сенсоров, контроллеров и активаторов Camera. Каждый активатор может приводиться в действие нажатием клавиши или щелчком мыши. Тогда в режиме игры можно будет переключать вид с одного объекта на другой. </p>
<div style="text-align:center;"><img src="../../../img/bge/camera3.gif" width="700" height="252" alt="Камера может следить за несколькими объектами в BGE" /></div>
<p><strong>4. Обзор сцены из разных камер</strong></p>
<p>Когда требуется не следить за конкретным объектом, а просто обозревать сцену с разных точек зрения, то возможно уместней установить несколько камер и предусмотреть возможность переключаться между ними в режиме игры. Для установки камеры используется активатор <strong>Scene -> Set Camera</strong>. </p>
<div style="text-align:center;"><img src="../../../img/bge/camera4.gif" width="700" height="261" alt="Активатор Set Camera в BGE" /></div>
<p><strong> Практическая работа</strong></p>
<ol>
<li>Используя возможности игрового движка Blender, создайте сцену, в которой объект может перемещаться по плоскостям, расположенным вертикально по отношению друг к другу. </li>
<li>Установите слежение за объектом с помощью связи родитель-потомок. Сохраните файл. </li>
<li>Установите слежение за объектом с помощью активатора Camera. Сохраните файл под другим именем.</li>
<li>Откройте оба файла и сравните движение камеры за объектом.</li>
<li>Создайте 3D-сцену с несколькими объектами. Задайте возможность в режиме игры переключать вид камеры с одного объекта на другой.</li>
<li>Добавьте на новую сцену две плоскости, разместив на них по любому объекту. Растащите их таким образом, чтобы одна плоскость была хорошо видна в одной камере, при этом вторая виднелась вдалеке. Во второй камере должна быть хорошо видна другая плоскость, а первая – где-то вдалеке. Организуйте возможность переключения между камерами с помощью щелчка левой кнопкой мыши по плоскости вдалеке.</li>
</ol>
  </div>
<div id="node-107" class="section-2">
  <h1 class="book-heading">Переходы между сценами при работе с игровым движком Blender. Урок 7</h1>
  <div style="text-align:center;">
<h4>Уроки по Blender Game Engine</h4>
</div>
<p>Обычно игры, создаваемые в Blender, состоят из нескольких сцен.</p>
<div style="text-align:center;"><img src="../../../img/bge/addscene.gif" width="542" height="145" alt="Добавление сцен в Blender" /></div>
<p>Blender Game Engine включает возможность настройки перехода на другую сцену в режиме игры. На панели Logic для этих целей предназначен активатор  <strong>Scene</strong> -> <strong>Set Scene</strong>. В качестве значения <strong>SCE</strong> («установить сцену») указывается имя сцены, на которую требуется перейти.</p>
<div style="text-align:center;"><img src="../../../img/bge/setscene.gif" width="700" height="119" alt="Контроллер Set Scene в Blender Game Engine" /></div>
<p>События, которые могут приводить к переходу на другие сцены, различны: щелчки мышью, нажатия клавиш, касание материала и др.</p>
<p>Приведем простой пример. Допустим, мы создаем заготовку будущей «виртуальной лаборатории», состоящей из четырех сцен, на каждой из которых будет возможно проводить и демонстрировать какой-нибудь виртуальный эксперимент. С главной сцены можно будет на графическом меню указать с помощью щелчка левой кнопкой мыши желаемую сцену. С любой другой сцены можно будет вернуться на главную сцену. Опишем примерную последовательность шагов.</p>
<p><strong>1. Подготовим сцены</strong></p>
<p>На главной сцене у нас будет меню. Его можно создать из плоскостей, на которые наложить текстуры изображений с текстом или объект Text Блендера. В последнем случае Text следует преобразовать в меш-объект (<strong>Alt+C</strong> -> <strong>Mesh</strong>) и объединить с плоскостью (<strong>Ctrl+J</strong>).</p>
<p>Для добавления новых сцен, следует выбрать пункт <strong>ADD NEW</strong> в выпадающем списке окна пользовательских настроек (вверху) – посмотрите на первое изображение в данном уроке. При добавлении сцены предлагается список из четырех вариантов. Лучше выбрать <strong>Full Copy</strong> (чтобы не иметь головной боли с установкой камеры и лампы), а все лишние объекты потом удалить. Далее можно переименовать сцену. </p>
<p>Добавив вторую сцену, не будем спешить с добавлением других сцен. Пока разместим на второй сцене «кнопку» возврата на главную. Далее уже будем копировать эту сцену. В результате должна получиться примерно такая схема сцен как на рисунке ниже.</p>
<div style="text-align:center;"><img src="../../../img/bge/allscene.gif" width="500" height="398" alt="Схема сцен в Blender" /></div>
<p><strong>2. Отобразим курсор мыши</strong></p>
<p><a href="http://younglinux.info/bgemouse">Урок 5. Сенсор Mouse</a></p>
<p><strong>3. Установим возможность перехода между сценами в режиме игры</strong></p>
<p>См. второй рисунок в данном уроке. Каждая кнопка на главной  сцене должна переключать на соответствующую ей сцену (one, two, three или four). Кнопка “main” на остальных сценах должна переключать игру на главную сцену. </p>
<h2>Практическая работа </h2>
<p>Создайте небольшую игру по следующему описанию. </p>
<p>Цель игры: прокатить шар до конца извилистой узкой поверхности.</p>
<p>Если шар падает с плоскости, то пользователь может нажать R и игра должна начаться сначала. </p>
<div style="text-align:center;"><img src="../../../img/bge/restart.gif" width="664" height="113" alt="Настойка restart (перезапуска) игры в BGE" /></div>
<p>Если шар докатывается до конца плоскости, то следует переход на другую сцену с еще более изощренной дорожкой. Чтобы переход происходил «автоматически», можно поставить на конец поверхности объект Empty (пустышка) и добавить к нему сенсор <strong>Near</strong>, связанный с активатором <strong>Scene</strong> -> <strong>Set Scene</strong>.</p>
<div style="text-align:center;"><img src="../../../img/bge/near.gif" width="700" height="86" alt="Сенсор Near" /></div>
<p>Камера должна «следить» за шаром.</p>
<p>Желательно, чтобы игра состояла из трех игровых сцен и сцены «конец игры», которую может увидеть только игрок, прошедший все уровни. </p>
  </div>
<div id="node-108" class="section-2">
  <h1 class="book-heading">Активатор Edit Object. Урок 8</h1>
  <div style="text-align:center;">
<h4>Уроки по Blender Game Engine</h4>
</div>
<p>Активатор <strong>Edit Object</strong> (редактирование объекта) позволяет изменять свойства конкретного объекта, а также изменять «меш-содержимое» 3D-сцены в режиме игры. </p>
<h2>Add Object – добавить объект</h2>
<p>Использование типа <strong>Add Object</strong> активатора <strong>Edit Object</strong> дает возможность в режиме игры добавлять на сцену новый меш-объект. На самом деле объект должен быть не новым, а “спрятанным” (обычно на другом слое). Новый объект добавляется в то место, где находится объект, к которому добавлен активатор <strong>Edit Object -> Add Object</strong>. Добавляемый объект (его имя) прописывается в качестве значения свойства <strong>OB</strong>. </p>
<p>Допустим, у нас есть плоскость, на которую планируется в процессе игры добавлять различные предметы при нажатии на различные клавиши, для указания места добавления используется специальная метка-точка (на рис. - кранным цветом), которую можно передвигать по плоскости в четырех направлениях.</p>
<div style="text-align:center;"><img src="../../../img/bge/addobject.gif" width="550" height="272" alt="Blender Game Engine, игровой режим" /></div>
<p>На самом деле двигается пустышка (Empty), которая является родителем по отношению к красной метке (<strong>Ctrl+P</strong> – связь родитель-потомок). Именно для объекта Empty также добавлены активаторы <strong>Edit Object</strong>. Конечно, можно привязать  добавляемые объекты и к красной метке, однако появятся проблемы с их размером и др.</p>
<div style="text-align:center;"><img src="../../../img/bge/addobject2.gif" width="699" height="308" alt="Активатор Edit Object - /> Add Object" /></div>
<p>Здесь происходит добавление объектов с именами white и black при нажатии клавиш W и B соответственно. Первые четыре блока сенсоров, контроллеров и активаторов отвечают за движение Empty.</p>
<p>У активатора <strong>Edit Object -> Add Object</strong> есть дополнительные настройки. Добавленные объекты будут исчезать через установленный промежуток времени, если Time не будет нулевым. Измеряется данное свойство не в секундах, а кадрах (обычно в секунде 25-30 кадров).</p>
<p><strong>linV</strong> и <strong>angV</strong> позволяют придать объекту некоторое ускорение в момент появления. Движение может быть вдоль оси или вокруг оси (поворот). Работает только с физическими объектами.</p>
<h2>End Object – удалить объект</h2>
<p>Объект может быть удален в режиме игры. Часто это используется в комбинации с каким-либо другим активатором. Например, исчезновение объекта при столкновении с другим объектом.</p>
<h2>Replace Mesh – замена меш-объекта</h2>
<p>Этот тип активатора <strong>Edit Object</strong> представляет собой интересную возможность Blender Game Engine (однако, еще не до конца реализованную разработчиками). Например, можно создавать различные спецэффекты. Допустим, объект падает и при касании земли, последняя проминается (на самом деле будет происходить замена меша).</p>
<div style="text-align:center;"><img src="../../../img/bge/replacemesh.gif" width="706" height="70" alt="Активатор Edit Object - /> Track to" /></div>
<h2>Track to – слежение</h2>
<p>При добавлении этого типа активатора, объект будет поворачиваться по осям, «следя» за указанным в качестве <strong>OB</strong> объектом, при этом оставаясь на одном и том же месте. Например, камера может следить за каким-нибудь передвигающимся объектом на сцене, если сцена небольшая. Или интересные эффекты могут получаться, если при движении одного объекта, другой (с активатором <strong>Edit Object -> Track to</strong>), оставаясь на месте, будет поворачиваться.</p>
<h2>Dynamics - динамика </h2>
<p>Этот тип активатора <strong>Edit Object</strong> позволяет изменять физические свойства объекта.  Однако объект должен изначально быть установлен как физический. Подтипы <strong>Suspend</strong> и <strong>Restore Dynamics</strong>, <strong>Disable</strong> и <strong>Enable Rigid Body</strong> включают и отключают соответственно влияние физики на объекты. Подтип <strong>Set Мass</strong> позволяет в режиме игры изменять массу объекта.</p>
<p>Например, у какого-нибудь Dynamic-объекта можно отключить его физические свойства, связав сенсор <strong>Always</strong> с активатором <strong>Edit Object -> Dynamics -> Suspend Dynamics</strong>. А в процессе игры включать физические свойства (<strong>Restore Dynamics</strong>), если случиться определенное событие. </p>
<h2>Практическая работа</h2>
<p>С помощью <strong>Blender Game Engine</strong> создайте небольшую игру по следующему описанию.</p>
<p>На одном краю плоскости, расположены небольшие кубики-мишени, являющиеся статическими объектами.</p>
<p>На другом крае плоскости расположен объект-пушка.</p>
<p>Добавить Empty и сделать ее родителем по отношению к пушке. Пустышка (вместе с пушкой) может двигаться в двух плоскостях: вдоль своего края и вверх-вниз. Сенсоры – стрелки на клавиатуре.</p>
<p>Из пушки (на самом деле – пустышки) вылетают пули в направлении мишеней. Для этого на другой слой поместить объект-пулю (физический объект). Привязать его к пушке при помощи активатора <strong>Edit Object -> Add Object</strong>. Придать ускорение в направлении мишеней (<strong>linV</strong>). Пульки должны исчезать примерно через 100-120 кадров (<strong>Time</strong>).</p>
<p>Мишени должны исчезать при касании их объектом-пулей (<strong>End Object</strong>).</p>
  </div>
<div id="node-109" class="section-2">
  <h1 class="book-heading">Влияние параметра Grav на поведение объектов   в Blender Game Engine. Урок 9  </h1>
  <p>Игровой мир в Blender по умолчанию настроен таким образом, что поведение виртуальных физических объектов сходно с поведением их аналогов в реальном мире в условиях Земли. Однако в невесомости или на каком-нибудь другом космическом теле те же самые объекты будут вести себя по-другому. Все зависит от силы притяжения, вызываемой конкретным «миром» (космическим телом). Эта сила вызывает ускорение свободного падения, которое в Blender можно менять в окне кнопок на панели <strong>Shading -> World buttons</strong>: параметр <strong>Grav</strong>. Значение по умолчанию равно 9.8, что соответствует ускорению свободного падения в пределах Земли.</p>
<div style="text-align:center;"><img src="../../../img/bge/grav.gif" width="623" height="181" alt="Параметр Grav в Blender" /></div>
<p>  Если разместить на сцене плоскость, а над ней несколько предметов, то можно увидеть, как они будут падать (если параметр <strong>Grav</strong> не равен нулю, нулевое значение обозначает невесомость) и взаимодействовать между собой. Большое значение <strong>Grav</strong> приводит к тому, что объекты падают очень быстро, и для их перемещения с помощью силы (<strong>Force</strong>) требуется использовать большее значение, чем обычно.</p>
<p>Изменяя значение <strong>Grav</strong>, можно оценивать поведение объектов в различных условия. Например, установив ускорение свободного падения в значение 1.62, мы увидим, как ведут себя объекты в пределах Луны. Сразу станет очевидно, что взлет с Луны требует приложения меньшей силы по оси Z. Интересно также увидеть, как ведут себя объекты в условиях невесомости.</p>
<p>В режиме игры мы видим одну сцену и, следовательно, один «мир». Однако, может потребоваться наглядно сравнить поведение объектов в условиях разных «миров». Тогда нужно в режиме игры как-то отобразить как минимум две сцены. В Blender Game Engine есть некоторая реализация данной возможности. У активатора Scene есть два типа, позволяющие разместить другую сцену над или под текущей соответственно: <strong>Add Overlay Scene</strong> и <strong>Add Background Scene</strong>. То есть всего в режиме игры можно отобразить содержимое трех сцен. </p>
<div style="text-align:center;"><img src="../../../img/bge/overlayscene.gif" width="637" height="113" alt="Добавление сцен в Blender Game Engine" /></div>
<p>При этом следует учитывать, что добавленная сцена отобразиться так, как она выглядит из камеры на своей сцене. Объекты с разных сцен могут накладываться друг на друга (что не желательно). Поэтому заранее нужно размещать предметы так, чтобы итоговый вид в режиме игры был приемлемым.</p>
<h3>Практическая работа</h3>
<p><strong>Примечание:</strong> предварительно лучше камеру развернуть параллельно оси X или Y.</p>
<ol>
<li>На сцену добавьте плоскость и несколько предметов над ней. Объекты должны быть типа <strong>Rigid body</strong> или <strong>Soft body</strong>, обладать разной массой. На объекты с помощью клавиш должно быть возможно влияние сил в различных направлениях. При виде из камеры все объекты должны находиться в нижней части сцены. Назовите данную сцену «earth». </li>
<li>Создайте копию предыдущей сцены. Назовите ее «moon». Все объекты сместите в центральную часть сцены (при виде из камеры). Измените <strong>Grav</strong> на 1.62.</li>
<li>Создайте вторую копию сцены – «space». Объекты сместите в верхнюю часть сцены, <strong>Grav</strong> обнулите (будет невесомость).</li>
<li>Перейдите на сцену «moon» и выделите камеру. На панели <strong>Logic</strong> добавьте две сцены, используя соответствующие типы активатора <strong>Scene</strong> (см. рисунок выше).</li>
<li>Запустите режим игры. Оцените поведение объектов под влиянием различных сил притяжения. </li>
</ol>
<div style="text-align:center;"><img src="../../../img/bge/gravitation.gif" width="500" height="428" alt="Три сцены в игровом режиме Blender" /></div>
  </div>
<div id="node-110" class="section-2">
  <h1 class="book-heading">Материалы и текстуры в Blender Game Engine: работа с UV/Image Editor. Урок 10</h1>
  <div style="text-align:center;"><img src="../../../img/bge/world.gif" width="450" height="437" alt="вид сцены в игровом режиме Blender" /></div>
<p>При создании боле менее сложных сцен с использованием Blender Game Engine объекты могут состоять из нескольких частей, каждая из которых имеет свой цвет и текстуру. Для того чтобы добиться этого, можно пойти разными путями. Например, можно сначала смоделировать части объекта из различных меш-примитивов, наложить на них материалы и текстуры, а затем объединить их в единое целое (<strong>Ctrl+J</strong>). Но при этом обычно возникает один существенный недостаток – большое количество частей у меш-объекта (граней, ребер и вершин). Из-за этого при запуске игрового режима компьютер начинает тормозить. Чем меньше частей, тем быстрее. Поэтому, бывает лучше создать изображение с прорисованными на нем частями, а потом наложить этот рисунок на целый меш-объект. Или возможно, объект достаточно прост, но каждая его часть должна быть своего цвета.</p>
<p>Один из способов «экзотически раскрасить» объекты для отображения в режиме игры – это использование редактора <strong>UV/Image Editor</strong>, который открывается в соответствующем окне Blender. (3D-окно следует подразделить на две части и в одном выбрать окно <strong>UV/Image Editor</strong>.)</p>
<div style="text-align:center;"><img src="../../../img/bge/imageedit.gif"  width="350" height="311" alt="Окно UV/Image Editor" /></div>
<p><strong>Примечания:</strong> </p>
<ol>
<li>При использовании материалов <strong>UV/Image Editor</strong> для объектов удаляйте у них материалы на панели <strong>Shading -> Material buttons</strong> (иначе в режиме игры будет отображаться именно этот материал).</li>
<li>Текстуры видны, только если переключиться в режим прорисовки Textured.</li>
</ol>
<div style="text-align:center;"><img src="../../../img/bge/deletematerial.gif" width="628" height="185" alt="Удаление материала в Blender" /></div>
<p>В окне <strong>UV/Image Editor</strong> можно 1) как создавать новые материалы, состоящие из одного цвета и/или дорисованные с помощью настроек панели <strong>Editing</strong> (вкладка <strong>Paint</strong>), 2) так и открывать готовые изображения. В основном предпочитают второй вариант.</p>
<div style="text-align:center;"><img src="../../../img/bge/newopen.gif" width="431" height="160" alt="Добавление текстуры в UV/Image Editor" /></div>
<p>После загрузки изображений они доступны в виде списка. Следует иметь в виду, что изображения по умолчанию не импортируются в файл .blend, а лишь связываются по ссылке. Чтобы картинки остались в файле «навечно», нужно для каждого рисунка в списке нажать кнопку с изображением коробки с сюрпризом.</p>
<div style="text-align:center;"><img src="../../../img/bge/pack.gif" width="511" height="193" alt="Упаковка текстуры" /></div>
<p>Текущее изображение отображается в рабочей области окна. Если оно слишком большое или маленькое, то с помощью колеса мыши можно изменить масштаб. А зажав колесо мыши, перемещать изображение по рабочей области (т.е. работать почти так, как в 3D-окне). </p>
<p>Итак, у нас есть импортированные изображения и объекты на сцене, на которые требуется наложить эти изображения. Делается все в режиме редактирования объектов и при выделении граней. Текстура применяется только к выделенным граням. Таким образом, можно к одному объекту применить несколько текстур.</p>
<p>Понятно, что объекты по размеру и форме не совпадают с изображениями. Поэтому существуют различные способы наложения текстур. Выбор способа наложения происходит в меню <strong>UV Calculation</strong>, которое появляется при нажатии клавиши <strong>U </strong>в 3D-окне. </p>
<div style="text-align:center;"><img src="../../../img/bge/calculate.gif" width="407" height="345" alt="Наложение текстуры в режиме редактирования Blender" /></div>
<p>Если с первыми четырьмя способами наложения еще кое-как понятно, то остальные достаточно специфичны (за исключением Reset, который часто бывает полезен). Не смотря на возможность разного способа наложения, рисунки все равно не совпадают с объектом по размеру. Поэтому в окне UV/Image Editor предусмотрена возможность редактирования способа наложения так, как если бы вы редактировали меш-объект: можно перемещать сетку наложения по текстуре, масштабировать и изменять форму.</p>
<p>Рассмотрим несколько примеров. </p>
<p>Накладывание карты на сферу. В 3D-окне в режиме редактирования сферы выделить все грани; нажав <strong>U</strong>, выбрать <strong>Sphere from View</strong>. Перевести курсор мыши в окно <strong>UV/Image Editor</strong>. Растягивая (<strong>S</strong> по осям X, Y или Z) и перемещая сетку (<strong>G</strong>) добиться ее совпадения с картой.</p>
<div style="text-align:center;"><img src="../../../img/bge/map.gif" width="700" height="159" alt="Редактирование текстуры в UV/Image Editor" /></div>
<p>Накладывание разных текстур на один меш-объект. Зажав <strong>Shift</strong>, выделяем только те грани, на которые накладывается первая текстура, выбираем изображение и применяем тип наложения. Редактируем сетку наложения, если потребуется. Далее выделяем другие грани и накладываем другой материал. Если нужно просто раскрасить их в тот или иной цвет, то достаточно в окне <strong>UV/Image Editor</strong> выбрать <strong>New</strong>, подобрать в появившемся окне цвет, назвать материал, и, затем, выбрать его из списка.</p>
<p>Отображение текстуры на внутренней поверхности. Допустим, планируется разместить сцену игры внутри большой сферы. Чтобы наложить текстуру на внутреннюю поверхность сферы надо наложить ее сначала на внешнюю сторону, затем (не выходя из режима редактирования) на панели кнопок <strong>Editing</strong> найти вкладку <strong>Texture Face</strong>, включить там <strong>Twoside</strong> и затем нажать <strong>Copy</strong> (чтобы применить изменения).</p>
<div style="text-align:center;"><img src="../../../img/bge/twosides.gif" width="251" height="174" alt="Наложение текстуры на внутренюю поверхность граней" /></div>
<p><strong>Практическая работа</strong></p>
<p>Попрактикуйтесь в наложении материалов и текстур с помощью <strong>UV/Image Editor</strong>. В качестве среды для опытов можно использовать сохраненные файлы с предыдущих уроков по Blender Game Engine.</p>
  </div>
</div>
    
  </body>
</html>
