<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Процесс загрузки, инициализация и завершение работы</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
              <div class="section-1">
                <div class="section-2">
          
    <div id="node-209" class="section-3">
  <h1 class="book-heading">Процесс загрузки, инициализация и завершение работы</h1>
  <h2>Введение</h2>
<p>Одна из наиболее мощных сторон Linux связана с ее открытым методом запуска и остановки операционной системы; Linux загружает определенные программы, используя их особую конфигурацию, что позволяет вам изменять эти конфигурации для контроля процесса загрузки и останавливать работу системы элегантно и организовано.</p>
<p>Помимо задач контроля загрузки и процесса завершения работы, открытый характер Linux облегчает в большинстве случаев точное определение источников проблем, связанных с запуском и остановкой системы. Понимание основ этого является весьма полезным для всех, кто использует Linux.</p>
<p>Множество систем Linux используют <strong>lilo</strong> (LInux LOader) для загрузки операционных систем. Мы обсудим только GRUB, т. к. он проще в использовании и является более гибким. Если вам необходима информация о <strong>lilo</strong>, обратитесь к man-страницам и HOWTO. Оба загрузчика поддерживают двойные загрузки; мы ссылаемся на HOWTO по этому вопросу для практических примеров и справочной информации.</p>
<h2>Загрузочный процесс</h2>
<p>Когда загружается компьютер x86, процессор просматривает конец системной памяти на обнаружение BIOS (Basic Input/Output System) и запускает его. (Программа BIOS записывается в постоянной памяти только для чтения, и всегда доступна для использования.) BIOS обеспечивает низкоуровневый интерфейс для периферийных устройств и контролирует первый шаг процесса загрузки.</p>
<p>BIOS тестирует систему, ищет и проверяет периферию, и затем ищет устройство, чтобы использовать его для загрузки системы. Обычно BIOS проверяет устройство для дискет (или на многих современных системах дисковод CD-ROM) на наличие загрузочного диска, если их там нет, то смотрит на жестком диске. Последовательность устройств, используемых для загрузки, обычно контролируется индивидуальными для системы настройками BIOS. После того, как Linux установлен на жесткий диск, BIOS ищет главную загрузочную запись (Master Boot Record - MBR), начиная с первого сектора первого жесткого диска, загружает его содержимое в память и передает ему управление.</p>
<p>MBR содержит инструкции о том, как загрузить загрузчик GRUB (или LILO), использующий предварительно заданные операционные системы. MBR загружает загрузчик, который принимает на себя процесс (если загрузчик установлен в MBR). В стандартной конфигурации Red Hat Linux GRUB использует настройки в MBR для отображения параметров загрузки в меню. Как только GRUB получил корректные инструкции для запуска операционной системы либо из его командной строки или из файла конфигурации, он находит необходимые загрузочные файлы и удаляется от управления машиной в данной операционной системе.</p>
<h2>Особенности GRUB</h2>
<p>Этот метод загрузки называется <em>прямой загрузкой</em>, поскольку инструкции используются для непосредственной загрузки операционной системы, без какого-либо промежуточного кода между загрузчиком и основными файлами операционной системы (например, ядром). Процесс загрузки, используемый в других операционных системах, может незначительно отличаться от вышеуказанного. Например, операционные системы Microsoft (DOS и Windows) полностью переписывают MBR, когда они устанавливаются без учета какой-либо текущей конфигурации MBR. Все они стирают любую другую информацию, хранящуюся в MBR от других операционных систем, таких как Linux. Операционные системы Microsoft, также как и другие разные проприетарные  операционные системы, загружаются с помощью метода цепной загрузки. При использовании этого метода, MBR указывает на первый сектор раздела, на котором находится операционная система, где находит специальные файлы, необходимые для фактической загрузки данной операционной системы.</p>
<p>GRUB поддерживает оба загрузочных метода, что позволяет использовать его практически с любой операционной системой, наиболее популярными файловыми системами, и практически любым жестким диском, который сможет распознать ваш BIOS.</p>
<p>GRUB содержит ряд других особенностей. Из них наиболее важные:</p>
<ul>
<li>GRUB обеспечивает истинно командное, предшествующее ОС, окружение на машинах x86 для обеспечения максимальной гибкости при загрузке операционной системы с определенными параметрами или сбора информации о системе.</li>
<li>GRUB поддерживает режим логической адресации блоков (LBA), необходимый для доступа ко многим IDE и всем SCSI жестким дискам. До LBA жесткие диски могли столкнуться с 1024-цилиндровый пределом, когда BIOS  после этого места не может найти файл.</li>
<li>Конфигурационный файл GRUB читается с диска каждый раз при загрузке системы, освобождая вас от необходимости писать поверх MBR при каждом изменении параметров загрузки.</li>
</ul>
<p>Полное описание GRUB можно найти, выполнив команду <strong>info</strong> <span class="monoi">grub</span> или на <noindex><a href="http://www.gnu.org/software/grub/">сайте GRUB</a></noindex>. В Linux Documentation Project есть мини-HOWTO по мультизагрузке GRUB.</p>
<h2>Init</h2>
<p>Ядро, как только оно загружено, находит <strong>init</strong> в <span class="mono">sbin</span> и выполняет его.</p>
<p>Когда <strong>init</strong> запускается, то становится родителем и прародителем всех процессов, которые запускаются автоматически в вашей системе Linux. Первое, что делает <strong>init</strong>, читает его файл инициализации <span class="mono">/etc/inittab</span>. Он инструктирует <strong>init</strong> прочитать первоначальный сценарий конфигурации для окружения, в котором определены пути, запускается своппинг, проверяются файловые системы и так далее. В принципе, этот шаг позаботится обо всем, что ваша система должна сделать при своей инициализации: установка часов, инициализация последовательных портов и т.д.</p>
<p>Затем <strong>init</strong> продолжает читать файл <span class="mono">/etc/inittab</span>, который описывает, каким образом система должна подниматься на каждом уровне запуска и устанавливает <em>уровень выполнения</em> по умолчанию. <em>Уровень выполнения</em> определяет конфигурацию процессов. Все UNIX-подобные системы могут работать в различных конфигурациях, среди них есть однопользовательский режим, который называется уровнем выполнения 1 или S (или s). В этом режиме только системный администратор может подключиться к системе. Он используется для выполнения задач по обслуживанию без риска повреждения системы или пользовательских данных. Естественно, в такой конфигурации нам не следует предоставлять пользовательские службы, так что все они будут отключены. Другой уровень выполнения — это режим перезагрузки, или уровень 6, который завершает все запущенные службы, выполнив надлежащие процедуры, и перезагружает систему.</p>
<p>Используйте <strong>who</strong> для проверки, каким является ваш текущий уровень выполнения:</p>
<pre>
willy@ubuntu:~$ <strong>who -r</strong>
	run-level 2 2006-10-17 23:22		last=S
</pre><p>
Подробнее об уровнях выполнения в следующем разделе, см. <a href="http://younglinux.info/#">Раздел "Уровни выполнения Init"</a>.</p>
<p>После того, как для вашей системы определяется уровень выполнения по умолчанию, <strong>init</strong> запускает все фоновые процессы, необходимые для запуска системы, просматривая соответствующую для данного уровня выполнения директорию <span class="mono">rc</span>. <strong>init</strong> выполняет каждый kill-сценарий (их файловые имена начинаются с K) с параметром <span class="monoi">stop</span>. Затем он проходит все запускающие сценарии (их имена файлов начинаются с S) в соответствующем уровню выполнения каталоге, с тем, чтобы все службы и приложения запустились правильно. На самом деле вы вручную можете выполнить те же сценарии после того, как система завершит загрузку, командами подобными <strong>/etc/init.d/httpd</strong> <span class="monoi"> stop</span> или <strong>service</strong> <span class="monoi"> httpd stop</span>, войдя в систему с правами <em>root</em>; в этом случае останавливается веб-сервер.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Особый случай.</strong><br />
Обратите внимание, что при запуске операционной системы скрипты в <span class="mono">rc2.d</span> и <span class="mono">rc3.d</span>, как правило, выполняются. В этом случае, никакие службы не останавливаются (по крайней мере, не навсегда). Службы только запускаются.</p>
<p>Ни один из сценариев, которые фактически запускают и останавливают службы, не расположен в <span class="mono">/etc/rc<x>.d</x></span>. Вернее, все файлы в <span class="mono">/etc/rc<x>.d</x></span>. являются символическими ссылками, указывающими на реальные сценарии, находящихся в <span class="mono">/etc/init.d</span>. Символическая ссылка это не более чем файл, который указывает на другой файл; в данном случае они используются, т. к. их можно создавать и удалять без ущерба для фактических сценариев, завершающих или запускающих службы. Символические ссылки на различные сценарии нумеруются в определенном порядке, в таком порядке они и запускаются. Вы можете изменить порядок запуска и остановки служб, изменив названия символических ссылок, которые ссылаются на сценарий, который фактически управляют службами. Вы можете использовать один и тот же номер множество раз, если хотите, чтобы определенный сервис запускался или останавливался непосредственно перед или после другого; в примере ниже перечислено содержимое <span class="mono">/etc/rc5.d</span>, в котором у <strong>crond</strong> и <strong>xfs</strong> имя ссылки начинается с "S90". В этом случае, скрипты запускаются в алфавитном порядке.</p>
<pre>
[jean@blub /etc/rc5.d] ls
K15httpd@     K45named@    S08ipchains@  S25netfs@      S85gpm@
K16rarpd@     K46radvd@    S08iptables@  S26apmd@       S90crond@
K20nfs@       K61ldap@     S09isdn@      S28autofs@     S90xfs@
K20rstatd@    K65identd@   S10network@   S30nscd@       S95anacron@
K20rusersd@   K74ntpd@     S12syslog@    S55sshd@       S95atd@
K20rwalld@    K74ypserv@   S13portmap@   S56rawdevices@ S97rhnsd@
K20rwhod@     K74ypxfrd@   S14nfslock@   S56xinetd@     S99local@
K25squid@     K89bcm5820@  S17keytable@  S60lpd@
K34yppasswdd@  S05kudzu@    S20random@    S80sendmail@
</pre><p>
Затем <strong>init</strong> проходит через уровень выполнения, чтобы задать уровень по умолчанию,  сценарий <span class="mono">/etc/inittab</span> разветвляется процессом <strong>getty</strong> для каждой виртуальной консоли (приглашение на вход в текстовом режиме). <strong>getty</strong> открывает строки tty, устанавливает их режимы, печатает строку входа, получает имя пользователя, и затем начинает процесс входа для данного пользователя. Это позволяет пользователям представится системе и использовать ее. По умолчанию, большинство систем предлагают 6 виртуальных консолей, но, как вы можете увидеть из файла <span class="mono">inittab</span>, это можно изменить.</p>
<p><span class="mono">/etc/inittab</span> может также указать <strong>init</strong>, как тот должен обрабатывать пользовательское нажатие <strong>Ctrl + Alt + Delete</strong> в консоли. Поскольку система должна надлежащим образом выключаться и перезапускаться, а не прекращать немедленно работу, <strong>init</strong> сообщается выполнить команду <span class="mono">/sbin/shutdown -t3 -r now</span>, например, когда пользователь нажимает эти клавиши. Кроме того, <span class="mono">/etc/inittab</span> устанавливает, что <strong>init</strong> должен делать в случае отключения электропитания, если у вашей системы есть <span style="background-color:yellow;">UPS unit</span>, прикрепленный к ней.</p>
<p>В большинстве систем, основанных на RPM, графический экран для входа запускается на уровне выполнения 5, где <span class="mono">/etc/inittab</span> запускает скрипт под названием <span class="mono">/etc/X11/prefdm</span>. Скрипт <span class="mono">prefdm</span> преимущественно работает в графическом менеджере X, основываясь на содержимом каталога <span class="mono">/etc/sysconfig/desktop</span>. Это, как правило, <strong>gdm</strong>, если вы работаете на GNOME или <strong>kdm</strong>, если вы используете KDE, но они могут быть смешаны, кроме того, есть <strong>xdm</strong>, который предоставляется  при стандартной установке X.</p>
<p>Но есть и другие возможности. В Debian, например, есть initscript для каждого менеджера дисплея, и содержание <span class="mono">/etc/X11/default-display-manager</span> используется для определения того, какой из них запустить. Подробнее о графическом интерфейсе можно прочитать в <a href="http://younglinux.info/#">Разделе 7.3. "Графическая среда"</a>. В конечном счете, ваша системная документация разъяснит подробности высокоуровневых аспектов <strong>init</strong>.</p>
<p>Каталоги <span class="mono">/etc/default</span> и/или <span class="mono">/etc/sysconfig</span> содержат записи для целого ряда функций и служб, все это читается во время загрузки. Местонахождение директории, содержащей системные настройки по умолчанию, может несколько различаться в зависимости от вашего дистрибутива Linux.</p>
<p>Кроме того, графическая среда пользователя, ряд других служб могут быть запущены также. Но если все пойдет хорошо, то когда процесс загрузки завершается, вы видите приглашение для входа или графический экран для входа.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Другие процедуры. </strong><br />
Мы объяснили, как SysV <strong>init</strong> работ на базе x86. Запуск процедур может различаться на других архитектурах и дистрибутивах. Другие системы могут использовать BSD-стиль <strong>init</strong>, когда загрузочные файлы не разделяются на множество каталогов <span class="mono">/etc/rc<LEVEL>.d</level></span>. Также может оказаться, что ваша система использует <span class="mono">/etc/rc.d/init.d</span> вместо <span class="mono">/etc/init.d</span>.</p>
<h2>Уровни выполнения Init</h2>
<p>Идея функционирования различных служб на разных уровнях выполнения по существу вращается вокруг того факта, что различные системы могут быть использованы по-разному. Некоторые службы не могут быть использованы, пока система находится в определенном состоянии или режиме, таком как быть готовой к более чем одному пользователю или доступной сети.</p>
<p>Бывают периоды, в которые вы можете работать с системой в низкоуровневом режиме. Примеры: решение проблем испорченного диска на уровне выполнения 1, так чтобы у других пользователей не было возможности быть в системе, или оставить сервер на уровне выполнения 3 (без работающей X сессии). В этих случаях, функционирование сервисов, которые зависят от высокоуровневого режима системы, не имеет смысла, т. к. они не будут работать правильно в любом случае. Уже имеющимся службам назначается их запуск, когда будет достигнут определенный уровень выполнения; вы обеспечиваете последовательный запуск процессов, и вы можете быстро изменить режим машины, не беспокоясь о том, что вручную придется запускать и останавливать службы.</p>
<p>Доступные уровни выполнения, как правило, описаны в файле <span class="mono">/etc/inittab</span>, содержимое которого частично показано ниже:</p>
<pre>
#
# inittab   This file describes how the INIT process should set up
#           the system in a certain run-level.

# Default run level. The run levels are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS 
#	(The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
# 
id:5:initdefault:
&lt;--cut-->
</pre><p>
Вы можете настроить неиспользованные уровни выполнения (обычно уровень 4) как вы считаете нужным. Многие пользователи настраивают эти уровни выполнения, таким образом, который наиболее подходит для них, оставляя стандартные уровни, поскольку они существуют по умолчанию. Это позволяет им быстро входить в и выходить из их пользовательской конфигурации, не нарушая нормальной установки свойств на стандартных уровнях запуска.</p>
<p>Если ваша машина оказывается в ситуации, когда она не может загрузиться из-за испорченного <span class="mono">/etc/inittab</span> или не позволят вам войти, т.к. вы повредили файл <span class="mono">/etc/passwd</span> (или если вы просто забыли свой пароль), загрузитесь в однопользовательском режиме.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong>  Без графики?</strong><br />
Когда вы работаете в текстовом режиме, т. к. не был предоставлен экран графического входа на вашей машине, обычно вы можете  переключаться на консоль 7. Если это не так, проверить текущий режим работы с помощью команды <strong>who</strong> <span class="mono"> -r</span>. Если он установлен на что-нибудь другое, чем есть оригинальные установки по умолчанию в <span class="mono">/etc/inittab</span>, то вероятно это может быть причина того, что система не запускается в графическом режиме по умолчанию. В таком случае обратитесь к системному администратору или прочитайте <strong>man</strong> <span class="mono"> init</span>. Заметим, что переключение режимов работы осуществляется преимущественно с использованием команды <strong>telinit</strong>; переключение из текстовой в графическую консоль или наоборот не подразумевает изменение режима выполнения.</p>
<p>Мы стараемся в данном руководстве обсуждать режимы выполнения, скрипты и конфигурации в общих чертах. Существует множество вариаций. Например, Gentoo Linux хранит скрипты в уровнях <span class="mono">/etc/run</span>. Другие системы могут запускаться через первый нижний режим выполнения и выполнить все сценарии в нем до прибытия конечного режима выполнения и исполнения его сценариев. Обратитесь к системной документации для получения дополнительной информации. Вы также можете прочитать скрипты, которые относятся к <span class="mono">/etc/inittab</span>, чтобы лучше понять, что происходит в вашей системе.</p>
<h3>Инструменты</h3>
<p>Если в вашей системе установлены утилиты <strong>chkconfig</strong> или <strong>update-rc.d</strong>, то они обеспечат простой инструмент командной строки для поддержания иерархии каталога <span class="mono">/etc/init.d</span>. Это освобождает системных администраторов от необходимости напрямую управлять многочисленные символическими ссылками в каталогах в <span class="mono">/etc/rc[x].d</span>.</p>
<p>Кроме того, некоторые системы предлагают инструмент <strong>ntsysv</strong>, который предоставляет текстовый интерфейс; вы можете сочти его легче в использовании, чем интерфейс командной строки <strong>chkconfig</strong>. В SuSE Linux, вы обнаружите инструменты <strong>yast</strong> и <strong>insserv</strong>. В Mandriva есть Mandriva Linux Control Center (Центр управления Mandriva Linux).</p>
<p>Большинство дистрибутивов обеспечивают графический пользовательский интерфейс для настройки процессов; обратитесь к вашей системной документации.</p>
<p>Все эти утилиты должны быть запущен под root. Системный администратор также может вручную создать соответствующие ссылки в каждом каталоге режима выполнения для того, чтобы запустить или остановить службы определенного режима.</p>
<h2>Shutdown – выключение</h2>
<p>UNIX была создана как система, которая не останавливается, но если вам это  действительно надо, используйте команду <strong>shutdown</strong>. Опция <span class="mono">-h</span> будет остановить систему, а <span class="mono">-r</span> будет перезагружать ее.</p>
<p>Команды <strong>reboot</strong> и <strong>halt</strong> теперь способны вызывать <strong>shutdown</strong>, когда система находится в режимах выполнения 1-5, и таким образом обеспечить надлежащее завершение ее работы, но это плохая привычка, поскольку не во всех версиях UNIX/Linux есть такая возможность.</p>
<p>Пока ваш компьютер сам не выключится, вы не должны выключать его, пока не увидите сообщение с указанием, что система остановилась или все процессы завершились, т. к. система должна отключить все разделы. Нетерпеливость может привести к потере данных.</p>
  </div>
    </div></div>
  </body>
</html>
