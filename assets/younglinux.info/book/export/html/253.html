<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Глава 7. Дом, сладкий /home</title>
    <base href="" />
    <link type="text/css" rel="stylesheet" href="http://younglinux.info/misc/print.css" />
      </head>
  <body>
              <div class="section-1">
          
    <div id="node-253" class="section-2">
  <h1 class="book-heading">Глава 7. Дом, сладкий /home</h1>
  <h4>Аннотация</h4>
<p>Эта глава о настройке вашего окружения. Теперь, когда мы знаем, как использовать редактор, можем изменить все виды файлов, что заставит нас чувствовать себя дома лучше. После изучения этой главы вы будете больше знать о следующем:</p>
<ul>
<li>Обустройство среды</li>
<li>Общие установочные файлы shell</li>
<li>Конфигурация shell</li>
<li>Настройка приглашения</li>
<li>Настройка графической среды</li>
<li>Звуковые и видео приложения</li>
<li>Дисплей и оконные менеджеры</li>
<li>Как работает клиент-серверная система X</li>
<li>Язык и настойки шрифта</li>
<li>Установка нового программного обеспечения</li>
<li>Обновление существующих пакетов</li>
</ul>
  <div id="node-259" class="section-3">
  <h1 class="book-heading">Важные вещи в домашнем хозяйстве</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<h3>Введение</h3>
<p>Как мы уже упоминали, навести беспорядок в системе достаточно легко. Поэтому не следует пренебрегать тем, что позволяет сохранять рабочее место опрятным. Если вы научитесь этому с самого начала, то приобретете хорошую привычку, которая поможет вам сэкономить время при программировании в системе Linux (UNIX) или при решении задач управления системой. Здесь приведены несколько способов сделать себе жизнь легче:</p>
<ul>
<li>Создайте каталог bin для ваших файлов программ и скриптов.</li>
<li>Организуйте неисполняемые файлы в подходящие каталоги и создайте так много каталогов, как вам требуется. Например, могут быть отдельные каталоги для изображений, документов, проектов, загруженных файлов, электронных таблиц, личных файлов, и так далее.</li>
<li>Делайте каталоги личными с помощью команды <strong>chmod</strong> <span class="mono">700 dirname</span>.</li>
<li>Давайте вашим файлам осмысленные имена, такие как <span class="mono">Жалоба премьер-министру 050302</span>, а не <span class="mono">письмо1</span>.</li>
</ul>
<h3>Создайте пространство</h3>
<p>На некоторых системах установленная квота может заставлять вас время от времени выполнять очистку, также физические ограничения жесткого диска могут заставить вас оставлять больше места без запуска каких-либо программ мониторинга. В этом разделе рассматриваются несколько способов освобождения места на диске, помимо использования команды <strong>rm</strong>.</p>
<p>Выполните команду <strong>quota</strong> <span class="mono">-v</span>, чтобы увидеть, сколько места осталось.</p>
<h4>Опустошение файлов</h4>
<p>Иногда содержание файла может вас не интересовать, но вам нужно имя файла в качестве маркера (например, вам просто необходим файл-метка, напоминание о том, что файл был там или должен быть через некоторое время в будущем). Перенаправление вывода "нулевой" команды в оболочках Bourne и Bash как раз это сделает:</p>
<pre>
andy:~> <strong>cat wishlist > placeholder</strong>

andy:~> <strong>ls -la placeholder</strong>
-rw-rw-r--    1 andy   andy       200 Jun 12 13:34 placeholder

andy:~>  <strong>> placeholder</strong>

andy:~> <strong>ls -la placeholder</strong>

-rw-rw-r--    1 andy   andy         0 Jun 12 13:35 placeholder
</pre><p>
Процесс уменьшения существующего файла в файл с тем же именем, но размер которого равен нулю байтов, называется усечением.</p>
<p>Также создать новый пустой файл можно с помощью команды <strong>touch</strong>. Использование <strong>touch</strong> на существующий файл обновит только его метку. Для выяснения деталей посмотрите info-страницу для <strong>touch</strong>.</p>
<p>Для получения "почти" пустого файла используйте команду <strong>tail</strong>. Допустим, список пожеланий пользователя <em>andy</em> становится довольно длинным, т.к. он всегда добавляет материал в конец, но никогда не удаляет то, что он уже получил. Теперь он хочет только сохранить последние пять пунктов:</p>
<pre>
andy:~> <strong>tail -5 wishlist > newlist</strong>

andy:~> <strong>cat newlist > wishlist</strong>

andy:~> <strong>rm newlist</strong>
</pre><h4>Подробнее о log-файлах</h4>
<p>Некоторые программы Linux настойчиво требуют записи различных выходных данных в файл журнала (log-файл). Обычно существуют установки только для журналов ошибок, или журналировать минимальное количество информации, например, установка уровня отладки программы. Но даже в этом случае, вы можете не волноваться о файле журнала. Здесь несколько способов, чтобы избавиться от них или, по крайней мере, несколько ограничить их размер:</p>
<ul>
<li>Если вы уверены, что log-файл вам больше не потребуется, попробуйте удалить его, когда программа не запущена. Некоторые программы могут даже обнаружить после перезагрузки, что файла журнала нет и не будут создавать его снова.</li>
<li>Если после удаления log-файла программа создает его снова, прочитайте документацию к этой программе в поисках варианта команды, которая исключит создание лог-файла.</li>
<li>Попробуйте сделать log-файлы меньше за счет того, что будет вводится только информация, имеющая отношение к вам, или только имеющая значение.</li>
<li>Попробуйте заменить файл журнала символической ссылкой <span class="mono">/dev/null</span>; если вам повезет, программа не будет жаловаться. Не делайте такого с лог-файлами программ, которые запускаются при загрузке системы, или программами, которые работают от хрона (см. <a href="http://younglinux.info/#">Главу 4, Процессы</a>). Эти программы могут заменить символическую ссылку небольшим файлом, который начнет расти снова.</li>
</ul>
<h4>Почта</h4>
<p>Регулярно очищайте ваш почтовый ящик, создавайте подкаталоги и автоматически перенаправляйте используемый <strong>procmail</strong> (см. info-страницы) или фильтры от предпочитаемого вами приложения для чтения почты. Если у вас есть  папка-корзина, то регулярно очищайте ее.</p>
<p>Для перенаправления почты используйте файл <span class="mono">.forward</span> в вашем домашнем каталоге. Почтовый сервис Linux ищет именно этот файл для локальной доставки. Содержание файла определяет то, что почтовая система должна делать с вашей почтой. Он может содержать одну строку, содержащую полный адрес электронной почты. В таком случае система будет отправлять все письма на этот адрес. Например, при аренде места для сайта, вы можете направлять почту, предназначенную для веб-мастера на свой аккаунт, чтобы не использовать место на диске. Файл <span class="mono">.forward</span> вебмастера может выглядеть следующим образом:</p>
<pre>
webmaster@www ~/> <strong>cat .forward</strong>
mike@pandora.be
</pre><p>
Использование пересылки почты также полезно, т.к. освобождает вас от необходимости проверять несколько почтовых ящиков. Вы можете сделать так, чтобы каждый адрес указывал на основную почту, которую вам удобней использовать.</p>
<p>Вы можете обратиться к системному администратору, чтобы он определил направления для вас в локальный файл почтовых псевдонимов, например, когда аккаунт закрывается, но электронная почта пока остается активной.</p>
<h4>Экономия пространства ссылкой</h4>
<p>Когда нескольким пользователям необходимо иметь доступ к одному и тому же файлу или программе, когда исходное имя файла слишком длинное или его слишком трудно запомнить, используйте символическую ссылку вместо создания отдельной копии для каждого пользователя или назначения.</p>
<p>Множественные символические ссылки могут иметь различные названия, например, ссылку можно назвать <span class="mono">monfichier</span> в одной пользовательской директории и <span class="mono">mylink</span> в другой. Несколько ссылок (с разными именами) на один и тот же файл может быть в одном и том же каталоге. Часто это можно наблюдать в каталоге <span class="mono">/lib</span> с помощью команды</p>
<p><span class="mono">ls -l /lib</span></p>
<p>Вы увидите, что в этом каталоге очень много ссылок, указывающих на одинаковые файлы. Они создаются для программ, ищущих какое-нибудь определенное название, в результате ссылки указывают на правильные/текущие название библиотек, которые требуются под другими именами.</p>
<h4>Ограничение размера файлов</h4>
<p>Оболочка содержит встроенную команду для ограничения размера файлов, <strong>ulimit</strong>, которая также может быть использована для отображения ограничений на системные ресурсы:</p>
<pre>
cindy:~> ulimit -a
core file size (blocks)     0
data seg size (kbytes)      unlimited
file size (blocks)          unlimited
max locked memory (kbytes)  unlimited
max memory size (kbytes)    unlimited
open files                  1024
pipe size (512 bytes)       8
stack size (kbytes)         8192
cpu time (seconds)          unlimited
max user processes          512
virtual memory (kbytes)     unlimited
</pre><p>
Cindy не разработчик и не заботится об основных дампах, которые содержат информацию об отладке программы. Если вам нужны основные дампы, вы можете установить их размер с помощью команды <strong>ulimit</strong>. В info-страницах bash дается более подробное объяснение.</p>
<p class="note"><img src="../../../img/linuxintro/note.gif" alt="" /><strong> Core файл?</strong><br />
Файл core или основной дамп иногда создается, когда не все так хорошо с программой во время ее выполнения. Файл core содержит копию памяти системы во время того, когда произошла ошибка.
</p>
<h4>Сжатые файлы</h4>
<p>Сжатые файлы весьма полезны, поскольку они занимают меньше места на жестком диске. Еще одним преимуществом является то, что они занимают меньше пропускной способности при отправке их по сети. Многие файлы, такие как man-страницы, в системе хранятся в сжатом виде. Тем не менее, чтобы получить информацию их надо распаковать; как и сжатие это занимает довольно много времени. Вряд ли вам захочется распаковывать страницу, например, описывающую опции команды, а затем сжимать ее снова. Большинство людей, кроме того, забывают удалить лишнее после того, как они нашли необходимую им информацию.</p>
<p>Поэтому есть инструменты, которые создают сжатые файлы, но распаковывают их только в память. Фактически сжатый файл остается на диске как есть. Большинство систем поддержки <strong>zgrep</strong>, <strong>zcat</strong>, <strong>bzless</strong> и других членов z-семейства предотвращают ненужные действия по распаковке/сжатию. Посмотрите в ваш каталог исполняемых файлов системы, а также info-страницы.</p>
<p>См. <a href="http://younglinux.info/#">Главу 9, Основные методы резервного копирования</a> для дополнительной информации по существующему сжатию файлов и примеры создания архивов.</p>
  </div>
<div id="node-265" class="section-3">
  <h1 class="book-heading">Ваше текстовое окружение</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<h2>Переменные окружения</h2>
<h3>Главное</h3>
<p>Мы уже упоминали несколько переменных окружения, таких как <span class="mono">PATH</span> и <span class="mono">HOME</span>. До сих пор мы видели только примеры, в которых они используются в оболочке для определенной цели. Но в Linux существует множество других утилит, для нормальной работы которых необходима информация о вас.</p>
<p>Какая еще информация нужна программам, кроме путей и домашних каталогов?</p>
<p>Многим программам необходима информация о том, какой терминал вы используете; эта информация хранится в переменной <span class="mono">TERM</span>. В текстовом режиме, это будет эмуляция терминала <em>linux</em>, в графическом режиме, скорее всего, вы используете <em>xterm</em>. Многим программам требуется информация о предпочитаемом вами редакторе на случай, если они должны будут запускать редактор как дочерний процесс. Оболочка, которую вы используете, хранится в переменной <span class="mono">SHELL</span>, тип операционной системы - в <span class="mono">OS</span> и так далее. Список всех текущих переменных, определенных для вашей сессии, можно посмотреть, введя команду  <strong>printenv</strong>.</p>
<p>Переменные окружения управляются оболочкой. В отличие от регулярных переменных оболочки, переменные окружения наследуются любой программой, которую вы запускаете, в том числе другой оболочкой. Новым процессам присваиваются копии этих переменных; процессы могут их читать, изменять и, в свою очередь, передавать собственным дочерним процессам.</p>
<p>В именах переменных нет ничего особенного, за исключением того, что по соглашению используют прописные буквы. Вы можете придумать любое имя, какое захотите, хотя существуют стандартные переменные, которые являются достаточно важными, поэтому они одинаковы во всех системах Linux, например <span class="mono">PATH</span> и <span class="mono">HOME</span>.</p>
<h3>Экспорт переменных</h3>
<p>Содержимое отдельных переменной обычно отображается с помощью команды <strong>echo</strong>, как в этих примерах:</p>
<pre>
debby:~> <strong>echo $PATH</strong>
/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin:/usr/local/bin

debby:~> <strong>echo $MANPATH</strong>
/usr/man:/usr/share/man/:/usr/local/man:/usr/X11R6/man
</pre><p>
Если вы хотите изменить содержимое переменной таким, чтобы она была полезна для других программ, вам следует экспортировать новое значение из вашего окружения в окружение, которое запускают эти программы. Типичным примером является экспорт переменной <span class="mono">PATH</span>. Вы можете объявить ее добавлением  очередного пути, например, с тем чтобы иметь возможность играть в симулятор полетов, который находится в <span class="mono">/opt/FlightGear/bin</span>:</p>
<pre>
debby:~> PATH=$PATH:/opt/FlightGear/bin
</pre><p>
Такая запись указывает оболочке искать программ не только в текущем пути <span class="mono">$PATH</span>, но и в дополнительном каталоге  <span class="mono">/opt/FlightGear/bin</span>.</p>
<p>Но если новое значение переменной <span class="mono">PATH</span> не известно окружению, то работать ничего не будет:</p>
<pre>
debby:~> runfgfs
bash: runfgfs: command not found
</pre><p>
В Bash мы обычно делаем это с помощью одного элегантного шага:</p>
<p><span class="mono">export VARIABLE=value</span></p>
<p>Тот же самый способ используется для переменной <span class="mono">MANPATH</span>, которая сообщает команде <strong>man</strong>, где искать сжатые man-страницы. Когда новые программы устанавливаются в новые или необычные каталоги, документация для них, вероятно, также будет в нестандартных каталогах. Если вы хотите прочитать справочные страницы этих новых программ, расширьте переменную <span class="mono">MANPATH</span>:</p>
<pre>
debby:~> <strong>export MANPATH=$MANPATH:/opt/FlightGear/man</strong>

debby:~> <strong>echo $MANPATH</strong>
/usr/man:/usr/share/man:/usr/local/man:/usr/X11R6/man:/opt/FlightGear/man
</pre><p>
Вы можете избежать повторного ввода этой команды в каждом окне, которое вы открываете, добавив эту строку в один из ваших установочных файлов оболочки, см. <a href="http://younglinux.info/#">Раздел "Установочные файлы shell"</a>.</p>
<h3>Зарезервированные переменные</h3>
<p>Следующая таблица дает обзор наиболее распространенных предопределенных переменных:</p>
<p><strong>Таблица. Стандартные переменные окружения</strong></p>
<table class="il">
<tr>
<td width="200"><strong>Имя переменной</strong></td>
<td><strong>Хранимая информация</strong></td>
</tr>
<tr>
<td>DISPLAY</td>
<td>используется системой X Window для определения сервера, который отображает на дисплей</td>
</tr>
<tr>
<td>DOMAIN</td>
<td>доменное имя</td>
</tr>
<tr>
<td>EDITOR</td>
<td>хранит предпочитаемый вами редактор</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>размер файла истории shell (в количестве строк)</td>
</tr>
<tr>
<td>HOME</td>
<td>адресный путь вашего домашнего каталога</td>
</tr>
<tr>
<td>HOSTNAME</td>
<td>имя локального хоста</td>
</tr>
<tr>
<td>INPUTRC</td>
<td>определяет местоположение файлов устройств ввода, например, клавиатуры</td>
</tr>
<tr>
<td>LANG</td>
<td>предпочитаемый язык</td>
</tr>
<tr>
<td>LOGNAME</td>
<td>логин</td>
</tr>
<tr>
<td>MAIL</td>
<td>местонахождение вашей папки для входящей почты</td>
</tr>
<tr>
<td>MANPATH</td>
<td>пути поиска для man-страниц</td>
</tr>
<tr>
<td>OS</td>
<td>строка, описывающая операционную систему</td>
</tr>
<tr>
<td>OSTYPE</td>
<td>дополнительные сведения о версии и т.п.</td>
</tr>
<tr>
<td>PAGER</td>
<td>используется программами, такими как <strong>man</strong>, которым требуется знать, что делать в случае, если вывод больше, чем окно терминала</td>
</tr>
<tr>
<td>PATH</td>
<td>поиск путей для команд </td>
</tr>
<tr>
<td>PS1</td>
<td>первоначальное приглашение</td>
</tr>
<tr>
<td>PS2</td>
<td>вторичное приглашение</td>
</tr>
<tr>
<td>PWD</td>
<td>текущий рабочий каталог</td>
</tr>
<tr>
<td>SHELL</td>
<td>текущая оболочка</td>
</tr>
<tr>
<td>TERM</td>
<td>тип терминала</td>
</tr>
<tr>
<td>UID</td>
<td>ID пользователя</td>
</tr>
<tr>
<td>USER(NAME)</td>
<td>имя пользователя</td>
</tr>
<tr>
<td>VISUAL</td>
<td>ваш предпочитаемый полноэкранный редактор</td>
</tr>
<tr>
<td>XENVIRONMENT</td>
<td>местонахождение ваших личных настроек поведения X</td>
</tr>
<tr>
<td>XFILESEARCHPATH</td>
<td>пути поиска графических библиотек</td>
</tr>
</table>
<p>Многие переменные не только предопределены, но также их значения  устанавливаются заранее, при этом используются конфигурационные файлы. Мы обсудим это в следующем разделе.</p>
<h2>Установочные файлы shell</h2>
<p>При вводе команды <strong>ls <span class="monoi">-al</span></strong> для получения расширенного списка всех файлов, в том числе начинающихся с точки, содержащихся в вашем домашнем каталоге, вы увидите один или несколько файлов, начинающихся с . и заканчивающихся на <em>rc</em>. Для Bash это будет <span class="mono">.bashrc</span>. Это копия общесистемного конфигурационного файла <span class="mono">/etc/bashrc</span>.</p>
<p>При входе логина в shell, <strong>login</strong> выполнит идентификацию, установит окружение и запустит вашу оболочку. В случае <strong>bash</strong> следующим шагом будет чтение общего профиля из <span class="mono">/etc</span>, если такой файл существует. Затем <strong>bash</strong> ищет <span class="mono">~/.bash_profile, ~/.bash_login</span> и <span class="mono">~/.profile</span> в указанном порядке, читает и выполняет команды из первого, который существует и который можно прочитать. Если таких файлов нет, то используется <span class="mono">/etc/bashrc</span>.</p>
<p>Когда происходит выход их оболочки, <strong>bash</strong> считывает и выполняет команды из файла <span class="mono">~/.bash_logout</span>, если он существует.</p>
<p>Эта процедура подробно описана в man-страницах <strong>login</strong> и <strong>bash</strong>.</p>
<h2>Стандартный набор установочных файлов</h2>
<h3>Пример /etc/profile</h3>
<p>Давайте посмотрим на некоторые из этих конфигурационных файлов. Первый для чтения — это <span class="mono">/etc/profile</span>, в котором устанавливаются такие важные переменные, как <span class="mono">PATH, USER</span> и <span class="mono">HOSTNAME</span>:</p>
<pre>
debby:~> <strong>cat /etc/profile</strong>
# /etc/profile

# System wide environment and startup programs, for login setup
# Functions and aliases go in /etc/bashrc


# Path manipulation
if [ `id -u` = 0 ] && ! echo $PATH | /bin/grep -q "/sbin" ; then
    PATH=/sbin:$PATH
fi

if [ `id -u` = 0 ] && ! echo $PATH | /bin/grep -q "/usr/sbin" ; then
    PATH=/usr/sbin:$PATH
fi

if [ `id -u` = 0 ] && ! echo $PATH | /bin/grep -q "/usr/local/sbin"
    then
    PATH=/usr/local/sbin:$PATH
fi

if ! echo $PATH | /bin/grep -q "/usr/X11R6/bin" ; then
    PATH="$PATH:/usr/X11R6/bin"
fi
</pre><p>
Эти строки проверяют устанавливаемые пути: если root открывает оболочку (ID пользователя 0), проверяется пути <span class="mono">/sbin, /usr/sbin</span> и <span class="mono">/usr/local/sbin</span>. Если нет, то они добавляются. Для всех проверяется путь <span class="mono">/usr/X11R6/bin</span>.</p>
<pre>
# No core files by default
ulimit -S -c 0 > /dev/null 2>&1
</pre><p>
Все, что не нужно отправляется в <span class="mono">/dev/null</span>, если пользователь не меняет эту настройку.</p>
<pre>
USER=`id -un`
LOGNAME=$USER
MAIL="/var/spool/mail/$USER"

HOSTNAME=`/bin/hostname`
HISTSIZE=1000
</pre><p>
Здесь общим переменным назначаются их стандартные значения.</p>
<pre>
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ]; then
    INPUTRC=/etc/inputrc
fi
</pre><p>
Если переменная <span class="mono">INPUTRC</span> не установлена, и нет <span class="mono">.inputrc</span> в домашнем каталоге пользователя, то будет загружен файл, отвечающий за ввод по умолчанию.</p>
<pre>
export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC
</pre><p>
Все переменные экспортируются, поэтому они доступны для других программ, запрашивающих информацию о вашем окружении.</p>
<h3>Каталог profile.d</h3>
<pre>
for i in /etc/profile.d/*.sh ; do
    if [ -r $i ]; then
    	. $i
    fi
done
unset i
</pre><p>
Все читаемые скрипты shell из каталога <span class="mono">/etc/profile.d</span> читаются и выполняются. Это то, что делает возможным <em>color-ls</em>, похожесть <strong>vi</strong> на <strong>vim</strong>, локальные настройки и т.д. Временная переменная <em>i</em> не устанавливается для предотвращения неадекватного поведения оболочки позже.</p>
<h3>Пример .bash_profile</h3>
<p>Затем bash ищет <span class="mono">.bash_profile</span> в домашнем каталоге пользователя:</p>
<pre>
debby:~> cat .bash_profile 
#####################################################
#                                                   #
#   .bash_profile file                              #
#                                                   #
#   Executed from the bash shell when you log in.   #
#                                                   #
#####################################################

source ~/.bashrc
source ~/.bash_login
</pre><p>
В файле содержаться указания оболочке сначала прочитать <span class="mono">~/.bashrc</span>, потом <span class="mono">~/.bash_login</span>. При работе с окружением оболочки вы будете сталкиваться с встроенной в shell командой <strong>source</strong> достаточно часто: она используется для  применения изменений конфигурации к текущему окружению.</p>
<h3>Пример .bash_login</h3>
<p>Файл <span class="mono">~/.bash_login</span> определяет по умолчанию защиту файлов, устанавливая значение <strong>umask</strong>, см. <a href="http://younglinux.info/#">Раздел "Вступление в другую группу"</a>. Файл <span class="mono">~/.bashrc</span> используется для определения группы пользовательских псевдонимов, функции и личные переменных окружения. Сначала читается <span class="mono">/etc/bashrc</span>, который описывает стандартное приглашение (<span class="mono">PS1</span>) и значение по умолчанию umask. После этого вы можете добавить собственные настройки. Если нет <span class="mono">~/.bashrc</span>, то по умолчанию читается <span class="mono">/etc/bashrc</span>.</p>
<h3>Пример /etc/bashrc</h3>
<p>Ваш файл <span class="mono">/etc/bashrc</span> может выглядеть следующим образом:</p>
<pre>
debby:~> cat /etc/bashrc
# /etc/bashrc

# System wide functions and aliases
# Environment stuff goes in /etc/profile

# by default, we want this to get set.
# Even for non-interactive, non-login shells.
if [ `id -gn` = `id -un` -a `id -u` -gt 99 ]; then
	umask 002
else
	umask 022
fi
</pre><p>
Эти строки устанавливают значение <strong>umask</strong>. Затем, в зависимости от типа shell, устанавливается приглашение:</p>
<pre>
# are we an interactive shell?
if [ "$PS1" ]; then
  if [ -x /usr/bin/tput ]; then
    if [ "x`tput kbs`" != "x" ]; then 
# We can't do this with "dumb" terminal
      stty erase `tput kbs`
    elif [ -x /usr/bin/wc ]; then
      if [ "`tput kbs|wc -c `" -gt 0 ]; then 
# We can't do this with "dumb" terminal
        stty erase `tput kbs`
      fi
    fi
  fi
  case $TERM in
	xterm*)
	if [ -e /etc/sysconfig/bash-prompt-xterm ]; then
		PROMPT_COMMAND=/etc/sysconfig/bash-prompt-xterm
	else
   PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:\
${PWD/$HOME/~}\007"'
	fi
    ;;
	*)
   [ -e /etc/sysconfig/bash-prompt-default ] && PROMPT_COMMAND=\
/etc/sysconfig/bash-prompt-default
	    ;;
    esac
    [ "$PS1" = "\\s-\\v\\\$ " ] && PS1="[\u@\h \W]\\$ "
    
    if [ "x$SHLVL" != "x1" ]; then # We're not a login shell
        for i in /etc/profile.d/*.sh; do
	    if [ -x $i ]; then
	        . $i
	    fi
	done
    fi
fi
</pre><h3>Пример .bash_logout</h3>
<p>Во время выхода из системы, выполняются команды из <span class="mono">~/.bash_logout</span>, которые могут, например, очищать терминал, так что у вас появляется чистое окно при входе из удаленного сеанса или при выходе из системной консоли:</p>
<pre>
debby:~> <strong>cat .bash_logout</strong>
# ~/.bash_logout

clear
</pre><p>
Давайте ближе рассмотрим, как эти скрипты работают в следующем разделе. Храните <strong>info <span class="monoi">bash</span></strong> под рукой.</p>
<h2>Приглашение Bash</h2>
<h3>Введение</h3>
<p>Приглашение Bash может делать гораздо больше, чем отображение такой простой информации, как имя пользователя, имя машины и некоторое указание на текущий рабочий каталог. Мы можем добавить другую информацию, такую как дата и время, количество подключенных пользователей и т.д.</p>
<p>Однако, прежде чем мы начнем, сохраним наше текущее приглашение в другую переменную окружения:</p>
<pre>
[jerry@nowhere jerry]$ <strong>MYPROMPT=$PS1</strong>

[jerry@nowhere jerry]$ <strong>echo $MYPROMPT</strong>
[\u@\h \W]\$

[jerry@nowhere jerry]$
</pre><p>
Когда мы теперь будем изменять строку приглашения, например, с помощью команды <span class="mono">PS1="->"</span>, то всегда сможем получить нашу оригинальную строку обратно с помощью команды <span class="mono">PS1=$MYPROMPT</span>. Конечно, вы получите ее обратно, и когда  подключитесь снова; так будет до тех пор, пока вы возитесь с приглашением в командной строке и не вставляете его в файл конфигурации оболочки.</p>
<h3>Некоторые примеры</h3>
<p>Для того, чтобы понять эти приглашения и используемые управляющие последовательности, обратитесь к info- и man-страницам Bash.</p>
<ul>
<li><strong>export <span class="mono">PS1="[\t \j] "</span></strong></li>
</ul>
<p>Отображает время и количество выполняемых заданий.</p>
<ul>
<li><strong>export <span class="mono">PS1="[\d][\u@\h \w] : "</span></strong></li>
</ul>
<p>Отображает дату, имя пользователя, название хоста и текущую рабочую директорию. Заметьте, что \W отображает только конечные имена текущего каталога.</p>
<ul>
<li><strong>export <span class="mono">PS1="{\!} "</span></strong></li>
</ul>
<p>Отображает номер каждой команды в истории.</p>
<ul>
<li><strong>export <span class="mono">PS1="\[\033[1;35m\]\u@\h\[\033[0m\] "</span></strong></li>
</ul>
<p>Делает user@host розовым.</p>
<ul>
<li><strong>export <span class="mono">PS1="\[\033[1;35m\]\u\[\033[0m\] \[\033[1;34m\]\w\[\033[0m\] "</span></strong></li>
</ul>
<p>Раскрашивает имя пользователя в розовый цвет, а рабочий каталог в голубой.</p>
<ul>
<li><strong>export <span class="mono">PS1="\[\033[1;44m\]$USER is in \w\[\033[0m\] "</span></strong></li>
</ul>
<p>Приглашение для людей, которым трудно видеть разницу между приглашением и тем, что они вводят.</p>
<ul>
<li><strong>export <span class="mono">PS1="\[\033[4;34m\]\u@\h \w \[\033[0m\]"</span></strong></li>
</ul>
<p>Подчеркнутое приглашение.</p>
<ul>
<li><strong>export <span class="mono">PS1="\[\033[7;34m\]\u@\h \w \[\033[0m\] "</span></strong></li>
</ul>
<p>Белые символы на синем фоне.</p>
<ul>
<li><strong>export <span class="mono">PS1="\[\033[3;35m\]\u@\h \w \[\033[0m\]\a"</span></strong></li>
</ul>
<p>Розовая строка иным шрифтом, которая предупреждает вас, когда ваши команды закончили работу.</p>
<ul>
<li><strong>export <span class="mono">PS1=...</span></strong></li>
</ul>
<p>Переменные экспортируются, так что впоследствии выполняющиеся команды также будут знать об окружении. Для конфигурации строки приглашения лучше изменить конфигурационный файл оболочки, <span class="mono">~/.bashrc</span>.</p>
<p>Если вам захочется, то приглашения могут выполнять shell-скрипты и вести себя по-разному в зависимости от условий. У вас может даже строка приглашения играть мелодию при выполнении команды, хотя это вам быстро надоест. Более подробную информацию можно найти в <noindex><a href="http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/">Bash-Prompt HOWTO</a></noindex>.</p>
<h2>Сценарии оболочки</h2>
<h3>Что такое сценарии?</h3>
<p>Скрипт оболочки, как мы видели в примерах конфигурации shell, представляет собой текстовый файл, содержащий команды оболочки. Когда такой файл используется в качестве первого аргумента без опции при вызове Bash, и без опций <span class="mono">-c</span> или <span class="mono">-s</span>, Bash считывает и выполняет команды из файла, затем выходит. Этот режим работы создает неинтерактивную оболочку. Когда Bash запускает shell-скрипт, он устанавливает специальный параметр 0 к имени файла, а не имя к оболочке, и позиционные параметры (все, что следует за именем скрипта) устанавливаются в остальные аргументы, если таковые задаются. Если  дополнительные аргументы не задаются, позиционные параметры не включаются.</p>
<p>Скрипт оболочки можно сделать исполняемым с помощью команды <strong>chmod</strong> за счет включения бита исполнения. Когда Bash находит такой файл при поиске в <span class="mono">PATH</span> по отношению к команде, он порождает подоболочку для его выполнения. Другими словами, выполнение</p>
<p><span class="mono">filename <em>ARGUMENTS</em> </span><br />
эквивалентно выполнению<br />
<span class="mono">bash <em>filename ARGUMENTS</em></span></p>
<p>если "filename" представляет собой исполняемый скрипт. Эта подоболочка  инициализирует себя, так что эффект такой, как если бы новая оболочка интерпретировала сценарий, с тем исключением, что места команд, запомненные родителем (см. <strong>hash</strong> в info-страницах), сохраняются ребенком.</p>
<p>Большинство версий UNIX наделяют эту часть команд операционной системы исполняемым механизмом. Если первая строка сценария начинается с двух символов "#!", оставшаяся часть строки указывает интерпретатор для программы. Таким образом, вы можете указать <strong>bash, awk, perl</strong> или другой интерпретатор или оболочку и писать остальную часть файла сценария на этом языке.</p>
<p>Аргументы для интерпретатора состоят из одного дополнительного аргумента, который следует за именем интерпретатора в первой строке файла сценария, после следует имя файла сценария, а затем остальные аргументы. Bash будет выполнять это действие на операционных системах, которые не обрабатывают это самостоятельно.</p>
<p>Сценарии Bash часто начинаются с</p>
<p><span class="mono">#! /bin/bash</span></p>
<p>(предполагая, что Bash была установлена в <span class="mono">/bin</span>), так как это гарантирует использование Bash для интерпретации сценариев, даже если скрипт выполняется под другой оболочкой.</p>
<h3>Некоторые простые примеры</h3>
<p>Очень простой скрипт, состоящий только из одной команды, которая приветствует пользователя, выполняется так:</p>
<pre>
[jerry@nowhere ~] <strong>cat hello.sh</strong>
#!/bin/bash
echo "Hello $USER"
</pre><p>
Сценарий фактически состоит только из одной команды <strong>echo</strong>, которая использует значение (<em>$</em>) переменной окружения <span class="mono">USER</span>, чтобы напечатать строку, настроенную на пользователя, который вызывает скрипт.</p>
<p>Другой однострочный пример, используемый для отображения подключенных пользователей:</p>
<pre>
#!/bin/bash
who | cut -d " " -f 1 | sort -u
</pre><p>
Вот скрипт, состоящий из несколько строк, которые я использую, чтобы создать резервные копии всех файлов в каталоге. Сначала скрипт создает список всех файлов в текущем каталоге и помещает его в переменную <span class="mono">LIST</span>. Затем он устанавливает имя копии для каждого файла, и затем копирует файл. Для каждого файла выводится сообщение:</p>
<pre>
tille:~> <strong>cat bin/makebackupfiles.sh</strong>
#!/bin/bash
# make copies of all files in a directory
LIST=`ls`
for i in $LIST; do
	ORIG=$i
	DEST=$i.old
	cp $ORIG $DEST
	echo "copied $i"
done
</pre><p>Просто ввод строки подобной <strong>mv</strong> <span class="monoi">* *.old</span> не будет работать, как вы заметите при попытке выполнить это на ряд тестовых файлов. Команда <strong>echo</strong> была добавлена для отображения какой-либо деятельности. <strong>echo</strong> обычно полезна, когда сценарий не  работает: постепенно просматривая код, вы найдете ошибку в кратчайшие сроки.</p>
<p>Каталог <span class="mono">/etc/rc.d/init.d</span> содержит множество примеров. Давайте посмотрим на этот сценарий, который управляет фиктивным сервером IcanSeeYou:</p>
<pre>
#!/bin/sh
# description: ICanSeeYou allows you to see networked people

# process name: ICanSeeYou
# pidfile: /var/run/ICanSeeYou/ICanSeeYou.pid
# config: /etc/ICanSeeYou.cfg

# Source function library.
. /etc/rc.d/init.d/functions

# See how (with which arguments) we were called.
case "$1" in
	start)
		echo -n "Starting ICanSeeYou: "
		daemon ICanSeeYou
		echo
		touch /var/lock/subsys/ICanSeeYou
		;;
	stop)
		echo -n "Shutting down ICanSeeYou: "
		killproc ICanSeeYou
		echo
		rm -f /var/lock/subsys/ICanSeeYou
		rm -f /var/run/ICanSeeYou/ICanSeeYou.pid
		;;
	status)
		status ICanSeeYou
		;;
	restart)
		$0 stop
		$0 start
		;;
	*)
		echo "Usage: $0 {start|stop|restart|status}"
		exit 1
esac

exit 0
</pre><p>
Во-первых, размещается . (точка), которая управляет множеством функций оболочки и используется практически во всех скриптах в <span class="mono">/etc/rc.d/init.d</span>. Затем размещается команда <strong>case</strong>, которая определяет 4 различных способа выполнения сценария. Например, это может быть <strong>ICanSeeYou</strong> <span class="monoi">start</span>. Решением в этом случае будет чтение (первого) аргумента сценария с выражением <em>$1</em>.</p>
<p>Когда дается не совместимый вход, то срабатывает код, отмеченный звездочкой, в котором скрипт выдает сообщение об ошибке. Список <strong>case</strong> заканчивается инструкцией <strong>esac</strong>. В случае <em>start</em> программа сервера запускается как демон, и назначаются ID процесса и шлюз. В случае <em>stop</em> процесс сервера сходит на нет и останавливается, шлюз и PID удаляются. Опции, такие как опции <span class="mono">daemon</span> и функции как <span class="mono">killproc</span> определены в файле <span class="mono">/etc/rc.d/init.d/functions</span>. Эта установка специфична для дистрибутива,  используемого в этом примере. Запускающие скрипты в вашей системе могут использовать другие функции, определенные в других файлах, или вообще никакие.</p>
<p>В случае успеха сценарий возвращает код выхода нуля к его родителю.<br />
Этот сценарий является прекрасным примером использования функций, которые позволяют легче читать сценарий и делать работу быстрее. Заметьте, что здесь используется <strong>sh</strong> вместо <strong>bash</strong>, чтобы сделать их полезными для более широкого круга систем. В системе Linux, вызывая <strong>bash</strong> как <strong>sh</strong>, результаты в оболочке работают в POSIX-совместимом режиме.</p>
<p>Man-страницы <strong>bash</strong> содержат больше информации об объединении команд, <strong>for-</strong> и <strong>while</strong>-петлях, регулярных выражений, а также примеры. Понятный Bash для системных администраторов и опытных пользователей, с упражнениями, от того же автора, как "Введение в руководство Linux", находится на <noindex>http://tille.garrels.be/training/bash/. Подробное описание особенностей Bash и приложений есть в справочном руководстве <a href="http://tldp.org/LDP/abs/html/index.html">"Продвинутые сценарии Bash"</a></noindex>.</p>
  </div>
<div id="node-267" class="section-3">
  <h1 class="book-heading">Графическая среда</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<h2>Введение</h2>
<p>Обычный пользователь может особо не заботиться о настройках входа в систему, однако Linux предлагает широкий спектр красивых менеджеров рабочего стола для использования под X, различные графические среды. Использование и настройка оконных менеджеров и графических сред достаточно простая задача, они напоминают стандартные среды MS Windows, Apple или UNIX CDE, хотя многие пользователи Linux предпочитают роскошные настольные ПК и фантастические оконные менеджеры. Мы не будем обсуждать здесь специфичные настройки пользователя. Простой эксперимент и чтение документации из встроенной <strong>Справки</strong> менеджеров дадут больше информации для того, чтобы настройка стала легким делом.</p>
<p>Мы, однако, внимательно рассмотрим лежащую в основе систему.</p>
<h2>Система X Window</h2>
<p>X Window System представляет собой явно сетевое окно системы, которая работает на широком спектре вычислительных и графических машин. Серверы X Window System работают на компьютерах с растровыми дисплеями. X сервер распределяет пользовательский ввод и принимает запросы на вывод от нескольких клиентских программ через различные межпроцессорные каналы связи. Хотя самый распространенный случай – клиентские программы работают на той же машине, что и сервер, но клиенты могут также прозрачно работать от других машин (включая машины с различными архитектурами и операционными системами). Мы узнаем, как это делается в <a href="http://younglinux.info/#">Главе 10, Сеть</a>, в которой рассказывается о сетях и удаленных приложениях.</p>
<p>X поддерживает параллельные иерархические окна, текст и графические операции как на монохромных, так и цветных дисплеях. Число клиентских программ X, которые используют X-сервер достаточно велико. Некоторые программы, внедренные в ядро распределением X Consortium, включают:</p>
<ul>
<li><strong>xterm</strong>: эмулятор терминала</li>
<li><strong>twm</strong>: минималистичный оконный менеджер</li>
<li><strong>xdm</strong>: менеджер дисплеев</li>
<li><strong>xconsole</strong>: программа перенаправления консоли</li>
<li><strong>bitmap</strong>: растровый редактор</li>
<li><strong>xauth, xhost</strong> и <strong>iceauth</strong>: программы контроля доступа</li>
<li><strong>xset, xmodmap</strong> и многие другие: предпочитаемые пользователем настройки программ</li>
<li><strong>xclock</strong>: часы</li>
<li><strong>xlsfonts</strong> и другие: экранный шрифт, утилиты для просмотра информации о шрифтах, окна и отображения</li>
<li><strong>xfs</strong>: сервер шрифтов</li>
<li>...</li>
</ul>
<p>Мы опять отсылаем к man-страницам этих команд за подробной информацией. Подробнее разъяснения доступных функций можно найти в руководстве <em>Xlib - C language X Interface</em>, которое поставляется с вашим X дистрибутивом, спецификацией <em>X Window System Protocol</em>, а также различные руководства и документация по X. Каталог <span class="mono">/usr/share/doc</span> содержит ссылки на эти и многие другие  документы.</p>
<p>Многие другие утилиты, оконные менеджеры, игры, пособия и гаджеты включены распределением X Consortium как дополнительное пользовательское программное обеспечение, или доступны с помощью анонимного ftp по Интернету. Хорошими местами для начала являются <noindex>http://www.x.org и http://www.xfree.org</noindex>.</p>
<p>Кроме того, все ваши графические приложения, такие как браузер, программа для электронной почты, программа для просмотра изображений, инструменты для проигрывания звуков и так далее являются клиентами X сервера. Отметим, что в обычных условиях эксплуатации графического режима X клиенты и X сервер Linux работают на одной и той же машине.</p>
<h3>Имена дисплеев</h3>
<p>С точки зрения пользователя, у каждого X сервера есть отображаемое имя в такой форме:</p>
<p><span class="mono">hostname:displaynumber.screennumber</span></p>
<p>Эта информация используется приложением для определения того, как ему следует соединиться с X сервером и какой экран он должен использовать по умолчанию (на настольных компьютерах с несколькими мониторами):</p>
<ul>
<li><em>hostname</em>: Имя хоста указывает имени компьютера-клиента, какой дисплей физически подключен. Если имя хоста не задано, будет использоваться наиболее целесообразный способ общения к серверу на одной и той же машине.</li>
<li><em>displaynumber</em>: Фраза "display", обычно используется для обозначения коллекции мониторов, которые разделяют общие клавиатуру и указатель (мышь, планшет, и т.д.). У большинства рабочих станций, как правило, только одна клавиатура, и, следовательно, только один дисплей. Большие многопользовательские системы, однако, часто имеют несколько дисплеев, так что группа людей сразу могут выполнять графическую работу. Чтобы избежать путаницы, каждому дисплею компьютера присваивается номер (начиная с 0), когда запускается X сервер для этого дисплея. Номер дисплея должен всегда быть приведен в отображаемом имени.</li>
<li><em>screen number</em>: Некоторые дисплеи разделяют одну клавиатуру и указатель между двумя или более мониторами. Так как у каждого монитора есть собственный ряд окон, каждому экрану присваивается номер (начиная с 0), когда запускается X сервер для данного дисплея. Если номер экрана не указан, будет использоваться экран 0.</li>
</ul>
<p>В POSIX-системах имя дисплея по умолчанию хранится в переменной окружения <span class="mono">DISPLAY</span>. Эта переменная автоматически устанавливается эмулятором терминала <strong>xterm</strong>. Однако, когда вы по сети входите на другой компьютер, может потребоваться установить <span class="mono">DISPLAY</span> вручную, чтобы указать на ваш дисплей, смотрите <a href="http://younglinux.info/#">Раздел "Telnet и X"</a>.</p>
<p>Более подробную информацию можно найти в man-страницах для X.</p>
<h3>Менеджеры окон и рабочего стола</h3>
<p>Расположение окон на экране находится под контролем специальных программ, которые называются оконными менеджерами. Хотя многие оконные менеджеры соблюдают предоставленные геометрические характеристики экрана, существуют такие, которые могут их игнорировать (требуя от пользователя точного указания области окна на экране с помощью указателя, например).</p>
<p>Поскольку оконные менеджеры обычные (хотя и сложные) клиентские программы, могут быть построены разнообразные пользовательские интерфейсы. От X Consortium предоставляется оконный менеджер под названием <strong>twm</strong>, но большинство пользователей предпочитают что-то более изощренное, когда позволяют ресурсы системы. Sawfish и Enlightenment являются популярными примерами, которые позволяют каждому пользователю иметь рабочий стол под соответствующее настроение и стиль.</p>
<p>Менеджер рабочего стола использует один или другой оконный менеджер для организации вашего графического экрана в удобном виде, с панелями, выпадающими меню, информационными сообщениями, часами, менеджерами программ, файловыми менеджерами и т.д. Среди наиболее популярных менеджеров рабочего стола выделяют Gnome и KDE, оба работают почти на любом дистрибутиве Linux и многих других UNIX-системах.</p>
<p class="note"><img src="../../../img/linuxintro/tip.gif" alt="" /><strong> Приложения KDE в Gnome/приложений Gnome в KDE</strong><br />
Вам не обязательно запускать рабочий стол KDE для того, чтобы иметь возможность запускать приложения KDE. Если у вас установлены библиотеки KDE (пакет kdelibs), вы можете запустить эти приложения из меню Gnome или его терминала.<br />
Запуск приложений Gnome в среде KDE немного сложнее, потому что нет единого набора базовых библиотек в Gnome. Однако при запуске или установке таких приложений станут ясны зависимости и, следовательно, дополнительные пакеты, которые вам, возможно, придется установить.
</p>
<h2>Конфигурация X сервера</h2>
<p>Распределение X, которое поставляется с Linux, XFree86, использует конфигурационный файл <span class="mono">XF86Config</span> для ее начальной установки. Этот файл настраивает вашу видеокарту и может быть найден в ряде мест, хотя обычно это <span class="mono">/etc/X11</span>.</p>
<p>Если вы видите, что файл <span class="mono">/etc/X11/XF86Config</span> присутствует в вашей системе, полное описание можно найти в info- или man-страницах о <span class="mono">XF86Config</span>.</p>
<p>Из-за проблем с лицензированием XFree86, более новые системы обычно поставляются с вариантом X сервера и инструментов от <em>X.Org</em>. Главный конфигурационный файл здесь xorg.conf, обычно находится также в <span class="mono">/etc/X11</span>. Файл состоит из нескольких разделов, которые могут находиться в любом порядке. Разделы содержат информацию о вашем мониторе, видеоадаптере, конфигурации экрана, клавиатуры и т.д. В качестве пользователя, вам не надо слишком беспокоиться о том, что в этом файле, так как все обычно определяется на момент, когда система установлена.</p>
<p>Однако, если вам потребуется изменить настройки графического сервера, вы можете запустить инструменты для настройки или редактировать конфигурационный файл, которые обеспечивает инфраструктуру для использования сервера XFree86. Смотрите man-страницы для получения дополнительной информации; у вашего дистрибутива могут быть собственные инструменты. Поскольку неверная конфигурация может привести к нечитаемой чуши в графическом режиме, вам следует сделать резервную копию конфигурационного файла, чтобы обезопасить себя, прежде, чем приступать к его изменению.</p>
  </div>
<div id="node-271" class="section-3">
  <h1 class="book-heading">Разные специфичные настройки</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<h2>Настройка клавиатуры</h2>
<p>Настройка раскладки клавиатуры для текстовых консолей производится с помощью команды <strong>loadkeys</strong>. Используйте ваши локальные инструменты конфигурации X или изменяйте раздел <em>Keyboard</em> в <span class="mono">XF86Config</span> вручную, чтобы настроить раскладку для графического режима. <span class="mono">XkbdLayout</span> является тем, что вам требуется установить:</p>
<pre>XkbLayout       "us"</pre><p>
Это по умолчанию. Измените на ваши локальные настройки путем замены значения в кавычках на любые имена, перечисленные в подкаталогах папки <span class="mono">keymaps</span>. Если вы не можете найти <span class="mono">keymaps</span>, попробуйте отобразить их местонахождение в вашей системе с помощью команды</p>
<p><span class="mono">locate keymaps </span></p>
<p>Можно комбинировать настройки раскладки, как показано в этом примере:</p>
<pre>
Xkblayout      "us,ru"
</pre><p>Сделайте резервную копию файла <span class="mono">/etc/X11/XF86Config</span> перед его редактированием! Чтобы сделать это, вам придется использовать аккаунт суперпользователя.</p>
<p>Выйдите и снова войдите в систему, чтобы перезагрузить настройки X.<br />
Апплет клавиатуры Gnome позволяет в режиме реального времени переключаться между раскладками, для использования этой программы специальных разрешений не требуется. KDE также имеет подобный инструмент для переключения между раскладками клавиатуры.</p>
<h2>Шрифты</h2>
<p>Используйте инструмент <strong>setfont</strong> для загрузки шрифтов в текстовом режиме. Большинство систем поставляются со стандартным файлом <span class="mono">inputrc</span>, который позволяет сочетание символов, таких как французский "?" (метасимволы). Для этого системный администратор должен добавить строку</p>
<pre>
export INPUTRC="/etc/inputrc"
</pre><p>к файлу <span class="mono">/etc/bashrc</span>.</p>
<h2>Зона даты и времени</h2>
<p>Настройка информации о времени обычно происходит во время установки. После этого, она постоянно соответствует текущей дате за счет использования клиента <em>NTP</em> (Network Time Protocol). Большинство Linux системы запускают <strong>ntpd</strong> по умолчанию:</p>
<pre>
debby:~> <strong>ps -ef | grep ntpd</strong>
ntp      24678     1  0  2002 ?        00:00:33 ntpd -U ntp
</pre><p>
Вы можете запустить <strong>ntpdate</strong> вручную, чтобы установить время, при условии, что можете подсоединиться к серверу времени. Демон <strong>ntpd</strong> не должен быть запущен, когда вы устанавливаете время с использованием <strong>ntpdate</strong>. Используйте сервер времени в качестве аргумента для команды:</p>
<pre>
root@box:~# <strong>ntpdate 10.2.5.200</strong>
26 Oct 14:35:42 ntpdate[20364]: adjust time server 10.2.5.200 offset
 -0.008049 sec
</pre><p>
Смотрите ваши системные руководства и документацию, которые поставляются с пакетом NTP. Большинство менеджеров рабочего стола включают инструменты для установки системного времени при условии, что у вас есть доступ к учетной записи системного администратора.</p>
<p>Для установки правильного часового пояса, вы можете использовать команды <strong>tzconfig</strong> или <strong>timezone</strong>. Обычно информация о часовом поясе задается во время установки вашей операционной системы. Многие системы имеют специфичные  для дистрибутива инструменты для настройки; обратитесь к документации по системе.</p>
<h2>Язык</h2>
<p>Если вы предпочитаете получать сообщения от системы на голландском или французском языке, то можете установить переменные окружения <span class="mono">LANG</span> и <span class="mono">LANGUAGE</span>, что позволит поддерживать нужный язык и, в конечном итоге, шрифты, связанные с символами на этом языке.</p>
<p>В большинстве графических систем входа, таких как <strong>gdm</strong> или <strong>kdm</strong>, у вас есть возможность настроить параметры языка до входа в учетную запись.</p>
<p>Обратите внимание, сейчас на большинстве систем по умолчанию имеется тенденция к использованию <em>en_US.UTF-8</em>. Это не проблема, потому что системы, где такое существует по умолчанию, будут также поставляться со всеми программами, поддерживающими эту кодировку. Таким образом, <strong>vi</strong> может редактировать все файлы на вашей системе, а <strong>cat</strong> не будет вести себя странно и т.п.</p>
<p>Проблема начинается тогда, когда вы подключаетесь к более старой системе, не поддерживающей эту кодировку шрифта, или при открытии файла, закодированного с помощью <em>UTF-8</em>, на системе, поддерживающей шрифты, у которых символы кодируются 1 байтом. Может пригодиться утилита <strong>recode</strong> для конвертирования файлов из одного ряда символов в другой. Читайте man-страницы для обзора возможностей и их использования. Другим решением может быть временная работа в другой кодировке, настроив для этого переменную окружения <span class="mono">LANG</span>:</p>
<pre>
debby:~> <strong>acroread /var/tmp/51434s.pdf</strong>
Warning: charset "UTF-8" not supported, using "ISO8859-1".
Aborted

debby:~> <strong>set | grep UTF</strong>
LANG=en_US.UTF-8

debby:~> <strong>export LANG=en_US</strong>

debby:~> <strong>acroread /var/tmp/51434s.pdf</strong>
&lt;--new window opens-->
</pre>  </div>
<div id="node-272" class="section-3">
  <h1 class="book-heading">Установка нового ПО</h1>
  <p class="right">Introduction to Linux. A Hands on Guide —<br />
Введение в Linux. Руководство по работе</p>
<h3>Общее</h3>
<p>Большинство людей с удивлением видит, что у них после установки Linux оказывается рабочий, пригодный для использования компьютер; в большинстве дистрибутивов поддерживается большинство видео и сетевых карт, мониторов и других внешних устройств, так что, как правило, не требуется установка дополнительных драйверов. Кроме обычных инструментов, таких как офисные пакеты, веб-браузеры, электронная почта и другие программы в наиболее распространенные дистрибутивы включены  клиентские сетевые программы. Тем не менее, начальные установки могут не соответствовать вашим требованиям.</p>
<p>Если вы не можете найти то, что вам нужно, то может быть, это просто не установлено в системе. Также может случиться, что у вас есть необходимое программное обеспечение, но оно делает не то, что должно делать. Помните, что Linux быстро развивается, и программное обеспечение улучшается ежедневно. Не стоит тратить время  на устранение проблем, которые могут быть уже решены.</p>
<p>Вы можете обновить вашу систему или добавить пакеты в нее в любое время. Большинство программного обеспечения поставляется в пакетах. Дополнительное программное обеспечение может быть найдено на установочных компакт-дисках или в Интернете. Веб-сайт вашего дистрибутива Linux является хорошим местом для начала поиска дополнительного программного обеспечения и содержит инструкции о том, как установить что-то на ваш Linux, см. <a href="http://younglinux.info/#">Приложение A, Куда идти дальше?</a>. Всегда читайте документацию, которая поставляется с новой программой, т.к. там могут находиться какие-нибудь руководства по установке пакета. Все программное обеспечение поставляется с файлом <span class="mono">README</span>, который вам очень настоятельно рекомендуется к прочтению.</p>
<h3>Форматы пакетов</h3>
<h4>Пакеты RPM</h4>
<h5>Что такое RPM?</h5>
<p>RPM, RedHat Package Manager, представляет собой мощный менеджер пакетов, который вы можете использовать для установки, обновления и удаления пакетов. Он позволяет вам находить пакеты и отслеживает файлы, которые поставляются с каждым пакетом. Система построена таким образом, что вы можете проверить подлинность пакетов, скаченных из Интернета. Опытные пользователи могут создавать свои собственные пакеты RPM.</p>
<p>Пакет RPM состоит из архива файлов и метаданных, используемых для установки и удаления файлов архива. Метаданные включают вспомогательные скрипты, атрибуты файлов, и информацию со сведениями о пакете. Пакеты выпускаются в двух вариантах: бинарные, используется для упаковки программного обеспечения для установки, и пакеты с исходным кодом и предписанием, необходимым для создания бинарных пакетов.</p>
<p>Многие другие дистрибутивы поддерживают пакеты RPM, среди популярных - RedHat Enterprise Linux, Mandriva (бывший Mandrake), Fedora Core и SuSE Linux. Помимо советов для вашего дистрибутива, вы захотите прочитать <strong>man</strong> <span class="monoi">rpm</span>.</p>
<h5>Примеры работы с RPM</h5>
<p>Большинство пакетов просто устанавливаются при использовании опции обновления <span class="mono">-U</span>, и не важно установлен уже пакет или нет. Пакет RPM содержит полную версию программы, которая перезаписывает существующую версию или инсталлируется как новый пакет. Типичное использование выглядит следующим образом:</p>
<p><span class="mono">rpm -Uvh /path/to/rpm-package(s)</span></p>
<p>Опция <span class="mono">-v</span> генерирует более подробный вывод, <span class="mono">-h</span> заставляет <strong>rpm</strong> выводить индикатор прогресса установки:</p>
<pre>
[root@jupiter tmp]# <strong>rpm -Uvh totem-0.99.5-1.fr.i386.rpm</strong>
Preparing...                ########################################### [100%]
   1:totem                  ########################################### [100%]
[root@jupiter tmp]#
</pre><p>При этом новые пакеты ядра, устанавливаются с опцией <span class="mono">-i</span>, которая не перезаписывает существующую версию пакета. Таким образом, вы по-прежнему сможете загрузить систему со старым ядром, если новое окажется не рабочим.<br />
Вы также можете использовать rpm для проверки, установлен ли пакет в вашей системе:</p>
<pre>
[david@jupiter ~] <strong>rpm -qa | grep vim</strong>
vim-minimal-6.1-29
vim-X11-6.1-29
vim-enhanced-6.1-29
vim-common-6.1-29
</pre><p>
Или вы можете узнать, какой пакет содержит определенный файл или исполняемый файл:</p>
<pre>
[david@jupiter ~] <strong>rpm -qf /etc/profile</strong>
setup-2.5.25-1

[david@jupiter ~] <strong>which cat</strong>
cat is /bin/cat

[david@jupiter ~] <strong>rpm -qf /bin/cat</strong>
coreutils-4.5.3-19
</pre><p>
Заметьте, вам не нужно иметь доступ к административным привилегиям, чтобы использовать rpm для запроса к базе данных RPM. Аккаутн root требуется только при добавлении, изменении или удалении пакетов.<br />
Ниже приведен еще один пример, демонстрирующий, как удалить пакет при помощи <strong>rpm</strong>:</p>
<pre>
[root@jupiter root]# <strong>rpm -e totem</strong>
[root@jupiter root]#
</pre><p>Обратите внимание, что удаление по умолчанию происходит без подробностей, это нормально, что вы не видите многое из того, что происходит. Если вы сомневаетесь, используйте <strong>rpm</strong> <span class="mono">-qa</span> опять, чтобы убедиться, что пакет был удален.</p>
<p>RPM может делать гораздо больше, чем те несколько основных функций, которые мы привели здесь.</p>
<h4>Пакеты DEB (.deb)</h4>
<h5>Что из себя представляют пакеты Debian?</h5>
<p>Этот формат пакетов используется по умолчанию в Debian GNU/Linux, где <strong>dselect</strong>, и, в настоящее время все более распространенный, <strong>aptitude</strong> являются стандартными инструментами для управления пакетами. Они используются для выбора пакетов, которые вы хотите установить или обновить, но также работают во время установки системы Debian и помогают вам определить метод доступа для использования, список доступных пакетов и их настройки.</p>
<p>Веб-сайт Debian содержит всю необходимую информацию.</p>
<p>Формат пакетов Debian становится все более и более популярным. Также <strong>apt-get</strong> становится популярным на не-DEB системах.</p>
<h5>Примеры с инструментами DEB</h5>
<p>Проверка, установлен ли пакет, осуществляется с помощью команды <strong>dpkg</strong>. Например, если вы хотите узнать, какая версия Gallery установлена на вашем компьютере, то следует выполнить такую команду:</p>
<pre>
nghtwsh@gorefest:~$ <strong>dpkg -l *gallery*</strong>
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Installed/Config-files/Unpacked/Failed-config/Half-installed
|/ Err?=(none)/Hold/Reinst-required/X=both-problems (Status,Err: uppercase=bad)
||/ Name           Version        Description
+++-==============-==============-============================================
ii  gallery        1.5-1sarge2    a web-based photo album written in php
</pre><p>Префикс "ii" означает, что пакет установлен. Если вы увидите префикс "un", это означает, что пакет известен в списке, который поддерживает ваша система, но не установлен.</p>
<p>Поиск, какому пакету принадлежит файл, выполняется путем использования <span class="mono">-S</span> для <strong>dpkg</strong>:</p>
<pre>
nghtwsh@gorefest:~$ <strong>dpkg -S /bin/cat</strong>
coreutils: /bin/cat
</pre><p>
Больше информации можно найти на info-страницах <strong>dpkg</strong>.</p>
<h4>Пакеты с исходным кодом</h4>
<p>Наибольшая часть программ Linux является Free/Open Source, что означает, что  пакеты с исходными кодами доступны для этих программ. Исходники необходимы для компиляции собственного варианта программы. Истодные коды программы можно скачать с ее веб-сайта, обычно в виде сжатого архива (<span class="mono">program-version.tar.gz</span> или аналогичного). Для дистрибутивов, основанных на RPM, исходники часто поставляются как <span class="mono">program-version.src.rpm</span>. Debian и большинство дистрибутивов на его основе, предоставляют для себя адаптированные исходники, который можно получить с помощью <strong>apt-get <span class="monoi">source</span></strong>.</p>
<p>Особые требования, зависимости и инструкции по установке приведены в файле <span class="mono">README</span>. Вам, вероятно, понадобится компилятор с языка C <strong>gcc</strong>. Этот компилятор GNU входит в большинство систем Linux и портирован на множество других платформ.</p>
<h3>Автоматизация управления пакетами и обновлениями</h3>
<h4>Общие замечания</h4>
<p>Первое, что вы делаете после установки новой системы, - это обновляете ее; это относится ко всем операционным системам и Linux не исключение.</p>
<p>Обновления для большинства систем Linux обычно могут быть найдены на ближайшем сайте-зеркале вашего дистрибутива. Списки сайтов, предлагающих такую возможность, можно найти на веб-сайте вашего дистрибутива, см. <a href="http://younglinux.info/#">Приложение A, Куда идти дальше?</a>.</p>
<p>Обновления следует применять регулярно, если это возможно, то ежедневно, но можно начать с того, чтобы проводить обновление каждые несколько недель. Вы действительно должны стремиться к тому, чтобы иметь самую последнюю версию дистрибутива, так как Linux изменяется постоянно. Как было прежде отмечено, появление новых возможностей, улучшений и исправлений ошибок происходит регулярно, иногда решаются важные проблемы безопасности.</p>
<p>Хорошей новостью является то, что большинство дистрибутивов Linux предоставляют инструменты, поэтому вам не придется ежедневно обновлять десятки пакетов вручную. Следующие разделы дают обзор менеджеров пакетов. Это достаточно обширная тема, даже регулярные обновления пакетов с исходными кодами управляются автоматически; мы перечислим лишь наиболее широко известных системы. Всегда обращайтесь к документации для вашего конкретного дистрибутива для выяснения действий.</p>
<h4>APT</h4>
<p>Advanced Package Tool является системой управления пакетами программного обеспечения. Команда инструмента для обработки пакетов – <strong>apt-get</strong>, который поставляется с превосходной man-страницей, описывающей как установить и обновить пакеты или весь дистрибутив. APT зародился в дистрибутиве Debian GNU/Linux, где он по умолчанию является менеджером пакетов. Также APT был портирован для работы с пакетами RPM. Главное преимущество APT заключается в том, что он является свободным и гибким в использовании. Это позволит вам создать системы, подобные конкретным дистрибутивам (и в некоторых случаях коммерческие), перечисленные в следующих разделах.</p>
<p>Как правило, при первом использовании <strong>apt-get</strong>, вы должны будете получить индекс доступных пакетов. Это делается с помощью команды</p>
<p><span class="mono">apt-get update</span></p>
<p>После этого, вы можете использовать <strong>apt-get</strong> для обновления вашей системы:</p>
<p><span class="mono">apt-get upgrade</span> </p>
<p>Делайте это часто, это легкий способ сохранять вашу систему современной и, следовательно, безопасной.</p>
<p>Помимо этого общего пользования, <strong>apt-get</strong> также очень быстр для установки отдельных пакетов. Вот как это работает:</p>
<pre>
[david@jupiter ~] <strong>su - -c "apt-get install xsnow"</strong>
Password:
Reading Package Lists... Done
Building Dependency Tree... Done
The following NEW packages will be installed:
  xsnow
0 packages upgraded, 1 newly installed, 0 removed and 3 not upgraded.
Need to get 33.6kB of archives.
After unpacking 104kB of additional disk space will be used.
Get:1 <span class="geshifilter"><code class="python geshifilter-python">http://ayo.<span style="color: black;">freshrpms</span>.<span style="color: black;">net</span></code></span> redhat/9/i386/os xsnow 1.42-10 [33.6kB]
Fetched 33.6kB in 0s (106kB/s)
Executing RPM (-Uvh)...
Preparing...                ########################################### [100%]
   1:xsnow                  ########################################### [100%]
</pre><p>
Обратите внимание на опцию <span class="mono">-c</span> команды <strong>su</strong>, которая указывает, чтобы shell администратора выполнила только эту команду, а затем вернуться к среде пользователя. Таким образом, у вас не получится забыть осуществить выход из учетной записи суперпользователя.</p>
<p>Если существуют какие-либо зависимости от других пакетов, <strong>apt-get</strong> загрузит и установит эти вспомогательные пакеты.</p>
<h4>Системы, использующие пакеты RPM</h4>
<p>Update Agent, который изначально поддерживал только пакеты RPM RedHat, теперь перенесен на более широкий набор программного обеспечения, в том числе не-RedHat репозитории. Этот инструмент предоставляет полную систему для обновления RPM пакетов на системах RedHat или Fedora Core. Для обновления вашей системы в командной строке следует ввести <strong>up2date</strong>. На рабочем столе по умолчанию активируется маленький значок, говорящий вам, нет ли обновлений для вашей системы.</p>
<p>Yellowdog's Updater Modified (<strong>yum</strong>) является еще одним инструментом, который в последнее время стал достаточно популярным. Это интерактивная, но автоматически работающая программа для инсталляции, обновления или удаления пакетов RPM в системе. Этот инструмент выбран на системах Fedora.</p>
<p>В SuSE Linux, все это делается с YaST, Yet another Setup Tool, который поддерживает широкий спектр задач системного администрирования, среди которых и обновление RPM пакетов. Начиная с SuSE Linux 7.1 вы можете производить обновление также с помощью веб-интерфейса и YOU, Yast Online Update.</p>
<p>Mandrake Linux и Mandriva предоставлять так называемые URPMI инструменты, ряд программ-оберток, которые делают установку нового программного обеспечения проще для пользователя. Эти инструменты в сочетании с RPMDrake и MandrakeUpdate обеспечить все необходимое для упрощения установки и удаления пакетов программного обеспечения. MandrakeOnline предлагает расширенный спектр услуг и может автоматически уведомлять администраторов, когда обновления доступны для вашей конкретной системы. Помимо прочего посмотрите <strong>man</strong> <span class="monoi">urpmi</span> для дополнительной информации.</p>
<p>Также среды KDE и Gnome имеют собственные (графический) варианты пакетных менеджеров.</p>
<h3>Обновление ядра</h3>
<p>Большинство установок в Linux протекает без проблем, если вы периодически обновляете ваш дистрибутив. Процедура обновления при необходимости установит новое ядро и сделает все необходимые изменения в вашей системе. Вам придется компилировать или устанавливать новое ядро вручную, если вам нужны функции ядра, которые не включены в ядро вашего дистрибутива Linux по умолчанию.</p>
<p>Компилируете ли вы собственное оптимизированное ядро или используете предварительно скомпилированный пакет ядра, установите его так, чтобы старое и новое ядра существовали вместе, пока вы не убедитесь, что все работает как надо.</p>
<p>Затем создайте двойную загрузку системы, что позволит вам выбрать ядро для загрузки, обновив загрузочный конфигурационный файл <span class="mono">grub.conf</span>. Вот простой пример:</p>
<pre>
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making config changes. 
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, e.g.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/hde8
#          initrd /initrd-version.img
#boot=/dev/hde
default=0
timeout=10
splashimage=(hd0,0)/grub/splash.xpm.gz
title Red Hat Linux new (2.4.9-31)
	root (hd0,0)
	kernel /vmlinuz-2.4.9-31 ro root=/dev/hde8
	initrd /initrd-2.4.9-31.img
title old-kernel
        root (hd0,0)
        kernel /vmlinuz-2.4.9-21 ro root=/dev/hde8
        initrd /initrd-2.4.9-21.img
</pre><p>
После того, как новое ядро окажется рабочим, вы можете удалить строки для загрузки старого из конфигурационного файла GRUB, хотя лучше подождать пару дней, просто чтобы быть уверенным.</p>
<h3>Установка дополнительных пакетов с установочных CD</h3>
<h4>Монтирование CD</h4>
<p>В основном это происходит так же, как и установка пакетов вручную, кроме того, вы должны добавить файловую систему CD к файловой системе вашего компьютера, чтобы сделать ее доступной. На большинстве систем, это будет сделано автоматически при вставке компакт-диска в привод, потому что во время загрузки запускается демон automount. Если ваш компакт-диск не становится доступным автоматически, выполните команду mount в окне терминала. В зависимости от вашей конкретной системной конфигурации, строка, подобная этой, обычно делает свое дело:</p>
<p><span class="mono">mount /dev/cdrom /mnt/cdrom</span></p>
<p>На некоторых системах только суперпользователь может монтировать сменные носители, это зависит от конфигурации.</p>
<p>Для того, чтобы все происходило автоматически, устройство для чтения CD обычно имеет запись в <span class="mono">/etc/fstab<span>, в котором перечислены файловые системы и их точки монтирования, в результате чего получается дерево файловой системы. Вот подобная строка:</span></span></p>
<pre>
[david@jupiter ~] <strong>grep cdrom /etc/fstab</strong>
/dev/cdrom	/mnt/cdrom	iso9660		noauto,owner,ro 0 0
</pre><p>
Это означает, что система будет понимать команду <strong>mount</strong> <span class="mono">/mnt/cdrom</span>. Опция <span class="mono">noauto</span> означает, что на этой системе компакт-диски не монтируются во время загрузки.</p>
<p>Вы даже можете попробовать щелкнуть правой кнопкой мыши на значке компакт-диска на рабочем столе для монтирования CD, если ваш файловый менеджер не сделает это за вас. Вы можете проверить, сработало ли это, с помощью команды mount без аргументов:</p>
<pre>
[david@jupiter ~] <strong>mount | grep cdrom</strong>
/dev/cdrom on /mnt/cdrom type iso9660 (ro,nosuid,nodev)
</pre><h4>Использование CD</h4>
<p>После монтирования CD, вы можете перемещаться по его каталогам, как правило, в точке монтирования <span class="mono">/mnt/cdrom</span>, где вы можете получить доступ к содержимому CD-ROM. Используйте те же команды для работы с файлами и каталогами, какие вы бы использовали для файлов на жестком диске.</p>
<h4>Извлечение CD</h4>
<p>Для того, чтобы вытащить компакт-диск из дисковода после того, как вы закончили использовать его, файловая система CD не должна использоваться. Даже нахождение в одном из подкаталогов точки монтирования, <span class="mono">/mnt/cdrom</span> в нашем примере, будет рассматриваться как "использование файловой системы", поэтому вам следует выйти оттуда. Сделайте это, например, введя <strong>cd</strong> без аргументов, эта команда вернет вас обратно в домашний каталог. После этого, вы можете использовать команду</p>
<p><span class="mono">umount /mnt/cdrom</span></p>
<p>или</p>
<p><span class="mono">eject cdrom</span></p>
<p class="note"><img src="../../../img/linuxintro/warning.gif" alt="" /><strong> Заблокированные диски</strong><br />
Никогда не применяйте силу к дисководу. Трюк со скрепкой является плохой идеей, и хотя это, в конечном итоге, выдернет CD, но ваша система будет думать, что CD по-прежнему там, т.к. обычные процедуры не были соблюдены. Скорее всего, вам придется перезагрузиться, чтобы привести систему в согласованное состояние.<br />
Если вы продолжаете получать сообщения "устройство занято", сначала проверьте, что все сессии shell вышли из файловой системы CD, а также графические приложения не используют его больше. Если есть сомнения, используйте инструмент <strong>lsof</strong>, чтобы убрать процесс(ы), которые продолжают использовать ресурсы компакт-диска.</p>
  </div>
<div id="node-283" class="section-3">
  <h1 class="book-heading">Резюме</h1>
  <p>Если вы дошли до этого места, то это значит, что половина работы уже сделана.</p>
<p>Хотя поддержание порядка имеет важное значение, не менее важно, чтобы вы чувствовали себя как дома в вашей среде, будь она текстовой или графической. Текстовое окружение контролируется с помощью установочных файлов оболочки. Графическая среда, в первую очередь, зависит от конфигурации X сервера, от которого зависит ряд других приложений, например, окна, менеджеры рабочего стола и графические приложения, и у каждого из них есть собственный конфигурационный файл. Вам следует почитать документацию к системе и программам, чтобы узнать о том, как их настраивать.</p>
<p>Региональные настройки, такие как настройку клавиатуры, установку соответствующих шрифтов и поддержку языка, лучше сделать во время установки.</p>
<p>Программное обеспечение управляется либо автоматически, либо вручную с помощью системы пакетов.</p>
<p>В этой главе описывались следующие команды:</p>
<p><strong>Таблица 7.2. Новые команды главы 7: Создай себе дом</strong></p>
<table class="il">
<tr>
<td width="100"><strong>Команда</strong></td>
<td><strong>Значение</strong></td>
</tr>
<tr>
<td><strong>aptitude</strong></td>
<td>Управление пакетами в стиле Debian</td>
</tr>
<tr>
<td><strong>automount</strong></td>
<td>Автоматическое подключение вновь добавленной файловой системы</td>
</tr>
<tr>
<td><strong>dpkg</strong></td>
<td>Пакетный менеджер Debian</td>
</tr>
<tr>
<td><strong>dselect</strong></td>
<td>Управление пакетами в стиле Debian</td>
</tr>
<tr>
<td><strong>loadkeys</strong></td>
<td>Загрузка конфигурации клавиатуры</td>
</tr>
<tr>
<td><strong>lsof</strong></td>
<td>Определяет процессы</td>
</tr>
<tr>
<td><strong>mount</strong></td>
<td>Подключает новые файловые системы к существующему дереву каталогов</td>
</tr>
<tr>
<td><strong>ntpdate</strong></td>
<td>Устанавливает системное время и дату использования времени сервера</td>
</tr>
<tr>
<td><strong>quota</strong></td>
<td>Отображает информацию о разрешенном к использованию дисковом пространстве</td>
</tr>
<tr>
<td><strong>recode</strong></td>
<td>Конвертирует файлы в другие таблицы символов</td>
</tr>
<tr>
<td><strong>rpm</strong></td>
<td>Управление RPM-пакетами</td>
</tr>
<tr>
<td><strong>setfont</strong></td>
<td>Выбор шрифтов</td>
</tr>
<tr>
<td><strong>timezone</strong></td>
<td>Установка временной зоны</td>
</tr>
<tr>
<td><strong>tzconfig</strong></td>
<td>Установка временной зоны</td>
</tr>
<tr>
<td><strong>ulimit</strong></td>
<td>Установка или отображение ограничения ресурсов</td>
</tr>
<tr>
<td><strong>up2date</strong></td>
<td>Управление RPM-пакетами</td>
</tr>
<tr>
<td><strong>urpmi</strong></td>
<td>Управление RPM-пакетами</td>
</tr>
<tr>
<td><strong>yum</strong></td>
<td>Управление RPM-пакетами</td>
</tr>
</table>
  </div>
<div id="node-284" class="section-3">
  <h1 class="book-heading">Упражнения</h1>
  <h3>Окружение Shell</h3>
<ul>
<li>Выведите ваши настройки окружения. Какую переменную можно использовать для хранения типа процессора вашей машины?</li>
<li>Создайте скрипт, который может выдать строку типа "Hello, World". Дайте ему соответствующие разрешения, чтобы его можно было запустить. Проверьте свой сценарий.</li>
<li>Создайте папку в вашем домашнем каталоге и переместите скрипт в новую директорию. Добавить эту новую директорию в путь поиска на постоянной основе. Проверьте, что сценарий может быть выполнен без указания пути  его фактического нахождения.</li>
<li>Создайте подкаталоги в домашнем каталоге для хранения различных файлов, например, папку <span class="mono">music</span> для хранения аудио файлов, папку <span class="mono">documents</span> для заметок, и т.д. И используйте их!</li>
<li>Создайте собственную строку приглашения.</li>
<li>Отобразите ограничения на использование ресурсов. Вы можете изменить их?</li>
<li>Попробуйте прочитать сжатые man-страницы без предварительной их распаковки.</li>
<li>Сделать псевдоним <strong>lll</strong> для команды <strong>ls <span class="mono">-la</span></strong>.</li>
<li>Почему команда <strong>tail <span class="mono">testfile > testfile</span></strong> не работает?</li>
<li>Подключите CD с данными, например, установочный компакт-диск с Linux, и посмотрите, что на нем. Не забудьте отключить его, когда он вам больше не будет нужен.</li>
<li>Скрипт из <a href="http://younglinux.info/#">Раздела "Некоторые простые примеры"</a> не совсем корректный. Он выдает ошибки для файлов, которые являются каталогами. Измените сценарий так, чтобы он выбирал только текстовые файлы для копирования. Чтобы делать выбор, используйте <strong>find</strong>. Не забудьте сделать скрипт исполняемым, прежде чем пытаться запустить его.</li>
</ul>
<h3>Графическое окружение</h3>
<ul>
<li>Попробуйте все кнопки мыши в различных местах (терминале, фоне, панели задач).</li>
<li>Исследуйте меню.</li>
<li>Настройте окно вашего терминала.</li>
<li>Используйте кнопки мыши для копирования и вставки текста из одного терминала в другой.</li>
<li>Узнайте, как настроить ваш оконный менеджер; попробуйте различные рабочие столы (виртуальные экраны).</li>
<li>Добавьте на панель задач апплет монитора загрузки.</li>
<li>Примените другую тему оформления.</li>
<li>Включите так называемый мокрый фокус, когда окно активизируется всего лишь перемещением мыши над ним, так что вам не приходится нажимать на него, чтобы оно стало активным.</li>
<li>Переключитесь на другой менеджер окон.</li>
<li>Выйдите из системы и выберите другой тип сессии, например, KDE, если вы использовали Gnome до этого. Повторите предыдущие шаги.</li>
</ul>
  </div>
</div>
    </div>
  </body>
</html>
